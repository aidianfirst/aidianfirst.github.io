<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哀殿firstの空间</title>
  
  <subtitle>文字avg+悬疑推理爱好者</subtitle>
  <link href="http://aidianfirst.com/atom.xml" rel="self"/>
  
  <link href="http://aidianfirst.com/"/>
  <updated>2024-01-18T13:52:03.365Z</updated>
  <id>http://aidianfirst.com/</id>
  
  <author>
    <name>aidianfirst</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring</title>
    <link href="http://aidianfirst.com/2023/12/08/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spring/"/>
    <id>http://aidianfirst.com/2023/12/08/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spring/</id>
    <published>2023-12-08T09:33:35.781Z</published>
    <updated>2024-01-18T13:52:03.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring主要加载链路分析"><a href="#Spring主要加载链路分析" class="headerlink" title="Spring主要加载链路分析"></a>Spring主要加载链路分析</h1><h2 id="包扫描"><a href="#包扫描" class="headerlink" title="包扫描"></a>包扫描</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>application.run =&gt; prepareEnvironment 准备环境</p><ul><li>发布事件 BootstrapApplicationListener =&gt; bootstrap 会触发一个application.run</li></ul></li><li><p>bootstrap的run执行完后，继续执行原application.run，也就是prepareEnvironment 处理完后，refreshContext刷新上下文</p></li><li><p>AbstractApplicationContext #invokeBeanFactoryPostProcessors</p></li><li><p>PostProcessorRegistrationDelegate #invokeBeanDefinitionRegistryPostProcessors</p><ul><li>for 后置处理器 #postProcessBeanDefinitionRegistry</li></ul></li><li><p>ConfigurationClassPostProcessor #processConfigBeanDefinitions</p><ul><li>BeanDefinitionRegistry注册表 获取初始BeanDefinition</li><li>for 校验获取可用配置类，一般都是项目的启动类</li><li>分析配置类 319行 <strong>parser.parse(…) =&gt; processConfigurationClass()</strong></li></ul></li><li><p>ConfigurationClassParser <strong>#doProcessConfigurationClass</strong> 289行开始根据扫描路径开始扫描包</p><ul><li>296行 ComponentScanAnnotationParser #parse 包扫描解析，根据ComponentScan注解配置对扫描器进行配置，然后执行扫描 scanner.doScan(…)</li><li>ClassPathBeanDefinitionScanner #doscan 通过类加载器以及配置路径，从编译后文件中获取，获取@Component相关类，不满足则过滤，最后返回全部可自动装配类</li></ul></li><li><p>for 处理包扫描结果集 </p><ul><li><p>自动装配相关类都会通过校验，主要关注以下方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationClassUtils </span><br><span class="line">#checkConfigurationClassCandidate()</span><br><span class="line">#isConfigurationCandidate()</span><br></pre></td></tr></table></figure></li><li><p>缓存到元数据读取工厂 metadataReaderFactory</p></li><li><p><strong>processConfigurationClass()</strong> 递归处理</p></li></ul></li></ul><h2 id="配置类处理逻辑"><a href="#配置类处理逻辑" class="headerlink" title="配置类处理逻辑"></a>配置类处理逻辑</h2><ul><li><p><strong>ConfigurationClassParser #processConfigurationClass</strong></p><ul><li>获取配置类缓存 configurationClasses<ul><li>已存在缓存，配置类与 @Imported 有关，则执行完相关逻辑后直接<strong>return</strong></li><li>已存在缓存，配置类与 @Imported 无关，讲配置类从缓存中去除，继续执行重新加载（具体处理原因源码中有注释）</li></ul></li><li><strong>递归处理配置类及其父类 #doProcessConfigurationClass</strong> 有父类则通过方法返回值赋值，递归处理</li><li>配置类放入缓存 configurationClasses</li></ul></li><li><p><strong>ConfigurationClassParser #doProcessConfigurationClass</strong></p><ul><li><p>配置类是否有 @Component ，有则先递归处理内部类 #processMemberClasses</p><ul><li>TODO </li></ul></li><li><p>处理 @PropertySource</p></li><li><p>处理 @ComponentScan 包扫描</p><ul><li><p><strong>ComponentScanAnnotationParser #parse</strong> 包扫描解析，根据ComponentScan注解配置对扫描器进行配置，然后执行扫描 scanner.doScan(…)</p><p><strong>ClassPathBeanDefinitionScanner #doscan =&gt; #findCandidateComponents</strong> 通过类加载器以及配置路径，从编译后文件中获取。</p><p><strong>#isCandidateComponent(MetadataReader metadataReader)</strong> 获取可自动装配类，包括 @Component，具体看方法实现，其中includeFilters包含了@Component</p></li><li><p>for 处理包扫描结果集 </p><ol><li><p> 转换成BeanDefinition</p></li><li><p>校验BeanDefinition，主要关注以下方法，一般自动装配类都会通过校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationClassUtils </span><br><span class="line">#checkConfigurationClassCandidate()</span><br><span class="line">#isConfigurationCandidate()</span><br></pre></td></tr></table></figure></li><li><p>通过校验后解析相应BeanDefinition #parse(String className, String beanName)</p></li><li><p>缓存到元数据读取工厂 metadataReaderFactory</p></li><li><p><strong>processConfigurationClass() 递归处理</strong></p></li></ol></li></ul></li><li><p>处理 @Import</p><ul><li><p>先通过 #getImports() 获取导入配置类，当前类上注解 =&gt; 注解上的注解，递归获取相关注解有过滤逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationClassParser</span></span><br><span class="line">  Predicate&lt;String&gt; DEFAULT_EXCLUSION_FILTER = className -&gt;</span><br><span class="line">  (className.startsWith(<span class="string">&quot;java.lang.annotation.&quot;</span>) || className.startsWith(<span class="string">&quot;org.springframework.stereotype.&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>@import导入的配置类也会加入缓存 metadataReaderFactory</p></li></ul></li><li><p>处理 @ImportResource</p></li><li><p>处理 @Bean</p><ul><li>获取全部 @Bean 相关方法</li><li>当相关方法为复数时，且元数据是由反射生成（original instanceof StandardAnnotationMetadata）。因为反射无需，需要排序</li><li>根据@Bean结果集，给配置类添加 BeanMethod</li></ul></li><li><p>处理接口默认方法</p></li><li><p>处理父类</p><ul><li>knownSuperclasses 缓存已处理过的父类</li><li>有父类就返回父类，外层循环递归处理父类 <strong>return sourceClass.getSuperClass();</strong></li></ul></li><li><p>没有父类返回null，结束递归 <strong>return null;</strong></p></li></ul></li></ul><h1 id="Spring事件"><a href="#Spring事件" class="headerlink" title="Spring事件"></a>Spring事件</h1><ul><li>ApplicationEvent： 抽象事件类，可按需求自定义实现</li><li>ApplicationListener：抽象事件监听接口，其方法<code>onApplicationEvent()</code>是事件被驱动的入口</li><li>ApplicationEventPublisher： 事件发布接口。一般通过<code>ApplicationEventPublisherAware</code>接口注入spring上下文进行发布。因为spring上下文实现了<code>ConfigurableApplicationContext</code>这个聚合接口，事件都是通过上下文进行发布，或者直接使用@Resource自动注入<code>ApplicationEventPublisher</code>的实现类，实际上注入的也是spring的上下文。</li><li>ApplicacationEventMulticaster： 监听器的注册和和事件发布具体执行者，<code>AbstractApplicationContext</code>抽象类中定义好了事件推送的逻辑，这里是事件运转的核心。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整个事件的驱动链路如下：</span><br><span class="line">ApplicationEventPublisher &#x3D;&gt; ApplicationEventMulticaster &#x3D;&gt; ApplicationListener &#x3D;&gt; ApplicationEvent</span><br><span class="line">事件发布后，通过Multicaster广播给相关的监听器，然后监听器通过 onApplicationEvent() 方法执行事件自定义逻辑</span><br><span class="line"></span><br><span class="line">ApplicationEventMulticaster 会被注入到上下文中，上下文refresh中会执行&#96;initApplicationEventMulticaster()&#96;，其中若我们有自定义的SimpleApplicationEventMulticaster，则会优先使用我们自定义的，比如我们可以设置线程池，让事件处理时走异步操作。</span><br></pre></td></tr></table></figure><ul><li>@EventListener：通过bean方法上的注解动态生成listener。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上下文refresh流程中：</span><br><span class="line">registerListeners() 注入所有实现了ApplicationListener接口的类</span><br><span class="line"></span><br><span class="line">finishBeanFactoryInitialization() &#x3D;&gt; beanFactory.preInstantiateSingletons() &#x3D;&gt; smartSingleton.afterSingletonsInstantiated() &#x3D;&gt; EventListenerMethodProcessor.afterSingletonsInstantiated()</span><br><span class="line">这个流程最后触发EventListenerMethodProcessor，给所有bean进行后置处理，扫描@EventListener注解，根据注解修饰的方法生成listener</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring主要加载链路分析&quot;&gt;&lt;a href=&quot;#Spring主要加载链路分析&quot; class=&quot;headerlink&quot; title=&quot;Spring主要加载链路分析&quot;&gt;&lt;/a&gt;Spring主要加载链路分析&lt;/h1&gt;&lt;h2 id=&quot;包扫描&quot;&gt;&lt;a href=&quot;#包扫</summary>
      
    
    
    
    <category term="工作 &amp; 源码" scheme="http://aidianfirst.com/categories/%E5%B7%A5%E4%BD%9C-%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>散装知识点</title>
    <link href="http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E6%95%A3%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E6%95%A3%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2023-07-30T11:20:17.737Z</published>
    <updated>2023-12-08T09:33:27.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OncePerRequestFilter（过滤器Filter）"><a href="#OncePerRequestFilter（过滤器Filter）" class="headerlink" title="OncePerRequestFilter（过滤器Filter）"></a>OncePerRequestFilter（过滤器Filter）</h1><p>Spring针对Servlet原生过滤器Filter的进一步封装。通过继承OncePerRequestFilter，可以自定义一个过滤器，且每个请求都会执行一次。关于重写方法，<code>init</code>、<code>doFilter</code>作为默认实现，有final修饰，我们想进行扩展，需要重写<code>initFilterBean</code>、<code>doFilterInternal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写doFilterInternal进行业务扩展，别忘了最后进行过滤链调用</span></span><br><span class="line">filterChain.doFilter(request, response);</span><br></pre></td></tr></table></figure><h1 id="HandlerInterceptorAdapter（拦截器Interceptor）"><a href="#HandlerInterceptorAdapter（拦截器Interceptor）" class="headerlink" title="HandlerInterceptorAdapter（拦截器Interceptor）"></a>HandlerInterceptorAdapter（拦截器Interceptor）</h1><p>HandlerInterceptorAdapter是Spring提供的一种拦截器适配器，通过继承该抽象类自定义拦截器。</p><p>主要实现三个接口：<code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">preHandle：前置处理，Controller执行前</span><br><span class="line">postHandle：后置处理，Controller执行完成，可以根据方法参数modelAndView操作渲染视图</span><br><span class="line">afterCompletion：请求回调完毕，可进行资源释放，比如处理Filter中set的ThreadLocal</span><br></pre></td></tr></table></figure><p>自定义配置类，将拦截器加入调用链路，实现WebMvcConfigurer或WebMvcConfigurationSupport进行实现</p><p>WebMvcConfigurer可以进行多实现，WebMvcConfigurationSupport多实现会产生冲突</p><p><a href="https://zhuanlan.zhihu.com/p/344541013">自定义SpringBoot默认MVC配置？好几个坑，避一避 - 知乎 (zhihu.com)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebMvcAutoConfiguration WebMvcConfigurationSupport默认实现DelegatingWebMvcConfiguration，Delegating会把所有WebMvcConfigurer的实现进行遍历，然后加入配置。</span><br><span class="line">自己实现会覆盖DelegatingWebMvcConfiguration的操作，导致WebMvcConfigurer的实现被忽略</span><br><span class="line"></span><br><span class="line">有个疑问，为什么DelegatingWebMvcConfiguration 这个实现类一定晚于WebMvcAutoConfiguration 被注入，它不是也被@configuration修饰了吗。也就DelegatingWebMvcConfiguration 和我们自己的实现类在注入时先后顺序到底有何差异，为什么spring能保证WebMvcAutoConfiguration 注入时WebMvcAutoConfiguration 一定没有被注入</span><br></pre></td></tr></table></figure><h1 id="RequestContextHolders"><a href="#RequestContextHolders" class="headerlink" title="RequestContextHolders"></a>RequestContextHolders</h1><p>可随时获取请求与响应，不用controller层往下传。</p><p>可自行封装http工具类，eg：<a href="https://www.jianshu.com/p/83a872d8db92">https://www.jianshu.com/p/83a872d8db92</a></p><h1 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h1><p>分布式日志？</p><h1 id="TransmittableThreadLocal（解决异步上下文传递问题）"><a href="#TransmittableThreadLocal（解决异步上下文传递问题）" class="headerlink" title="TransmittableThreadLocal（解决异步上下文传递问题）"></a>TransmittableThreadLocal（解决异步上下文传递问题）</h1><h1 id="AOP动态代理，this引用不代理则失效"><a href="#AOP动态代理，this引用不代理则失效" class="headerlink" title="AOP动态代理，this引用不代理则失效"></a>AOP动态代理，this引用不代理则失效</h1><h1 id="SmartInitializingSingleton-（后置处理解决循环依赖）"><a href="#SmartInitializingSingleton-（后置处理解决循环依赖）" class="headerlink" title="SmartInitializingSingleton （后置处理解决循环依赖）"></a>SmartInitializingSingleton （后置处理解决循环依赖）</h1><h1 id="HandlerMethodArgumentResolver-（自定义接收前端传参实现）"><a href="#HandlerMethodArgumentResolver-（自定义接收前端传参实现）" class="headerlink" title="HandlerMethodArgumentResolver （自定义接收前端传参实现）"></a>HandlerMethodArgumentResolver （自定义接收前端传参实现）</h1><p><a href="https://blog.csdn.net/dear_little_bear/article/details/104565425">https://blog.csdn.net/dear_little_bear/article/details/104565425</a></p><h2 id="WebDataBinder-参数转换"><a href="#WebDataBinder-参数转换" class="headerlink" title="WebDataBinder 参数转换"></a>WebDataBinder 参数转换</h2><h2 id="WebMvcConfigurer"><a href="#WebMvcConfigurer" class="headerlink" title="WebMvcConfigurer"></a>WebMvcConfigurer</h2><h1 id="AliasFor（别名，封装注解）"><a href="#AliasFor（别名，封装注解）" class="headerlink" title="@AliasFor（别名，封装注解）"></a>@AliasFor（别名，封装注解）</h1><h1 id="EventListener-spring事件监听机制"><a href="#EventListener-spring事件监听机制" class="headerlink" title="@EventListener spring事件监听机制"></a>@EventListener spring事件监听机制</h1><h1 id="Import-实现配置链式加载"><a href="#Import-实现配置链式加载" class="headerlink" title="@Import 实现配置链式加载"></a>@Import 实现配置链式加载</h1><p>配置链式加载，多个配置类链式引用，第一个被注入后，后面配置进行链式加载</p><h2 id="Controller层接口定义为什么必须是public"><a href="#Controller层接口定义为什么必须是public" class="headerlink" title="Controller层接口定义为什么必须是public"></a>Controller层接口定义为什么必须是public</h2><p>接口调用servlet初始化是代理对象，public在后续调用链上会走aop代理增强，注入容器管理的类，private方法则不会。所以private方法被调用时用的是代理对象，代理对象是中自动注入的属性都是null，引发空指针。</p><h1 id="Querydsl-for-JPA"><a href="#Querydsl-for-JPA" class="headerlink" title="Querydsl for JPA"></a>Querydsl for JPA</h1><p><a href="http://querydsl.com/static/querydsl/latest/reference/html/ch02.html">http://querydsl.com/static/querydsl/latest/reference/html/ch02.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@LastModifiedBy</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">上述注解组合可以自动更新修改人，使用querydsl更新数据是否也会自动更新？</span><br></pre></td></tr></table></figure><h1 id="自定义starter，如何自动装配"><a href="#自定义starter，如何自动装配" class="headerlink" title="自定义starter，如何自动装配"></a>自定义starter，如何自动装配</h1><p><a href="https://juejin.cn/post/6918283737771966477">SpringBoot自定义日志Starter，可动态拔插配置 - 掘金 (juejin.cn)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">starter中配置统一用一个配置类集中注入</span><br><span class="line"></span><br><span class="line">显示注入：自定义@EnableXXX注解，@import 导入 ImportSelector实现类，实现类selectImports返回需要装配的配置类。最后启用注解即可功能生效</span><br><span class="line"></span><br><span class="line">隐式注入：resources -&gt; META-INF -&gt; spring.factories，</span><br><span class="line">其中配置org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\ 转行写自己的配置类</span><br><span class="line"></span><br><span class="line">这两种实现都可以看spring官方的starter进行学习。都有运用</span><br></pre></td></tr></table></figure><h1 id="UriComponentsBuilder"><a href="#UriComponentsBuilder" class="headerlink" title="UriComponentsBuilder"></a>UriComponentsBuilder</h1><p><a href="https://www.baeldung.com/spring-uricomponentsbuilder">https://www.baeldung.com/spring-uricomponentsbuilder</a></p><h1 id="位图BitMap"><a href="#位图BitMap" class="headerlink" title="位图BitMap"></a>位图BitMap</h1><p>二进制位代表多种类型组合，存储int型即可</p><p>例如业务产品涉及类型A B C D E。10101，00011，01010 则对应ACE、DE、BD这三种组合。存储值对应21、3、10</p><p>基础适用场景，多组合优惠卷、多固定标签、签到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OncePerRequestFilter（过滤器Filter）&quot;&gt;&lt;a href=&quot;#OncePerRequestFilter（过滤器Filter）&quot; class=&quot;headerlink&quot; title=&quot;OncePerRequestFilter（过滤器Filter</summary>
      
    
    
    
    <category term="工作 &amp; 源码" scheme="http://aidianfirst.com/categories/%E5%B7%A5%E4%BD%9C-%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Controller接口调用链路浅析</title>
    <link href="http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Controller%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%B5%85%E6%9E%90/"/>
    <id>http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Controller%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%B5%85%E6%9E%90/</id>
    <published>2023-07-30T11:20:17.736Z</published>
    <updated>2023-07-30T11:20:17.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Controller接口调用链路浅析"><a href="#Controller接口调用链路浅析" class="headerlink" title="Controller接口调用链路浅析"></a>Controller接口调用链路浅析</h1><h2 id="项目初始化，创建代理类"><a href="#项目初始化，创建代理类" class="headerlink" title="项目初始化，创建代理类"></a>项目初始化，创建代理类</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractClassGenerator#generate() 358:&#123;strategy.generate(this)&#125; -&gt;</span><br><span class="line">DefaultGeneratorStrategy#generate() 25:&#123;transform(cg).generateClass(cw)&#125; -&gt;</span><br><span class="line">Enhancer#generateClass() 670:&#123;getMethods(...)&#125; -&gt;</span><br><span class="line">Enhancer#generateClass() 651:&#123;CollectionUtils.filter(methods, new VisibilityPredicate(superclass, true));&#125; -&gt;</span><br><span class="line">AbstractClassGenerator#generate() 363:&#123;gen = ReflectUtils.defineClass(...)&#125;</span><br></pre></td></tr></table></figure><p>主要是在<code>AbstractClassGenerator</code>这个类完成代理类的生成，其中调用了cglib相关逻辑过滤原生类的方法， <code>DefaultGeneratorStrategy</code>、<code>CollectionUtils</code>需要导入cglib源码进行查看，而private方法则被<code>VisibilityPredicate</code>这个策略过滤了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VisibilityPredicate 过滤方法 很明显private方法false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">    Member member = (Member)arg;</span><br><span class="line">    <span class="keyword">int</span> mod = member.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (Modifier.isPrivate(mod)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Modifier.isPublic(mod)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Modifier.isProtected(mod) &amp;&amp; protectedOk) &#123;</span><br><span class="line">        <span class="comment">// protected is fine if &#x27;protectedOk&#x27; is true (for subclasses)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// protected/package private if the member is in the same package as the source class </span></span><br><span class="line">        <span class="comment">// and we are generating into the same classloader.</span></span><br><span class="line">        <span class="keyword">return</span> samePackageOk </span><br><span class="line">            &amp;&amp; pkg.equals(TypeUtils.getPackageName(Type.getType(member.getDeclaringClass())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同一个代理类生成流程会被多次触发，这个原因还未深究，不知道出于什么目的，可以标记一下这个问题点。</strong></p><h2 id="tomcat开启线程，走到过滤器链之前的一个定向逻辑链路调用"><a href="#tomcat开启线程，走到过滤器链之前的一个定向逻辑链路调用" class="headerlink" title="tomcat开启线程，走到过滤器链之前的一个定向逻辑链路调用"></a>tomcat开启线程，走到过滤器链之前的一个定向逻辑链路调用</h2><p>tomcat这部分调用链绕弯很多，我没有细看这部分的映射逻辑，和我们的问题核心也没有太大关系，有兴趣可以看看，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)</span><br><span class="line">at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)</span><br><span class="line">at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)</span><br><span class="line">at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)</span><br><span class="line">at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)</span><br><span class="line">at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)</span><br></pre></td></tr></table></figure><h2 id="过滤器链路"><a href="#过滤器链路" class="headerlink" title="过滤器链路"></a>过滤器链路</h2><p>过滤器链路是在项目启动时提前扫描好注入上下文中的，servlet原生过滤链，<code>ApplicationFilterChain</code>，以下是主要调用链的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ApplicationFilterChain#doFilter() 调用链路 -&gt;</span><br><span class="line">ApplicationFilterChain#internalDoFilter() 193 索引移动,调用过滤器 -&gt; </span><br><span class="line">Filter#doFilter() 相应过滤器逻辑 -&gt;</span><br><span class="line">chain.doFilter(request, response) 过滤器完成后继续调用链路 -&gt;</span><br><span class="line">重复上述动作直至遍历完链路 ApplicationFilterChain#internalDoFilter() 231 servlet.service(request, response) -&gt;</span><br><span class="line">开始servlet调用接口...</span><br></pre></td></tr></table></figure><p>完成上述tomcat的定向逻辑调用后就会开启过滤器链路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StandardWrapperValve#invoke() 174</span><br><span class="line">ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br></pre></td></tr></table></figure><h2 id="调用controller接口"><a href="#调用controller接口" class="headerlink" title="调用controller接口"></a>调用controller接口</h2><p>过滤器链路走完后，继续servlet请求处理，执行doService、doDispatch相关操作。然后便是调用接口方法，这里将针对方法属性进行是否代理类拦截增强操作。我们先生成代理类。</p><h3 id="Method-invoke"><a href="#Method-invoke" class="headerlink" title="Method invoke"></a>Method invoke</h3><p>c源码下载：<a href="https://hg.openjdk.org/jdk8u%EF%BC%8C%E6%83%B3%E7%9C%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%BA%90%E7%A0%81%E7%82%B9%E5%87%BBhotspot%EF%BC%8C%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E5%90%8E%E7%82%B9%E5%87%BB%E5%B7%A6%E4%BE%A7%E6%A0%8Fzip%E3%80%81gc%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%8C%85%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81jdk%E5%92%8Chotspot%E7%9A%84%E6%BA%90%E7%A0%81%E3%80%82">https://hg.openjdk.org/jdk8u，想看虚拟机源码点击hotspot，加载页面后点击左侧栏zip、gc下载源码压缩包，我们需要jdk和hotspot的源码。</a></p><p>我们知道源码都是使用反射进行动态代理的，这一步骤就是调用<code>Method#invoke()</code>方法，一层层往下看，最终调用的native方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NativeMethodAccessorImpl.class</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure><p>jdk源码进一步调用jvm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jdk<span class="number">-7f</span>cf35286d52\src\share\native\sun\reflect\NativeAccessors.c</span><br><span class="line"></span><br><span class="line">JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0</span><br><span class="line">(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> JVM_InvokeMethod(env, m, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键反射调用 Reflection::invoke_method</p><p><strong>实力有限，这块c源码确实啃不动，单纯抛砖引玉一下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hotspot<span class="number">-69087</span>d08d473\src\share\vm\prims\jvm.cpp</span><br><span class="line"></span><br><span class="line">JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_InvokeMethod&quot;</span>);</span><br><span class="line">  Handle method_handle;</span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) &#123;</span><br><span class="line">    method_handle = Handle(THREAD, JNIHandles::resolve(method));</span><br><span class="line">    <span class="function">Handle <span class="title">receiver</span><span class="params">(THREAD, JNIHandles::resolve(obj))</span></span>;</span><br><span class="line">    <span class="function">objArrayHandle <span class="title">args</span><span class="params">(THREAD, objArrayOop(JNIHandles::resolve(args0)))</span></span>;</span><br><span class="line">    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);</span><br><span class="line">    jobject res = JNIHandles::make_local(env, result);</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::should_post_vm_object_alloc()) &#123;</span><br><span class="line">      oop ret_type = java_lang_reflect_Method::return_type(method_handle());</span><br><span class="line">      assert(ret_type != <span class="literal">NULL</span>, <span class="string">&quot;sanity check: ret_type oop must not be NULL!&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (java_lang_Class::is_primitive(ret_type)) &#123;</span><br><span class="line">        <span class="comment">// Only for primitive type vm allocates memory for java object.</span></span><br><span class="line">        <span class="comment">// See box() method.</span></span><br><span class="line">        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_StackOverflowError());</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oop <span class="title">Reflection::invoke_method</span><span class="params">(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS)</span> </span>&#123;</span><br><span class="line">  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);</span><br><span class="line">  <span class="keyword">int</span> slot               = java_lang_reflect_Method::slot(method_mirror);</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">override</span>          = java_lang_reflect_Method::<span class="keyword">override</span>(method_mirror) != <span class="number">0</span>;</span><br><span class="line">  <span class="function">objArrayHandle <span class="title">ptypes</span><span class="params">(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)))</span></span>;</span><br><span class="line"></span><br><span class="line">  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);</span><br><span class="line">  BasicType rtype;</span><br><span class="line">  <span class="keyword">if</span> (java_lang_Class::is_primitive(return_type_mirror)) &#123;</span><br><span class="line">    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rtype = T_OBJECT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">instanceKlassHandle <span class="title">klass</span><span class="params">(THREAD, java_lang_Class::as_Klass(mirror))</span></span>;</span><br><span class="line">  Method* m = klass-&gt;method_with_idnum(slot);</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    THROW_MSG_0(vmSymbols::java_lang_InternalError(), <span class="string">&quot;invoke&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">methodHandle <span class="title">method</span><span class="params">(THREAD, m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> invoke(klass, method, receiver, <span class="keyword">override</span>, ptypes, rtype, args, <span class="literal">true</span>, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成cglib代理类"><a href="#生成cglib代理类" class="headerlink" title="生成cglib代理类"></a>生成cglib代理类</h3><p>使用<code>System.setPropert()</code>定义输出路径，将 YOUR_CLASS 替换成你生成代理类的原生类，最后调用一下类方法，在对应路径下找到生成的代理类。</p><p>当然生成后的是class文件，需要反编译源码，可以使用jd-gui：<a href="https://github.com/java-decompiler/jd-gui/releases">https://github.com/java-decompiler/jd-gui/releases</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;D:\\class&quot;</span>);</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(YOUR_CLASS.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">        YOUR_CLASS <span class="class"><span class="keyword">class</span> </span>= (YOUR_CLASS) enhancer.create();</span><br><span class="line">        class.function();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理类过滤链路"><a href="#代理类过滤链路" class="headerlink" title="代理类过滤链路"></a>代理类过滤链路</h3><ul><li>代理类调用前都是通过<code>Enhancer</code>设置基类和回调，对应上文中的<code>enhancer.setSuperclass()</code>、<code>enhancer.setCallback()</code>，回调类实现cglib的扩展接口，也就是实现<code>intercept()</code></li><li>外部调用cglib的<code>invoke()</code>通过两个fastclass相关的映射类去调用代理类的方法</li><li>代理方法，通过判断是否还有拦截增强器，进行增强或走原生方法，代理类的基类是我们的原生方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***$$FastClassByCGLIB$$***</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> paramInt, Object paramObject, Object[] paramArrayOfObject)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (paramInt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> ((OhbController)paramObject).add((Ohb)paramArrayOfObject[<span class="number">0</span>]);</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> () &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ***$$EnhancerByCGLIB$$***$$FastClassByCGLIB$$***</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> paramInt, Object paramObject, Object[] paramArrayOfObject)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (paramInt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> ((OhbController$$EnhancerByCGLIB$$a5ddc9c3)paramObject).add((Ohb)paramArrayOfObject[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> () &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ***$$EnhancerByCGLIB$$***          </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">add</span><span class="params">(Ohb paramOhb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 != <span class="keyword">null</span>) </span><br><span class="line">        ? <span class="keyword">this</span>.CGLIB$CALLBACK_0.intercept(<span class="keyword">this</span>, CGLIB$add$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[] &#123; paramOhb &#125;, CGLIB$add$<span class="number">0</span>$Proxy) </span><br><span class="line">        : <span class="keyword">super</span>.add(paramOhb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h2><p>初始化生成抽象类的时候，就把private方法排除了。</p><p>现在问题点是invoke0方法执行的时候是个什么调用逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure><p>debug结果是，obj是代理对象，而代理对象中不存在已被过滤的方法，不能被调用链路增强，直接反射调用了方法，此时的类相当于是反射映射的，非spring管理。</p><p>而public可以在增强链路中，可以被增强，通过增强链路调用了容器中bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- cglib源码</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="invoke0"><a href="#invoke0" class="headerlink" title="invoke0"></a>invoke0</h2><p>调用代理类方法，能调用到就调用，private方法调用不到就直接映射到父类了，这个是猜测，需要验证。</p><p>多个代理，EnhancerBySpringCGLIB、FastClassBySpringCGLIB，存在映射关系，intercept走aop链</p><p>看源码，如果没有设置Enhancer callback，则直接调用父类原方法</p><p>所以private没有的方法转发是在invoke0字节码中被发射处理了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Controller接口调用链路浅析&quot;&gt;&lt;a href=&quot;#Controller接口调用链路浅析&quot; class=&quot;headerlink&quot; title=&quot;Controller接口调用链路浅析&quot;&gt;&lt;/a&gt;Controller接口调用链路浅析&lt;/h1&gt;&lt;h2 id=&quot;项</summary>
      
    
    
    
    <category term="工作 &amp; 源码" scheme="http://aidianfirst.com/categories/%E5%B7%A5%E4%BD%9C-%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Spel字段解析功能源码浅析</title>
    <link href="http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spel%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81/"/>
    <id>http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spel%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81/</id>
    <published>2023-07-30T11:20:17.736Z</published>
    <updated>2023-07-30T11:20:17.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近在写日志功能，aop + 注解 + spel，使用 @RestControllerAdvice 全局捕获到的Exception的异常信息肯定是需要打印的，于是我想当然获取自定义信息的spel表达式是 e.getDetailMessage，detailMessage异常信息字段是异常继承于Throwable的，然后运行代码spel解析出现异常，网上搜一圈无果，只好自己debug看源码，找找原因了。</p><h1 id="Debuging"><a href="#Debuging" class="headerlink" title="Debuging"></a>Debuging</h1><p>题外话，学会debug技巧应该是我们初级后端进阶的第一步，学会debug才好看源码，Evaluate Expression 执行表达式，断点设置条件以及是否线程，这两个小技巧掌握好就可以看源码了。</p><h2 id="readProperty"><a href="#readProperty" class="headerlink" title="readProperty"></a>readProperty</h2><p>debug步进直到spel判断核心</p><p>org.springframework.expression.spel.ast.Indexer#readProperty 关键代码节选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (PropertyAccessor accessor : accessorsToTry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (accessor.canRead(evalContext, contextObject.getValue(), name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (accessor <span class="keyword">instanceof</span> ReflectivePropertyAccessor) &#123;</span><br><span class="line">            accessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(</span><br><span class="line">                evalContext, contextObject.getValue(), name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.cachedReadAccessor = accessor;</span><br><span class="line">        <span class="keyword">return</span> accessor.read(evalContext, contextObject.getValue(), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canRead这个方法是校验的关键，这里如果校验不通过就不会返回结果，再往后走都是抛异常了，我们进canRead看看</p><h2 id="canRead"><a href="#canRead" class="headerlink" title="canRead"></a>canRead</h2><p>PropertyAccessor.canRead的具体实现如下</p><p>org.springframework.expression.spel.support.<strong>ReflectivePropertyAccessor</strong>#canRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(EvaluationContext context, <span class="meta">@Nullable</span> Object target, String name)</span> <span class="keyword">throws</span> AccessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; type = (target <span class="keyword">instanceof</span> Class ? (Class&lt;?&gt;) target : target.getClass());</span><br><span class="line">    <span class="keyword">if</span> (type.isArray() &amp;&amp; name.equals(<span class="string">&quot;length&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PropertyCacheKey cacheKey = <span class="keyword">new</span> PropertyCacheKey(type, name, target <span class="keyword">instanceof</span> Class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.readerCache.containsKey(cacheKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method method = findGetterForProperty(name, type, target);</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Property property = <span class="keyword">new</span> Property(type, method, <span class="keyword">null</span>);</span><br><span class="line">        TypeDescriptor typeDescriptor = <span class="keyword">new</span> TypeDescriptor(property);</span><br><span class="line">        method = ClassUtils.getInterfaceMethodIfPossible(method);</span><br><span class="line">        <span class="keyword">this</span>.readerCache.put(cacheKey, <span class="keyword">new</span> InvokerPair(method, typeDescriptor));</span><br><span class="line">        <span class="keyword">this</span>.typeDescriptorCache.put(cacheKey, typeDescriptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Field field = findField(name, type, target);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TypeDescriptor typeDescriptor = <span class="keyword">new</span> TypeDescriptor(field);</span><br><span class="line">            <span class="keyword">this</span>.readerCache.put(cacheKey, <span class="keyword">new</span> InvokerPair(field, typeDescriptor));</span><br><span class="line">            <span class="keyword">this</span>.typeDescriptorCache.put(cacheKey, typeDescriptor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>canRead的主要逻辑</p><ul><li>判断是否为数组，表达式是length则可执行</li><li>缓存中有，可执行</li><li>findGetterForProperty 找方法</li><li>找不到方法 findField 找字段</li></ul><p>我们先看Method，通过 findGetterForProperty 是怎么找的</p></li><li><p><strong>findGetterForProperty</strong> 在canRead这个类里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Method <span class="title">findGetterForProperty</span><span class="params">(String propertyName, Class&lt;?&gt; clazz, <span class="keyword">boolean</span> mustBeStatic)</span> </span>&#123;</span><br><span class="line">    Method method = findMethodForProperty(getPropertyMethodSuffixes(propertyName),</span><br><span class="line">                                          <span class="string">&quot;get&quot;</span>, clazz, mustBeStatic, <span class="number">0</span>, ANY_TYPES);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        method = findMethodForProperty(getPropertyMethodSuffixes(propertyName),</span><br><span class="line">                                       <span class="string">&quot;is&quot;</span>, clazz, mustBeStatic, <span class="number">0</span>, BOOLEAN_TYPES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用看到最底下，里面的实现是一堆校验找方法，最主要的判断逻辑是将 get 或 is 作为前缀，表达式字段作为后缀进行拼接，然后在目标类里面查找是否有相关的方法。</p><p>找完方法后继续canRead里的逻辑，如果方法不为空，说明有可拼接的 get、is方法，可以继续走 readProperty 的流程。</p><p>如果方法为空，则没有对应的get方法，去 findField 找字段。</p></li><li><p><strong>findField</strong> 在canRead这个类里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Field <span class="title">findField</span><span class="params">(String name, Class&lt;?&gt; clazz, <span class="keyword">boolean</span> mustBeStatic)</span> </span>&#123;</span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(name) &amp;&amp; (!mustBeStatic || Modifier.isStatic(field.getModifiers()))) &#123;</span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Field field = findField(name, clazz.getSuperclass(), mustBeStatic);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; implementedInterface : clazz.getInterfaces()) &#123;</span><br><span class="line">        Field field = findField(name, implementedInterface, mustBeStatic);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看第一行，发现这里只获取了公共字段，使用 getDeclaredFields() 才可以获取私有字段。</p><p>获取公共字段后与表达式进行匹配，然后进行静态校验，相同则返回。</p><p>公共字段找不到则获取父类，递归查找。</p><p>递归完仍然查不到，则去实现的接口，也会递归。</p><p><strong>这里我有个点没想明白，getFields获取全部公共字段包括父类、接口，所以为什么还要继续递归？大胆质疑源码！！！</strong></p></li></ul><h2 id="createOptimalAccessor"><a href="#createOptimalAccessor" class="headerlink" title="createOptimalAccessor"></a>createOptimalAccessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ReflectivePropertyAccessor) accessor).createOptimalAccessor();</span><br></pre></td></tr></table></figure><p>readProperty 在通过 canRead 校验后，如果继承 ReflectivePropertyAccessor，则会用做一些缓存操作，且调用OptimalPropertyAccessor构造器，缓存 <strong>member</strong> 的值</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>如果通过了canRead的校验，readProperty方法会先进行缓存，然后调用read返回值。</p><p>ReflectivePropertyAccessor.OptimalPropertyAccessor#read</p><p>我debug是走了内部类的read方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TypedValue <span class="title">read</span><span class="params">(EvaluationContext context, <span class="meta">@Nullable</span> Object target, String name)</span> <span class="keyword">throws</span> AccessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.member <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">        Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            Object value = method.invoke(target);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypedValue(value, <span class="keyword">this</span>.typeDescriptor.narrow(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AccessException(<span class="string">&quot;Unable to access property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; through getter method&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(field);</span><br><span class="line">            Object value = field.get(target);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypedValue(value, <span class="keyword">this</span>.typeDescriptor.narrow(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AccessException(<span class="string">&quot;Unable to access field &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 member 会使用 createOptimalAccessor 缓存好的值，通过代理 invoke 方法走对应类的方法获取值，或者直接去获取字段的值。</p><h1 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h1><p>源码分析后，在回来看问题的起因，我想获取异常信息 Throwable：detailMessage，我表达式写的是e.getDetailMessage，按照刚刚的分析走到 <strong>findGetterForProperty</strong> 会去查找字段对应的get、is方法，但是异常里面获取信息的方法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String getMessage() &#123;return detailMessage;&#125;</span><br></pre></td></tr></table></figure><p>并不是 getDetailMessage，所以方法查找不到，而detailMessage又是私有字段，所以 <strong>findField</strong> 也找不到字段，最后就拿不到我们想要的值，出现解析异常。</p><p><strong>解决办法就是将表达式写成 e.message，走getMessage方法获取 detailMessage 字段的值。</strong></p><p>我上面分析的都是针对字段表达式，如果写的是方法表达式，getMessage()，带括号的这种，spel调用的时候就需要换一种写法，给表达式指定rootObject，而且表达式的解析路径也不一样了，那么源码就是另外一种解析路径了，下次这里有坑我再去看吧😂</p><h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>在看 <strong>findFields</strong> 对字段校验时，有个地方吸引到我了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modifier.isStatic(field.getModifiers())</span><br></pre></td></tr></table></figure><p>字面意思可以看出来，是在判断字段是否静态变量，点进源码看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATIC           = <span class="number">0x00000008</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">(<span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mod &amp; STATIC) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是在做位运算，用 field.getModifiers() 的值和 STATIC，STATIC表示十六进制数：8。</p><p>看到这想起之前刷算法遇到位运算的题，就想看看jdk是怎么联动的，通过位运算判断静态变量。</p><p>网上搜了下 field.getModifiers() 这个方法是获取字段前面修饰符的值，jdk底层把每个修饰符按十六进制数进行定义了，通过这个方法可以得到修饰符之和。以下列举部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC           = <span class="number">0x00000001</span>; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE          = <span class="number">0x00000002</span>;<span class="comment">//2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROTECTED        = <span class="number">0x00000004</span>;<span class="comment">//4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATIC           = <span class="number">0x00000008</span>;<span class="comment">//8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINAL            = <span class="number">0x00000010</span>;<span class="comment">//16</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNCHRONIZED     = <span class="number">0x00000020</span>;<span class="comment">//32</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VOLATILE         = <span class="number">0x00000040</span>;<span class="comment">//64</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIENT        = <span class="number">0x00000080</span>;<span class="comment">//8*16</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NATIVE           = <span class="number">0x00000100</span>;<span class="comment">//16*16</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERFACE        = <span class="number">0x00000200</span>;<span class="comment">//32*16</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ABSTRACT         = <span class="number">0x00000400</span>;<span class="comment">//64*16</span></span><br></pre></td></tr></table></figure><p>那么就很清晰了，获取字段修饰符之和，然后在和 STATIC：8 进行按位与计算，按照位运算，如果修饰符之和没有STATIC：8，得到的结果一定是0，不为0则说明组合的修饰符包含 static。同理其他修饰符都可以使用 Modifier 类中的方法进行位运算判断。</p><p>ps：如果不明白就去复习一下位运算吧，按位与&amp;，每位计算的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &amp; 0 | 0 &amp; 1 | 1 &amp; 0 &#x3D; 0</span><br><span class="line">1 &amp; 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p>只有同位都为1，按位与才等于1，所以当前位不为1说明修饰符之和不包含要判断的修饰符。</p><h1 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h1><p><a href="https://gitee.com/link?target=https://www.bilibili.com/video/BV1R24y1W7DY/?spm_id_from=333.999.0.0&vd_source=77c5fa1cb2cbdaccec0dbbcfa038a8e7">https://www.bilibili.com/video/BV1R24y1W7DY/?spm_id_from=333.999.0.0&amp;vd_source=77c5fa1cb2cbdaccec0dbbcfa038a8e7</a></p><p>最近看到1v5大佬分享的内容讲到了Spel，刚好自己写日志的时候有过了解，看完视频后对Spel这一块内容认知更全面了，主要是从三个层面进行理解，解析器、表达式、上下文。</p><p>Spel关联链路：使用解析器转换输入字符串内容，得到需要的表达式类型，然后设置上下文内容，最后根据表达式在上下文中获取参数对应的值。这是Spel技术实现的三个顶层抽象，从这三个层面进行展开，我们再去看实现类之间的关系，确实更加清晰了。非常推荐看到这里的朋友去看看上方链接的视频。此次讲解Spel也让我对源码阅读有了新的思路，看顶层抽象，入手设计层面上的基础关联关系。</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/46.png" alt="46.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;最近在写日志功能，aop + 注解 + spel，使用 @RestControllerAdvice 全局捕获到的Exception的异常信息</summary>
      
    
    
    
    <category term="工作 &amp; 源码" scheme="http://aidianfirst.com/categories/%E5%B7%A5%E4%BD%9C-%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>并发编程实战阅读学习</title>
    <link href="http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aidianfirst.com/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-30T11:20:17.736Z</published>
    <updated>2023-07-30T11:20:17.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h1><p>通常我们无法确保执行读操作的线程能适时的看到其他写线程写入的值，为了确保多线程间对内存写入操作的可见性，必须使用同步机制。</p><h2 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h2><p>AB线程获取同一个锁，可以保证A中改变的变量，等到B获取锁后仍可以看见。</p><p>B线程执行由锁保护的同步代码块时，可以看见A线程之前在同一个同步代码块中的所有操作结果。</p><p>可见性即公共变量的可视性、一致性，同步保证并发下不同线程数据变量一致。对于变量来说，锁机制同步是为了确保某个线程写入改变量的值，对于其他线程来说是可见的。</p><p>加锁的意义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程可以看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Java提供一种稍弱的同步机制，volatile关键字，用于确保将变量的更新操作通知到其他线程。</p><p>当变量声明为volatile后，编译器和运行时都会注意到该变量是共享的，因此不会将变量上的操作与其他内存操作一起重排序，volatile变量不会被缓存在寄存器或其他处理器不可见的地方，因此在读取volatile变量时总能得到最新写入的值。</p><p>volatile不会执行加锁操作，因此也不会使线程阻塞，volatile是一种比synchronized更轻量级的同步机制。</p><p>volatile也有一些不足，它不足以确保 i++ 这类操作的原子性，除非只有一个线程对变量执行写操作。</p><p>synchronized此类的加锁机制：原子性 + 可见性，volatile：可见性。</p><p><strong>volatile主要作用是可见性 + 防重排，无加锁动作，不会阻塞线程，但是不能保证原子性。</strong></p><h1 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h1><h2 id="中断-interrpt-停止线程"><a href="#中断-interrpt-停止线程" class="headerlink" title="中断 interrpt 停止线程"></a>中断 interrpt 停止线程</h2><p>java中断没有实质操作，一般是提供一个中断标识，程序根据标识进行处理，例如 wait、sleep 操作，底层会自动感知标识位抛出 InterruptedException 异常。</p><p>每个线程都有一个 boolean 类型的中断状态，中断操作会将此标识设置为 true，所以要真正中断一个运行中的线程，需要先触发中断修改状态，然后自行感知状态执行中断逻辑。</p><p>Thread 类提供一些相关方法：</p><ul><li>interrupt()：修改目标线程（连续多次中断，标识会一直为false，原因未知）</li><li>isInterrupted()：感知线程中断标识</li><li>interrupted()：清除中断标识位</li></ul><h2 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h2><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>通过 <code>Runtime.getRuntime.addShutDownHook()</code> 注册钩子，JVM在关闭时会去调用钩子代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;钩子&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是看到了钩子 Hook 这个概念想提一下，Spring中提供了一些扩展点就是钩子，例如获取上下文会实现接口 ApplicationContextAware，我们可以获取上下文并进行相应扩展，需要对这个概念有一个认知。</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>JVM关闭场景很多，普通的正常关闭方式是在最后一个普通线程（非守护）结束时被触发。程序中线程非为普通和守护，JVM启动时创建的所有线程中，除主线程外都是守护线程（如gc线程），当一个线程A创建新线程B时，B会继承创建者A的线程守护状态，默认情况下，程序中由主线程创建的全部都是普通线程。</p><p>普通、守护二者差异仅存在于线程退出时发生的操作，当一个线程退出时，JVM会检查其他正在运行的线程，若这些线程都是守护线程，则JVM会正常退出。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h2><p>线程池过大，会创建大量线程，在CPU和内存资源上进行竞争，加大了内存使用量。</p><p>线程池过小，无法合理运用空闲的处理器，降低系统的吞吐率。</p><ul><li>计算密集任务：CPU数 + 1 可达到较好的利用率</li><li>IO密集任务 或 阻塞操作的任务：线程池规模更大，网传 2*CPU数</li><li>线程池精确计算公式：<code>CPU数 * CPU利用率 * (1 + 任务等待时间/任务计算时间)</code></li></ul><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程池扭转过程：核心线程 -&gt; 阻塞队列 -&gt; 最大线程 -&gt; 拒绝策略</span><br></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列基本的三种实现：</p><ul><li><strong>无界队列：</strong>任务无限积累知道上限</li><li><strong>有界队列：</strong>有利于避免资源耗尽，<strong>使用有界队列，其大小应与线程池大小一起调节</strong></li><li><strong>同步移交：</strong>SynchronousQueue 可避免任务排队，直接将任务移交给工作线程，可以说不是队列而是一种线程间进行移交的机制，若元素放入该队列，没有线程等待任务，则会走后续最大线程、拒绝策略的逻辑，它不会进行存储任务。在无界线程池和可拒绝任务的场景下，它才有价值</li></ul><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ul><li><strong>AbortPolicy：</strong>默认拒绝策略，会抛出 RejectedExecutionException ，我们可以捕获这个异常，执行自定义逻辑</li><li><strong>DiscardPolicy：</strong>直接丢弃当前任务</li><li><strong>DiscardOldestPolicy：</strong>丢弃下一个将要被执行的任务，FIFO 下一个要执行的就是最早入队列的任务，然后尝试重新提交新任务（不易和优先队列一起使用，因为被抛弃的是优先级最高的任务）</li><li><strong>CallerRunsPolicy：</strong>让调用了 execute 的线程执行任务</li><li>通过实现RejectedExecutionHandler进行自定义扩展</li></ul><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(...) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.terminated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>beforeExecute：</strong>扩展前置处理，出现异常，任务则不执行</li><li><strong>afterExecute：</strong>扩展后置处理</li><li><strong>terminated：</strong>所有任务完成且所有工作线程也关闭，terminated 会释放 Executor 在生命周期中分配的资源</li></ul><h1 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h1><p><strong>串行操作降低可伸缩性，而上下文切换回降低性能。在锁上发生竞争会同时导致这两个问题，因此减少锁的竞争能够提高性能急可伸缩性。（线程阻塞会频繁导致上下文切换）</strong></p><h2 id="缩小锁的范围"><a href="#缩小锁的范围" class="headerlink" title="缩小锁的范围"></a>缩小锁的范围</h2><p>降低锁发生竞争的可能性，有效方法之一是<strong>减少锁的持有时间</strong>。例如，可将一些与锁无关的代码移出同步代码块，尤其是那些开销大的操作、以及可能被阻塞的操作，如IO操作。</p><p>细化加锁的代码范围，可以有效减少锁持有时间。而有时同步代码范围也不难过小，一些需要保证原子性的操作，必须包含在一个同步块中。</p><p><strong>例：将一个同步方法改写成内部关键逻辑使用 synchronized 修饰，减少锁内部逻辑执行的时间。</strong></p><h2 id="减小锁的粒度——锁分解"><a href="#减小锁的粒度——锁分解" class="headerlink" title="减小锁的粒度——锁分解"></a>减小锁的粒度——锁分解</h2><p>另一种<strong>减少锁的持有时间</strong>的方式是<strong>降低线程请求锁的频率</strong>，进而减少发生竞争的可能性。</p><p>如一个锁需要保护<strong>多个相互独立的状态变量</strong>，你们可以将这个锁分解为多个锁，每个锁保护一个变量，降低每个锁被请求的频率，提高可伸缩性。</p><p>对竞争适中的锁进行分解时，实际上时将这些锁转变为非竞争锁，有效提高性能。而对竞争并不激烈的锁进行分解，则提升有限。</p><p><strong>例：前提是一个类有多个独立的变量，且当前类存在多个同步方法，未进行锁分解前，所有方法都会针对当前实例获取锁，进行锁分解后，我们取消同步方法，改为在方法内部使用 synchronized 获取的锁则是各个逻辑对应的独立变量，这样所有方法锁的对象就细化了，减小了锁的粒度。</strong></p><h2 id="减小锁的粒度——锁分段"><a href="#减小锁的粒度——锁分段" class="headerlink" title="减小锁的粒度——锁分段"></a>减小锁的粒度——锁分段</h2><p>将一个竞争激烈的锁分解为两个锁，分解后的多个锁可能都存在激烈的竞争，在多处理器系统中，无法得到最大的性能提升，</p><p>某些情况下，可将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，即锁分段，细化作用域。</p><p>ConcurrentHashMap jdk1.7就是分段锁实现，现在jdk1.8已经换成 cas + synchronized，通过减少锁粒度，从1.7的分段到1.8的各个节点，进一步优化，相当于进一步分段了，具体后面我考虑去写一下ConcurrentHashMap的源码分析，到时候在关注细节。</p><p><strong>例：存在一个map实例中，可以通过hash算法（通过hashcode设计）获取每个线程对应的映射，也就是将map中实例分段操作，每次锁的对象由一个map实例变为算法处理后各个线程对应的子模块，各个线程操作的区间不一样，减小锁粒度提高性能。</strong></p><h2 id="放弃独占锁"><a href="#放弃独占锁" class="headerlink" title="放弃独占锁"></a>放弃独占锁</h2><p>第三种降低锁竞争的方式就是放弃使用独占锁，才有非独占锁或非阻塞锁进行优化。</p><ul><li>读写锁 ReadWriteLock，读锁共享，写锁独占</li><li>原子类，提供在整数、对象引用上的细粒度原子操作</li></ul><h1 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h1><h2 id="Lock与ReentrantLock"><a href="#Lock与ReentrantLock" class="headerlink" title="Lock与ReentrantLock"></a>Lock与ReentrantLock</h2><p>和syn同步代码块内置加锁机制不同，Lock接口提供了多种锁获取的方式，且所有加锁、解锁方法都是显式的。ReentrantLock 实现 Lock接口，并提供与 syn 相同的互斥性和内存可见性。获取 ReentrantLock 时，有着与进入同步代码块相同的内存语义，释放 ReentrantLock 时 ，同样有与退出同步代码块相同的内存语义。此外，ReentrantLock 和 synchronized 一样具有可重入的加锁语义。</p><p>至于为什么要创建一种和内置锁高度相似的锁机制，这是因为内置锁存在一定局限性。内置锁必须在获取该锁的代码块中释放，进入代码块获取锁，退出代码块释放锁，简化了编码工作，<strong>但却无法实现非阻塞结构的加锁规则。</strong></p><p>通常我们使用Lock接口，需要 try-finally 格式，在finally中确保锁的释放。以下展示四种加锁机制：</p><ul><li>独占锁</li><li>轮询锁，根据非阻塞加锁进行轮询重试</li><li>定时锁，未超时期间为独占，被阻塞住可响应中断</li><li>可感知中断的独占锁</li><li>非块结构的加锁，显示锁的lock可以应对非块结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占锁，阻塞</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配合循环一直重试组成轮询锁，非阻塞加锁，有返回值</span></span><br><span class="line"><span class="keyword">boolean</span> b = lock.tryLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时锁，超时时间内是独占锁，阻塞，超时后变为非阻塞，有返回值。且阻塞时可以响应中断</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> b1 = lock.tryLock(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 感知中断的独占锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syn同步代码块，块结构加锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">doSomthing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><p>ReentrantLock 有公平锁、非公平锁两种实现，公平锁线程按照发出请求的顺序获得锁，而非公平锁允许插队，即某线程请求非公平锁时，若发出请求的同时该锁的状态变为可用，则跳过队列中所有的等待线程并获得该锁。</p><p>普通场景我们都是使用默认实现，即非公平锁提高吞吐量，有需要使用公平锁的特殊场景则另外讨论。</p><h2 id="synchronized、ReentrantLock-的选择"><a href="#synchronized、ReentrantLock-的选择" class="headerlink" title="synchronized、ReentrantLock 的选择"></a>synchronized、ReentrantLock 的选择</h2><p>为什么有了 ReentrantLock 我们还在用 synchronized？主要是 synchronized 可以自动释放锁，没有了ReentrantLock 忘记释放锁的隐患，且 synchronized 已经被广泛使用也能满足普通需求。而 ReentrantLock 主要是适用于内置锁无法满足需求的情况下，充当一种高级工具，提供一些高阶功能，我们普通加锁使用 synchronized 就够了。</p><p>此外 synchronized 相比 ReentrantLock 还有一个优点：<strong>线程转储中能给出在哪些调用帧中获得了哪些锁，并可以检测和识别发生死锁的线程。</strong>而 ReentrantLock 想实现这个功能需要自行实现接口，ReentrantLock 的非块结构特性意味着获取锁的操作不能与特定的栈帧关联起来，而 synchronized 可以。</p><h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><p>读写锁放宽加锁需求，允许多个读线程同时访问，可以提升系统性能。只要每个线程都能确保读取到最新数据，且读取数据时不会有其他线程修改数据，就不会发生问题，基于此种情况使用读写锁，<strong>读锁可被多个线程持有，写锁只能被单一线程持有。</strong></p><p>在多处理器系统上被频繁读取的数据结构，读写锁能提高性能，而其他情况下读写锁因为复杂性高于独占锁，性能会略差一点。基于实际场景使用。</p><p><strong>多线程读写锁，读读共享、读写互斥、写读互斥、写写互斥，但是内部加锁操作有所不同。</strong></p><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>读写锁，读锁、写锁都是可重入的，写锁内部加写锁不会死锁。</p><h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>当一个线程持有写锁，当它未释放写锁的情况下获取读锁，这会使写锁降级为读锁，同时不允许其他写线程修改被保护的资源，<strong>锁降级是为了保证线程的可见性。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDegrade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    Lock writeLock = lock.writeLock();</span><br><span class="line">    Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockDegrade degrade = <span class="keyword">new</span> LockDegrade();</span><br><span class="line">        <span class="keyword">new</span> Thread(degrade::doSomething).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(degrade::doSomething).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    public void doSomething () &#123;</span></span><br><span class="line"><span class="comment">//        writeLock.lock();</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//        ++i;</span></span><br><span class="line"><span class="comment">//        try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(i);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//        writeLock.unlock();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public void doSomething () &#123;</span></span><br><span class="line"><span class="comment">//        writeLock.lock();</span></span><br><span class="line"><span class="comment">//        ++i;</span></span><br><span class="line"><span class="comment">//        writeLock.unlock();</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//      try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(i);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        ++i;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        </span><br><span class="line">        writeLock.unlock();</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面这个demo我们来分析一下锁降级，3个doSomething的写法逐个分析</p><ul><li>第一种写法是通过写锁互斥，让每个线程都能读到自己修改后的变量值，假定业务有优化空间，只有数据修改这一步是并发的，那么我们可以相应的减小锁的范围，提高性能。</li><li>第二种写法是我们为了减小锁的范围，只将数据修改包裹在写锁内，后续释放锁根据数据走业务逻辑，但此时可能会出现问题，当线程A写锁释放后，线程B就可以拿到写锁进行数据修改操作，此时如果线程A后续业务读取数据的操作还未执行，那么线程A的变量值会变为线程B修改后的值，此时当业务再来读取，就产生了一致性问题。面对第二种写法的问题就有锁降级这种处理方式。</li><li>第三种写法就是锁降级，我们在执行完数据修改操作后，继续在线程内部获取读锁，接着我们在释放写锁，此时写锁被释放肯定会有其他线程来竞争，但是我们加了读锁，由于读写互斥的原因，其他写线程获取不到写锁，随后我们执行业务操作就能得到当前线程修改的变量值，最后释放掉读锁其他写线程又可以来竞争了。使用锁降级和第一种纯写锁包裹的区别，就是读数据这一步是共享的，性能可能比写锁包裹高一点，这一点算是我的猜想，这里的示例也是为了讲清楚锁降级到底是干啥，能否应用到实际项目我们需要结合实际场景讨论。</li></ul><h3 id="为什么没有锁升级（附加写锁、读锁源码浅析）"><a href="#为什么没有锁升级（附加写锁、读锁源码浅析）" class="headerlink" title="为什么没有锁升级（附加写锁、读锁源码浅析）"></a>为什么没有锁升级（附加写锁、读锁源码浅析）</h3><p>既然可以将写锁降级为读锁，保证一致性，那么有没有可能将读锁升级为写锁呢，答案是不可以。</p><p>以下为网络答案：读锁升级死锁这种写法会导致死锁，因为读锁可以多线程同时持有，写锁只能单一线程持有，读锁升级需要其他线程的读锁都释放掉才可以，所以每个持有读锁的线程都是等待其他线程释放读锁，然后再去获取写锁，这个互相等待读锁释放的过程就是一个明显的死锁，所以永远获取不到写锁，无法锁升级。</p><p>看了网上形形色色的解析，没有一个基于code证明说法的，今天不信邪来看看源码是怎么写的。以下是我对写锁、读锁源码的粗略分析。</p><ul><li>写锁分析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写锁加锁方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 线程获取锁的标识，可以当作数量，获取写锁+1，获取读锁+65536，</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写锁个数，除重入锁的情况下，这个计数永远不会&gt;1，可认为是写锁的可重入数，具体实现看后面代码</span></span><br><span class="line">    <span class="comment">// 加读锁，不影响写锁的可重入数，读锁重入锁是另一种计算方式，底层通过位运算实现</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// state不为0，说明有线程获取了读锁或写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、可重入数==0，true:有线程获取了读锁，false:有线程获取了写锁</span></span><br><span class="line">        <span class="comment">// 2、有线程获取了写锁，判断当前线程是不是独占线程，</span></span><br><span class="line">        <span class="comment">// true:说明不是当前线程获取读锁，false:当前线程获取了写锁</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">// 1、只要有线程获取了读锁，加写锁就失败，2、其他线程获取了写锁，写写互斥，加写锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 判断写锁的可重入数在这次加锁后是否超过上线，超过则抛error</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 重入锁，对标识位++，这里可以发现重入锁是直接操作标识位，没有通过cas操作</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、写锁是否应该阻塞，非公平锁=false，公平锁会进阻塞队列判断节点</span></span><br><span class="line">    <span class="comment">// 2、通过校验，cas加锁并取反结果，写锁state+=1，false:加锁成功，true:枷锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="comment">// 写锁被公平锁阻塞队列阻塞；或cas加锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// cas加锁成功将当前线程设置为独占线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可重入锁的上限，超过会报error，自己可以new个写锁跑循环试试</span></span><br><span class="line"><span class="comment">// 这个上限设计和加读锁，state+65536这些设计都是挂钩的，jdk位运算玩的6</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; i++)&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读锁分析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读锁加锁方法，写锁中出现过的简单注释就不重复了</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 1、可重入数!=0，true:有线程获取了写锁，false:有线程获取了读锁，2、见写锁中判断注释</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="comment">// 有其他线程获取了写锁，写读互斥加读锁失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 读锁的可重入数</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 1、读锁是否应该阻塞，这里面有多个极端场景的校验，我们暂不讨论，2、不超过可重入上限</span></span><br><span class="line">    <span class="comment">// 3、cas加锁，这里可以发现读锁加锁state+=SHARED_UNIT，去源码看是位运算的65536</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有可重入数，标记为第一次加读锁的线程，count=1</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 有可重入数，且当前线程是第一次加读锁的线程，直接对第一次Reader的变量++</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有可重入数，且不是第一次加读锁的线程，拿缓存</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 1、缓存拿不到，说明是头一次获取读锁的线程，</span></span><br><span class="line">                <span class="comment">// 2、缓存tid与当前线程不匹配，从本地ThreadLocal获取，此处设计我不知道用意</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 缓存拿到且是当前线程，而计数为0，则放到本地ThreadLocal</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 缓存计数++</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读锁被校验阻塞 或 加锁失败继续走逻辑，以后做AQS全解我们在慢慢理，现在就不进一步了</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ul><li><strong>加写锁时，无论是当前线程还是其他线程，只要有线程持有读锁就加写锁失败，这里也就解释了为什么锁升级会失败，必须等读锁全部释放才能加锁，网上的结论确实是对的，至于原因如果我不分析永远都不知道了，就没看到一篇文章对着代码分析过。。。</strong></li><li><strong>加写锁，若其他线程持有写锁，写写互斥，加锁失败</strong></li><li><strong>加写锁，若当前线程持有写锁，可重入性，可以加锁</strong></li><li><strong>加读锁，若其他线程持有写锁，写读互斥，加锁失败</strong></li><li><strong>加读锁，除了其他线程持有写锁的情况都能触发加锁逻辑，所以当前线程持有写锁不影响其获取读锁，这也就是锁降级可行的原因，而且读读也不影响，读读共享得到验证</strong></li></ul><h2 id="Condition（类比wait）"><a href="#Condition（类比wait）" class="headerlink" title="Condition（类比wait）"></a>Condition（类比wait）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Condition condition &#x3D; Lock.newCondition();</span><br><span class="line">condition.await();</span><br><span class="line">condition.signal();</span><br></pre></td></tr></table></figure><p>对于每个Lock，可以有任意数量的Condition对象，可使用Condition对显示锁进行等待、唤醒操作，而不是Object的wait、notify，当然和内置锁一样，显示锁使用Condition进行等待、唤醒前需要先获取锁。</p><p>ps：在Condition对象中，对应wait、notify、notifyAll的分别是await、signal、signalAll，但是Condition对Object进行了扩展，它也包含了wait、notify，我们一定要使用正确的版本——await、signal</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>compareAndSwap 比较并设置，无论操作是否成功都有返回，CAS包含了三个操作数，需要读写的内存位置V、进行比较的值A、拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。</p><p>当多线程尝试使用CAS同时更新一个变量时，只有其中一个线程能更新变量值，而其他线程都将失败，失败线程不会被挂起，而是告知竞争失败。CAS可实现原子性的读—改—写操作。</p><h2 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h2><p>当数据A被两个线程X、Y都同时读到，Y线程先处理其他业务，而X则进行两次CAS操作，数据变化为 A -&gt; B，B -&gt; A，最后等Y处理完业务进行CAS操作时，看到的数据仍然是A，误以为没有改变，成功执行了CAS，其实在实际操作中该数据是被改变了，这种中间状态的不可查情况即是ABA问题。</p><p>对于触发这种问题的场景，常规解决方案是引入第三方参数进行辅助校验，例如版本号机制，每次操作数据则版本号递增，即使多个线程读取数据时值一样，但轮到每个线程操作时版本号不一致，说明中间状态被修改过，CAS执行失败。</p><p>一般CAS操作是在Unsafe类中实现，针对int、long、object三种类型有三种实现<code>compareAndSwapInt</code>，<code>compareAndSwapLong</code>，<code>compareAndSwapObject</code>，原子类中会分别基于这三种原生方法进行封装，而解决ABA问题就有两个原子类可以实现，<code>AtomicStampedReference</code>，<code>AtomicMarkableReference</code>，第一个是类似于版本号的实现，第二个是通过true false进行辅助标记。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存可见性&quot;&gt;&lt;a href=&quot;#内存可见性&quot; class=&quot;headerlink&quot; title=&quot;内存可见性&quot;&gt;&lt;/a&gt;内存可见性&lt;/h1&gt;&lt;p&gt;通常我们无法确保执行读操作的线程能适时的看到其他写线程写入的值，为了确保多线程间对内存写入操作的可见性，必须使用同步</summary>
      
    
    
    
    <category term="工作 &amp; 源码" scheme="http://aidianfirst.com/categories/%E5%B7%A5%E4%BD%9C-%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>ES operation mark</title>
    <link href="http://aidianfirst.com/2023/07/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/ES/"/>
    <id>http://aidianfirst.com/2023/07/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/ES/</id>
    <published>2023-07-30T11:20:17.727Z</published>
    <updated>2023-12-08T09:31:23.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><h2 id="数据迁移流程"><a href="#数据迁移流程" class="headerlink" title="数据迁移流程"></a>数据迁移流程</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将上次的备份数据清空</span></span><br><span class="line"><span class="string">delete</span> <span class="string">/logger_mes_bak</span></span><br><span class="line"><span class="string">delete</span> <span class="string">/logger_mcs_bak</span></span><br><span class="line"><span class="string">delete</span> <span class="string">/logger_mcs_command_bak</span></span><br><span class="line"><span class="string">delete</span> <span class="string">/logger_mcs_exception_bak</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份索引</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">/logger_mcs_exception_bak</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;:</span> <span class="number">6</span>,</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;refresh_interval&quot;:</span> <span class="number">-1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">        <span class="string">&quot;carrier&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;format&quot;</span> <span class="string">:</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS || yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;data&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;detail&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;device&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;logType&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;vehicle&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧索引数据拷贝至备份索引，reindex多参数配置，进行异步操作</span></span><br><span class="line"><span class="string">POST</span> <span class="string">/_reindex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mcs_exception&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mcs_exception_bak&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新备份索引</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">/logger_mcs_exception_bak/_settings</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;refresh_interval&quot;:</span> <span class="string">&quot;1s&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;number_of_replicas&quot;:</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧索引</span></span><br><span class="line"><span class="string">DELETE</span> <span class="string">/logger_mcs_exception</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新索引</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">/logger_mcs_exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;:</span> <span class="number">6</span>,</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;:</span> <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;refresh_interval&quot;:</span> <span class="number">-1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">        <span class="string">&quot;carrier&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;createTime&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;format&quot;</span> <span class="string">:</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS || yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;data&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;detail&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;device&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;logType&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;vehicle&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> <span class="string">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份数据拷贝到新索引</span></span><br><span class="line"><span class="string">POST</span> <span class="string">/_reindex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mcs_exception_bak&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mcs_exception&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新新索引</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">/logger_mcs_exception/_settings</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;refresh_interval&quot;:</span> <span class="string">&quot;1s&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;number_of_replicas&quot;:</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reindex-数据迁移"><a href="#reindex-数据迁移" class="headerlink" title="reindex 数据迁移"></a>reindex 数据迁移</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/docs-reindex.html#docs-reindex-api-request-body">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/docs-reindex.html#docs-reindex-api-request-body</a></p><p>script 使用脚本操作，有两个配置项，source：脚本内容，lang：脚本语言类型（默认实现是painless），详情见 官方文档 Request body</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该语句执行成功后 右侧会出现&quot;task&quot; : &quot;任务id&quot;，把任务id记录下来，不要左右引号</span></span><br><span class="line"><span class="string">POST</span> <span class="string">/_reindex?wait_for_completion=false</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mes&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mes_bak&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;script&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;:</span> <span class="string">&quot;ctx._source.remove(\&quot;returnCode\&quot;);ctx._source.remove(\&quot;returnMessage\&quot;)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把&lt;task-id&gt;换成上一步操作得到的任务id，不要引号，执行后可在右侧查看迁移情况，&quot;completed&quot; : true代表完成迁移</span></span><br><span class="line"><span class="string">GET</span> <span class="string">_tasks/&lt;task-id&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果es集群负载过大，可通过任务id停止操作</span></span><br><span class="line"><span class="string">POST</span> <span class="string">_tasks/&lt;task-id&gt;/_cancel</span></span><br></pre></td></tr></table></figure><p>reindex 来源数据和终点数据可进行查询配置迁移的内容，详情见 官方文档 Request body</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">POST</span> <span class="string">/_reindex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mes&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;range&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;createTime&quot;:</span> &#123;</span><br><span class="line">              <span class="attr">&quot;gte&quot;:</span> ,</span><br><span class="line">              <span class="attr">&quot;lte&quot;:</span> </span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> <span class="string">&quot;logger_mes_bak&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="delete-by-query"><a href="#delete-by-query" class="headerlink" title="delete by query"></a>delete by query</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/docs-update-by-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/docs-update-by-query.html</a></p><p>scroll_size：单次内存操作数据量</p><p>slices：异步线程，最好配置为auto，es会自动分配和分片数一致，异步线程数大于分片数反而会导致性能低下</p><p>wait_for_completion：异步执行操作，请求response为task-id，查询任务跟进请求执行情况</p><p>refresh：请求执行成功后刷新所有受影响的分片</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">POST</span> <span class="string">/&lt;index_name&gt;/_delete_by_query?scroll_size=5000&amp;slices=10&amp;wait_for_completion=false&amp;refresh=true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;date&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;lt&quot;:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用java进行code实现时需注意（RestHighLevelClient）"><a href="#使用java进行code实现时需注意（RestHighLevelClient）" class="headerlink" title="使用java进行code实现时需注意（RestHighLevelClient）"></a>使用java进行code实现时需注意（RestHighLevelClient）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submitDeleteByQueryTask wait_for_completion &#x3D; false es实现的异步操作，返回值taskid，可根据id查看</span><br><span class="line">deleteByQueryAsync wait_for_completion &#x3D; true 代码层面实现异步</span><br><span class="line">deleteByQuery wait_for_completion &#x3D; true 同步删除</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生api翻译一下，执行任务有上述三种方法，代码实现多了一种异步</span></span><br><span class="line">DeleteByQueryRequest request = <span class="keyword">new</span> DeleteByQueryRequest(index);</span><br><span class="line">request.setBatchSize(<span class="number">5000</span>);</span><br><span class="line">request.setSlices(AbstractBulkByScrollRequest.AUTO_SLICES);</span><br><span class="line">request.setRefresh(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">TaskSubmissionResponse taskSubmissionResponse = esClient.submitDeleteByQueryTask(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure><p><strong>这里需要注意的时BatchSize参数对应scroll_size，虽然注释有写，但是初看代码时有疑惑，因为这个参数实际赋值如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DeleteByQueryRequest <span class="title">setBatchSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    getSearchRequest().source().size(size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用的时size参数，刚好我在代码实现时有考虑类似数据库限制每次操作的数据量，因为query时就有这个size参数，所以自己看源码时就有疑问，deleteByQuery是否支持size限制数据量，BatchSize和scroll_size是否为同一个字段，下面我来解密</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestConverters.class#prepareDeleteByQueryRequest(...) 598</span></span><br><span class="line"><span class="keyword">if</span> (deleteByQueryRequest.getBatchSize() != AbstractBulkByScrollRequest.DEFAULT_SCROLL_SIZE) &#123;</span><br><span class="line">    params.putParam(<span class="string">&quot;scroll_size&quot;</span>, Integer.toString(deleteByQueryRequest.getBatchSize()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里我们就能看到实际在deleteByQuery时使用这个字段的值赋给了scroll_size，本来这个字段是query的通用字段，但是在es对delete的实现中封装了一层，构造请求时分成select、update、delete三种，各个参数的应用点也就不同了</strong></p><h2 id="单表全数据"><a href="#单表全数据" class="headerlink" title="单表全数据"></a>单表全数据</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">/logger_moc/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;track_total_hits&quot;:</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询全部索引情况"><a href="#查询全部索引情况" class="headerlink" title="查询全部索引情况"></a>查询全部索引情况</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">/_cat/indices?v</span></span><br></pre></td></tr></table></figure><h2 id="节点堆内存，分片设置"><a href="#节点堆内存，分片设置" class="headerlink" title="节点堆内存，分片设置"></a>节点堆内存，分片设置</h2><p><a href="https://juejin.cn/post/7202639428132094010">关于ES分片设置的6个建议 - 掘金 (juejin.cn)</a></p><p>es分片设置前需要对索引存储进行评估，最好每个分片处于1~50G</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;nodes?v&amp;h&#x3D;heap*</span><br><span class="line"></span><br><span class="line">GET &#x2F;_nodes&#x2F;stats&#x2F;jvm?pretty</span><br><span class="line"></span><br><span class="line">GET &#x2F;_nodes&#x2F;stats&#x2F;jvm?filter_path&#x3D;nodes.*.jvm.mem.heap_*</span><br></pre></td></tr></table></figure><h2 id="集群级别配置修改"><a href="#集群级别配置修改" class="headerlink" title="集群级别配置修改"></a>集群级别配置修改</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有集群级别的配置</span></span><br><span class="line"><span class="string">get</span> <span class="string">_cluster/settings</span></span><br><span class="line"><span class="comment"># response主要有两个主体</span></span><br><span class="line"><span class="string">persistent：这些设置会一直生效，即使集群重启。这些设置可以通过</span> <span class="string">API</span> <span class="string">或者配置文件</span> <span class="string">elasticsearch.yml</span> <span class="string">来进行设置。</span></span><br><span class="line"><span class="string">transient：这些设置在集群重启之前一直会生效。一旦整个集群重启，这些设置就被清除。这些设置可以通过</span> <span class="string">API</span> <span class="string">来进行设置。</span></span><br></pre></td></tr></table></figure><h1 id="docker-通过插件查看容器启动命名"><a href="#docker-通过插件查看容器启动命名" class="headerlink" title="docker 通过插件查看容器启动命名"></a>docker 通过插件查看容器启动命名</h1><p><a href="https://hub.docker.com/r/cucker/get_command_4_run_container">https://hub.docker.com/r/cucker/get_command_4_run_container</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">cucker/get_command_4_run_container</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装插件命令，--privileged 给予容器权限</span></span><br><span class="line"><span class="string">echo</span> <span class="string">&quot;alias get_run_command=&#x27;docker run  --privileged --rm -v /var/run/docker.sock:/var/run/docker.sock cucker/get_command_4_run_container&#x27;&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用命令</span></span><br><span class="line"><span class="string">.</span> <span class="string">~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="string">get_run_command</span> <span class="string">&lt;容器NAME&gt;/&lt;容器ID&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ES-ILM-amp-rollover-索引滚动"><a href="#ES-ILM-amp-rollover-索引滚动" class="headerlink" title="ES ILM &amp; rollover 索引滚动"></a>ES ILM &amp; rollover 索引滚动</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-index-lifecycle.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-index-lifecycle.html</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-rollover.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-rollover.html</a></p><h2 id="ILM-config"><a href="#ILM-config" class="headerlink" title="ILM config"></a>ILM config</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-settings.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-settings.html</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群级别配置修改ILM策略应用频率，默认值10min</span></span><br><span class="line"><span class="string">indices.lifecycle.poll_interval</span></span><br><span class="line"></span><br><span class="line"><span class="string">PUT</span> <span class="string">_cluster/settings</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;transient&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;indices.lifecycle.poll_interval&quot;:</span> <span class="string">&quot;1m&quot;</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ILM-policy"><a href="#ILM-policy" class="headerlink" title="ILM policy"></a>ILM policy</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-rollover.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/ilm-rollover.html</a></p><p>rollover 滚动api搭配ILM自动进行生命周期管理</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PUT</span> <span class="string">_ilm/policy/&lt;policy_name&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;policy&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;phases&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;hot&quot;:</span> &#123;                      </span><br><span class="line">        <span class="attr">&quot;actions&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;rollover&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;max_age&quot;:</span> <span class="string">&quot;30d&quot;</span> </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;delete&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;min_age&quot;:</span> <span class="string">&quot;180d&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;actions&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;delete&quot;:</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="index-template"><a href="#index-template" class="headerlink" title="index template"></a>index template</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PUT</span> <span class="string">_template/&lt;template_name&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;index_patterns&quot;:</span> [</span><br><span class="line">    <span class="string">&quot;&lt;index_name-predfix&gt;-*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;lifecycle.name&quot;:</span> <span class="string">&quot;&lt;policy_name&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;lifecycle.rollover_alias&quot;:</span> <span class="string">&quot;&lt;your_alias&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;number_of_shards&quot;:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;:</span> &#123;</span><br><span class="line">      <span class="string">.....</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init-index-amp-set-alias"><a href="#init-index-amp-set-alias" class="headerlink" title="init index &amp; set alias"></a>init index &amp; set alias</h2><p>is_write_index：表示当前索引是写入索引</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PUT</span> <span class="string">/&lt;index_name&gt;-000001</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;aliases&quot;:</span> &#123;</span><br><span class="line">    <span class="string">&quot;&lt;your_alias&gt;&quot;</span><span class="string">:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;is_write_index&quot;:</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 is_write_index 参数在 rollover index api 中有记载，索引滚动有多种场景，详情看文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-rollover-index.html#">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-rollover-index.html#</a></p><p>我们这里别名对应多个索引，需要指定哪个索引是当前最新写入的，所以初始化时设置 “is_write_index”: true，触发滚动后新索引会被设置为”is_write_index”: true，旧索引值被修改为false</p><h2 id="手动执行滚动策略"><a href="#手动执行滚动策略" class="headerlink" title="手动执行滚动策略"></a>手动执行滚动策略</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-rollover-index.html#">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-rollover-index.html#</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">POST</span> <span class="string">/&lt;your_alias&gt;/_rollover</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;conditions&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;max_docs&quot;:</span>  <span class="number">50000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><h2 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h2><p>配置项：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.9/configuring-howto-filebeat.html">https://www.elastic.co/guide/en/beats/filebeat/7.9/configuring-howto-filebeat.html</a></p><p>模板化配置文件：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.9/filebeat-reference-yml.html">https://www.elastic.co/guide/en/beats/filebeat/7.9/filebeat-reference-yml.html</a></p><p>filebeat日志多行匹配：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.9/multiline-examples.html#multiline">https://www.elastic.co/guide/en/beats/filebeat/7.9/multiline-examples.html#multiline</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /u01/soft/filebeat/filebeat.yml filebeat.yml 输入源input、modules。modules是一些日志收集方式的官方实现，input则是自定义收集</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/share/filebeat/logs/mcs-service.log</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">mcs</span></span><br><span class="line">  <span class="comment"># 跨多行日志处理，例如堆栈信息，每次日志打印开头必是日期，所以这里采用日期分割，这里和你的logback输出相对应</span></span><br><span class="line">  <span class="attr">multiline.type:</span> <span class="string">pattern</span></span><br><span class="line">  <span class="attr">multiline.pattern:</span> <span class="string">&#x27;^\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;&#x27;</span></span><br><span class="line">  <span class="attr">multiline.negate:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">multiline.match:</span> <span class="string">after</span></span><br><span class="line">  </span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/share/filebeat/logs/mes-service.log</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">mes</span></span><br><span class="line">  <span class="attr">multiline.type:</span> <span class="string">pattern</span></span><br><span class="line">  <span class="attr">multiline.pattern:</span> <span class="string">&#x27;^\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;&#x27;</span></span><br><span class="line">  <span class="attr">multiline.negate:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">multiline.match:</span> <span class="string">after</span></span><br><span class="line"><span class="comment"># 忽略指定时间跨度前的文件</span></span><br><span class="line"><span class="attr">ignore_older:</span> <span class="string">2h</span></span><br><span class="line"><span class="comment"># 指定时间范围内文件未发生改变，则关闭文件处理</span></span><br><span class="line"><span class="attr">close_inactive:</span> <span class="string">1m</span></span><br><span class="line"><span class="comment"># 文件刷新频率，默认时间10s</span></span><br><span class="line"><span class="attr">scan_frequency:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;128.168.11.101:5044&quot;</span>]</span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">drop_fields:</span></span><br><span class="line">      <span class="attr">fields:</span> [<span class="string">&quot;agent&quot;</span>,<span class="string">&quot;ecs&quot;</span>,<span class="string">&quot;host&quot;</span>,<span class="string">&quot;input&quot;</span>,<span class="string">&quot;log&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull elastic&#x2F;filebeat:7.9.3</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name filebeat \</span><br><span class="line">--privileged&#x3D;true \</span><br><span class="line">-v &#x2F;u01&#x2F;soft&#x2F;filebeat&#x2F;filebeat.yml:&#x2F;usr&#x2F;share&#x2F;filebeat&#x2F;filebeat.yml \</span><br><span class="line">-v &#x2F;u01&#x2F;soft&#x2F;logs:&#x2F;usr&#x2F;share&#x2F;filebeat&#x2F;logs \</span><br><span class="line">-w &#x2F;usr&#x2F;share&#x2F;filebeat \</span><br><span class="line">elastic&#x2F;filebeat:7.9.3</span><br></pre></td></tr></table></figure><h3 id="收集器多个日志源处理"><a href="#收集器多个日志源处理" class="headerlink" title="收集器多个日志源处理"></a>收集器多个日志源处理</h3><p><a href="https://www.elastic.co/guide/en/beats/filebeat/7.9/filebeat-input-log.html#filebeat-input-log-fields">https://www.elastic.co/guide/en/beats/filebeat/7.9/filebeat-input-log.html#filebeat-input-log-fields</a></p><p>自定义fields字段，logstash进行分类判断</p><h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><p>logstash官方文档：<a href="https://www.elastic.co/guide/en/logstash/7.9/input-plugins.html">https://www.elastic.co/guide/en/logstash/7.9/input-plugins.html</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /u01/soft/logstash/config/logstash.yml logstash.yml</span></span><br><span class="line"><span class="attr">http.host:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9600</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式对比</span></span><br><span class="line"><span class="attr">logback:</span></span><br><span class="line"><span class="string">%date</span> <span class="string">%level</span> [<span class="string">%thread</span>] <span class="string">%logger&#123;36&#125;</span> [<span class="string">%file</span> <span class="string">:</span> <span class="string">%line</span>] <span class="string">%msg%n</span></span><br><span class="line"><span class="attr">logstash:</span></span><br><span class="line"><span class="string">&quot;(?&lt;log_time&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;\s\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;,\d&#123;3&#125;) <span class="template-variable">%&#123;LOGLEVEL:level&#125;</span> \[<span class="template-variable">%&#123;DATA:thread&#125;</span>\] <span class="template-variable">%&#123;JAVACLASS:javaClass&#125;</span> \[<span class="template-variable">%&#123;DATA:class&#125;</span>\] <span class="template-variable">%&#123;GREEDYDATA:data&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logback:</span></span><br><span class="line"><span class="string">%d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss.SSS&#125;</span> <span class="string">%ip</span> <span class="string">%level</span> [<span class="string">%thread</span>] [<span class="string">%file</span> <span class="string">:</span> <span class="string">%line</span>] <span class="string">%msg%n</span></span><br><span class="line"><span class="string">logstash：</span></span><br><span class="line"><span class="string">&quot;(?&lt;log_time&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;\s\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;.\d&#123;3&#125;) <span class="template-variable">%&#123;IP:ip&#125;</span> <span class="template-variable">%&#123;LOGLEVEL:level&#125;</span> \[<span class="template-variable">%&#123;DATA:thread&#125;</span>\] \[<span class="template-variable">%&#123;DATA:class&#125;</span>\] <span class="template-variable">%&#123;GREEDYDATA:data&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /u01/soft/logstash/pipeline/logstash.conf logstash.conf</span></span><br><span class="line"><span class="string">input</span> &#123;</span><br><span class="line"><span class="string">beats</span> &#123;</span><br><span class="line"><span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">filter</span> &#123;</span><br><span class="line"><span class="string">if</span> [<span class="string">fields</span>][<span class="string">type</span>] <span class="string">==</span> <span class="string">&quot;mcs&quot;</span> &#123;</span><br><span class="line">        <span class="string">grok</span> &#123;</span><br><span class="line">            <span class="string">match</span> <span class="string">=&gt;</span> &#123;<span class="string">&quot;message&quot;</span> <span class="string">=&gt;</span> <span class="string">&quot;(?&lt;log_time&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;\s\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;.\d&#123;3&#125;) <span class="template-variable">%&#123;IP:ip&#125;</span> <span class="template-variable">%&#123;LOGLEVEL:level&#125;</span> \[<span class="template-variable">%&#123;DATA:thread&#125;</span>\] \[<span class="template-variable">%&#123;DATA:class&#125;</span>\] <span class="template-variable">%&#123;GREEDYDATA:data&#125;</span>&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">else</span> <span class="string">if</span> [<span class="string">fields</span>][<span class="string">type</span>] <span class="string">==</span> <span class="string">&quot;mes&quot;</span> &#123;</span><br><span class="line">        <span class="string">grok</span> &#123;</span><br><span class="line">            <span class="string">match</span> <span class="string">=&gt;</span> &#123;<span class="string">&quot;message&quot;</span> <span class="string">=&gt;</span> <span class="string">&quot;(?&lt;log_time&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;\s\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;.\d&#123;3&#125;) <span class="template-variable">%&#123;LOGLEVEL:level&#125;</span> \[<span class="template-variable">%&#123;DATA:thread&#125;</span>\] \[<span class="template-variable">%&#123;DATA:class&#125;</span>\] <span class="template-variable">%&#123;GREEDYDATA:data&#125;</span>&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">date</span> &#123;</span><br><span class="line"><span class="string">match</span> <span class="string">=&gt;</span> [<span class="string">&quot;log_time&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>]</span><br><span class="line"><span class="string">target</span> <span class="string">=&gt;</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="string">timezone</span> <span class="string">=&gt;</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">mutate</span> &#123;</span><br><span class="line"><span class="string">remove_field</span> <span class="string">=&gt;</span> [<span class="string">&quot;@version&quot;</span>,<span class="string">&quot;tags&quot;</span>,<span class="string">&quot;message&quot;</span>,<span class="string">&quot;log_time&quot;</span>,<span class="string">&quot;thread&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line"><span class="string">if</span> [<span class="string">fields</span>][<span class="string">type</span>] <span class="string">==</span> <span class="string">&quot;mcs&quot;</span> &#123;</span><br><span class="line"><span class="string">elasticsearch</span> &#123;</span><br><span class="line"><span class="string">hosts</span> <span class="string">=&gt;</span> [<span class="string">&quot;http://128.168.11.112:9200&quot;</span>]</span><br><span class="line"><span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;mcslog-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">else</span> <span class="string">if</span> [<span class="string">fields</span>][<span class="string">type</span>] <span class="string">==</span> <span class="string">&quot;mes&quot;</span> &#123;</span><br><span class="line"><span class="string">elasticsearch</span> &#123;</span><br><span class="line"><span class="string">hosts</span> <span class="string">=&gt;</span> [<span class="string">&quot;http://128.168.11.112:9200&quot;</span>]</span><br><span class="line"><span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;meslog-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 索引自动删除策略</span><br><span class="line">PUT _ilm&#x2F;policy&#x2F;logstash_auto_delete</span><br><span class="line">&#123;</span><br><span class="line">  &quot;policy&quot;: &#123;</span><br><span class="line">    &quot;phases&quot;: &#123;</span><br><span class="line">      &quot;delete&quot;: &#123;</span><br><span class="line">        &quot;min_age&quot;: &quot;7d&quot;,</span><br><span class="line">        &quot;actions&quot;: &#123;</span><br><span class="line">          &quot;delete&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引模板配置：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-templates-v1.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-templates-v1.html</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义日志索引模板 meslog同理</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">_template/mcslog</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;index_patterns&quot;:</span> [</span><br><span class="line">    <span class="string">&quot;mcslog-*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;lifecycle&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;logstash_auto_delete&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;number_of_shards&quot;:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">      <span class="comment"># 单机设置副本分片0 &quot;number_of_replicas&quot; : &quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;:</span> &#123;</span><br><span class="line">      <span class="string">&quot;@timestamp&quot;</span><span class="string">:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;level&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;ip&quot;:</span> &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;class&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;data&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker pull logstash:7.9.3</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name logstash \</span><br><span class="line">--privileged&#x3D;true \</span><br><span class="line">-p 9600:9600 \</span><br><span class="line">-p 5044:5044 \</span><br><span class="line">-v &#x2F;u01&#x2F;soft&#x2F;logstash&#x2F;config&#x2F;logstash.yml:&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;config&#x2F;logstash.yml \</span><br><span class="line">-v &#x2F;u01&#x2F;soft&#x2F;logstash&#x2F;pipeline:&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;pipeline \</span><br><span class="line">-w &#x2F;usr&#x2F;share&#x2F;logstash \</span><br><span class="line">logstash:7.9.3</span><br><span class="line"></span><br><span class="line">-v &#x2F;u01&#x2F;soft&#x2F;logstash&#x2F;data:&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;data \</span><br></pre></td></tr></table></figure><h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><p>kibana配置：<a href="https://www.elastic.co/guide/en/kibana/7.9/settings.html">https://www.elastic.co/guide/en/kibana/7.9/settings.html</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /u01/soft/kibana/kibana.yml kibana.yml</span></span><br><span class="line"><span class="attr">server.name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [ <span class="string">&quot;http://128.168.11.112:9200&quot;</span> ]</span><br><span class="line"><span class="attr">monitoring.ui.container.elasticsearch.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">kibana:7.9.3</span></span><br><span class="line"></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-d</span> <span class="string">\</span></span><br><span class="line"><span class="string">--name</span> <span class="string">kibana</span> <span class="string">\</span></span><br><span class="line"><span class="string">--privileged=true</span> <span class="string">\</span></span><br><span class="line"><span class="string">-p</span> <span class="number">5601</span><span class="string">:5601</span> <span class="string">\</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/u01/soft/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml</span> <span class="string">\</span></span><br><span class="line"><span class="string">-w</span> <span class="string">/usr/share/kibana</span> <span class="string">\</span></span><br><span class="line"><span class="string">kibana:7.9.3</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dateFormatYYYY-MM-DD HH:mm:ss.SSS</span><br><span class="line">dateFormat:tzAsia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><h2 id="logback切割日志，filebeat收集日志是否会冲突？"><a href="#logback切割日志，filebeat收集日志是否会冲突？" class="headerlink" title="logback切割日志，filebeat收集日志是否会冲突？"></a>logback切割日志，filebeat收集日志是否会冲突？</h2><p>logback切割日志，将当前log文件变成我们自定义的zip，并生成新的log，此时filebeat收集日志会不会受到影响？</p><p><a href="https://www.jianshu.com/p/e98287437d41">https://www.jianshu.com/p/e98287437d41</a></p><p>可参考官方文档：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.9/filebeat-input-docker.html#filebeat-input-docker-close-inactive">https://www.elastic.co/guide/en/beats/filebeat/7.9/filebeat-input-docker.html#filebeat-input-docker-close-inactive</a></p><p>close_inactive、scan_frequency等相关配置</p><p>简单说filebeat有刷新机制，不会长期监听一个没有新增内容的文件</p><h2 id="镜像导入导出"><a href="#镜像导入导出" class="headerlink" title="镜像导入导出"></a>镜像导入导出</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">save</span> <span class="string">-o</span> <span class="string">&lt;镜像存储输出路径，保存为tar&gt;</span> <span class="string">&lt;镜像id</span> <span class="string">or</span> <span class="string">镜像名:版本号&gt;</span></span><br><span class="line"><span class="string">上传文件进行宿主机导入</span></span><br><span class="line"><span class="string">docker</span> <span class="string">load</span> <span class="string">-i</span> <span class="string">&lt;tar包上传路径&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据迁移&quot;&gt;&lt;a href=&quot;#数据迁移&quot; class=&quot;headerlink&quot; title=&quot;数据迁移&quot;&gt;&lt;/a&gt;数据迁移&lt;/h1&gt;&lt;h2 id=&quot;数据迁移流程&quot;&gt;&lt;a href=&quot;#数据迁移流程&quot; class=&quot;headerlink&quot; title=&quot;数据迁移流</summary>
      
    
    
    
    <category term="中间件" scheme="http://aidianfirst.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring框架八股</title>
    <link href="http://aidianfirst.com/2021/12/07/%E5%85%AB%E8%82%A1/Spring%E6%A1%86%E6%9E%B6%E5%85%AB%E8%82%A1/"/>
    <id>http://aidianfirst.com/2021/12/07/%E5%85%AB%E8%82%A1/Spring%E6%A1%86%E6%9E%B6%E5%85%AB%E8%82%A1/</id>
    <published>2021-12-07T02:00:08.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://www.jianshu.com/p/ad05cfe7868e">https://www.jianshu.com/p/ad05cfe7868e</a></p><p>IoC控制反转，是一种设计思想，将以往通过手动创建对象的控制权交由Spring管理，<strong>降低对象之间的耦合性</strong>。其控制反转，指的是<strong>控制</strong>对象创建的权力，然后将控制权<strong>反转</strong>交给外部环境管理。</p><p>所有的Bean在项目启动时生成，加载到Spring容器中统一管理，我们需要使用的时候再去容器中取Bean。而不是单独的去new一个相关类来进行调用。</p><p>IoC只是一种思想，而依赖注入DI是具体实现。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>底层xml配置文件，编写对应属性kv，如k - 类名，v - 类的全路径。</p><p>创建一个工厂类解析xml，获取对应类的全路径，并通过反射创建该类对象。</p><p>最后从工厂中调用创建好的对象即可。</p><p>现在我们开发都是使用注解注入Bean替代xml配置。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>AOP面向切面编程，能将与业务无关，却被业务模块共同调用的服务进行封装（如工具类等），然后进行统一调用，降低模块之间的耦合性，利于拓展和维护。</p><p>AOP基于代理模式实现，其分为静态代理和动态代理。</p><ul><li>AspectJ AOP 静态代理</li><li>Spring AOP 动态代理（JDK、CGLIB）</li></ul><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>我们要代理的对象<strong>实现了接口</strong>时，Spring AOP使用 <strong>JDK动态代理</strong> 去创建代理对象；对于<strong>没有实现接口</strong>的对象，Spring AOP使用 <strong>CGLIB动态代理 去生成一个被代理对象的子类来作为代理（继承）</strong>。</p><p>Spring默认使用的 JDK动态代理。</p><h2 id="JDK动态代理原理（反射）"><a href="#JDK动态代理原理（反射）" class="headerlink" title="JDK动态代理原理（反射）"></a>JDK动态代理原理（反射）</h2><ul><li><p>编写一个<strong>代理类</strong>：实现 InvocationHandler 接口，将原类方法通过重写 invoke() 进行代理实现，invoke()中可以自行添加内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * proxy 代理类，method 代理方法，args[] 方法参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure></li><li><p>编写<strong>工厂类生成代理对象</strong>：Proxy.newProxyinstance，获取全部接口，将接口方法通过代理进行增强，最后返回代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader 类加载器，interfaces[] 全部接口，handler 自行实现的代理类</span></span><br><span class="line">newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)</span><br></pre></td></tr></table></figure></li></ul><p>JDK动态代理基于<strong>反射</strong>实现，工厂类实现了原类的全部接口，并对接口的所有方法进行了代理。通过代理对象执行原类方法时，代理对象会通过反射回调我们实现的代理类的 invoke()，也就是代理方法被调用。</p><p><strong>特点：</strong></p><ul><li>JDK动态代理通过反射实现，是JDK原生的。</li><li>JDK动态代理，被代理类必须实现接口，且只能代理接口中定义的方法，如果代理类自行编写了不存在于接口的方法，那么JDK动态代理不会实现该方法。</li></ul><h2 id="CGLIB动态代理原理（字节码）"><a href="#CGLIB动态代理原理（字节码）" class="headerlink" title="CGLIB动态代理原理（字节码）"></a>CGLIB动态代理原理（字节码）</h2><p>底层对代理类的字节码进行操作，生成该类的一个子类，并重写父类的所有可重写方法，也就是生成自定义的代理方法（自行生成子类继承父类，对子类进行代理）。然后通过字节码操作生成代理类。</p><p><strong>特点：</strong></p><ul><li>CGLIB代理的类无需实现接口，CGLIB会自行生成子类继承原类来代理。</li><li>由于final修饰的类无法被继承，所以CGLIB不能代理final类。</li><li>CGLIB代理是生成子类，对原类方法进行重写，生成相应的代理方法，如果原方法由final 或 private修饰，我们无法重写方法，所以final和private修饰的方法不能被代理。</li></ul><h2 id="AspectJ-AOP（静态代理）"><a href="#AspectJ-AOP（静态代理）" class="headerlink" title="AspectJ AOP（静态代理）"></a>AspectJ AOP（静态代理）</h2><p><strong>Spring AOP是运行时增强，基于代理；Aspect AOP是编译时增强，基于字节码操作。</strong></p><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><p>Bean就是IoC容器管理的对象。</p><h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><p>Bean实例化，根据实现的接口，调用对应方法完成相应操作，如在BeanFactory中获取容器实例，加载Bean所在应用的上下文引用等。</p><p>Bean初始化完成后，可以被应用程序使用，它们一直驻留在应用上下文中，，直到应用上下文被销毁。</p><p>可以执行destroy()销毁Bean。</p><h2 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h2><ul><li>singleton：单例，唯一Bean实例</li><li>prototype：多实例，每次请求都创建一个Bean</li><li>request：每次Http请求都创建一个Bean，只在当前Http request内有效</li><li>session：每次新session的Http请求会创建一个Bean，只有当前HttpSession内有效</li><li>global - session：全局Session，一个Bean对应一个实例</li></ul><h2 id="Bean线程安全问题"><a href="#Bean线程安全问题" class="headerlink" title="Bean线程安全问题"></a>Bean线程安全问题</h2><p>单例可能会设计多线程修改变量。改变Bean作用域，选择多实例，每个请求都创建一个Bean。或使用ThreadLcoal存储变量。</p><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="@Transaction"></a>@Transaction</h2><p>Spring事务对应数据库事务，也是ACID，隔离级别也一致，多了一种默认的级别default，和数据库的级别同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure><p>注意Spring事务默认是运行时异常才回滚，我们可以设置为任何异常都回滚。</p><h2 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h2><p>@Transaction也是通过AOP动态代理实现的。由于是动态代理，只有注解方法被类以外方法调用时事务才生效，如果本类方法直接调用则事务无法生效。</p><h1 id="MyBatis的-、"><a href="#MyBatis的-、" class="headerlink" title="MyBatis的#{}、${}"></a>MyBatis的#{}、${}</h1><ul><li>#{}：sql参数占位符，mybatis会认定传入参数是一个字符串，将其字段加上’ ‘，替换我们需要的参数。经过预编译，防止sql注入。</li><li>${}：变量占位符，直接传值，不做处理。</li></ul><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(···)</span></span><br></pre></td></tr></table></figure><p>主启动类注解由三个注解组成：</p><ul><li><p>@SpringBootConfiguration：代表主启动注解是一个配置类</p></li><li><p>@ComponentScan：默认扫描主启动类包下的全部注入组件（@Component等），可自定义不扫描的Bean。</p></li><li><p>@EnableAutoConfiguration：开启自动装配</p><p>在META-INF/spring.factories下配置自动加载类，一般都是 **AutoConfiguration 结尾的类，通过@Conditional注解按需加载实现自动装配。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IoC&quot;&gt;&lt;a href=&quot;#IoC&quot; class=&quot;headerlink&quot; title=&quot;IoC&quot;&gt;&lt;/a&gt;IoC&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="八股" scheme="http://aidianfirst.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务商城项目学习总结</title>
    <link href="http://aidianfirst.com/2021/11/23/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://aidianfirst.com/2021/11/23/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-23T09:29:08.000Z</published>
    <updated>2023-07-30T11:20:17.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机环境配置"><a href="#虚拟机环境配置" class="headerlink" title="虚拟机环境配置"></a>虚拟机环境配置</h1><p>这次使用Virtual Box + Vagrant完成虚拟机安装，比传统VMware配置镜像更方便，Vagrant可下载打包好的镜像文件进行安装，无需详细配置。</p><p><a href="https://blog.csdn.net/qq_15990969/article/details/113096469">https://blog.csdn.net/qq_15990969/article/details/113096469</a></p><p><a href="https://www.cnblogs.com/lxwphp/p/11121283.html">https://www.cnblogs.com/lxwphp/p/11121283.html</a></p><h1 id="快速反向工程辅助crud"><a href="#快速反向工程辅助crud" class="headerlink" title="快速反向工程辅助crud"></a>快速反向工程辅助crud</h1><p>使用renren脚手架辅助开发，对应前后端分离，renren-fast，renren-fast-vue，renren-generator使用前需删除.git文件，这是官方的git信息</p><p>renren的service层无需注入dao，它继承了一个父类，父类注入了baseMapper，而这个baseMapper的类型是对应继承时类的泛型M的，人人继承这个父类就会用自己的dao实现泛型，所以此时父类注入的baseMapper即我们需要的dao，封装nb。</p><h1 id="商品服务"><a href="#商品服务" class="headerlink" title="商品服务"></a>商品服务</h1><p><a href="https://blog.csdn.net/unique_perfect/article/details/113824202">https://blog.csdn.net/unique_perfect/article/details/113824202</a></p><p>可以拿sql数据，1000+商品词条。</p><h2 id="菜单分级展示"><a href="#菜单分级展示" class="headerlink" title="菜单分级展示"></a>菜单分级展示</h2><p>先查一级菜单，然后递归查询二级菜单，给product商品加上子菜单，方便设置，数据库没有该字段需注明exist。</p><h2 id="网关（跨域）"><a href="#网关（跨域）" class="headerlink" title="网关（跨域）"></a>网关（跨域）</h2><p>通过gateway路由请求，涉及<strong>跨域问题</strong>（同源策略）。</p><p>非简单请求先发送预检请求option，服务器不允许则不发送请求。</p><p>我们在gateway的微服务中进行config配置，使用前置filter过滤请求即可，放行所有的请求都跨域。CorsWebFilter是官方提供跨域过滤器。</p><p><strong>端口号的动态刷新，好像能取改变后的值，但访问的url没变？</strong></p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p><strong>我们删除使用逻辑删除</strong>，即属性有个字段为是否展示，我们提供改变这个字段状态将属性隐藏显示，而不是将数据真正的删除。</p><p>mybatis-plus自带逻辑删除组件配置，yml配置</p><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><p>品牌管理进行后端校验，仅仅前端校验是不够的，以防越过前端直接访问接口。</p><p>@NotBlank等注解标明字段，@Valid标明业务实体类参数，随后进行校验，@NotBlank可自定义message，校验失败返回对应信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可写一个统一的异常处理类，使用@ControllerAdvice</p><p>JSR303还可进行分组校验。使用象征性接口进行标识。</p><h2 id="属性分组"><a href="#属性分组" class="headerlink" title="属性分组"></a>属性分组</h2><p>SPU相当于一个抽象概念，如米8手机。</p><p>SKU是具体概念，也就是米8手机的具体配置，配置不同价值也不同。</p><p>数据库基于这个概念进行分类，如米8 128g，只有黑色、白色内存大小8g，米8 256g，有黑白蓝绿等颜色，内存大小16g，不同的SKU具体实现的内容不同。</p><h2 id="关联分类"><a href="#关联分类" class="headerlink" title="关联分类"></a>关联分类</h2><p>品牌管理可将品牌和分类的关系存到一张表记录，我们修改品牌与分类名时，要联动修改这个表的数据。</p><h2 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h2><p>view object，我们实体类一般用于数据库操作，有时引入其他字段还需要注解标明字段不属于数据库，所以我们可以多进行一层封装，继承实体类，添加用于视图返回的字段。</p><p>我们可以根据应用场景的不同，对原实体类继承后二次封装，防止实体类注解冗余。</p><h2 id="生成商品Vo"><a href="#生成商品Vo" class="headerlink" title="生成商品Vo"></a>生成商品Vo</h2><p>先创建json数据，然后使用工具反向生成vo，导入vo然后用这个实体去进行保存。为了保证精度，小数操作值使用BigDecimal，id使用long。</p><h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>对商品进行添加时，会影响多个表，所以我们使用事务进行控制</p><h2 id="feign服务调用"><a href="#feign服务调用" class="headerlink" title="feign服务调用"></a>feign服务调用</h2><p>spu需要记录优惠信息，调用其他服务的接口，使用TO传输，跨服务传输，可在常用服务组件中封装TO。</p><p>服务调用时，feign接口调用参数需要和服务一致？？？参数需要<code>@RequestBody</code>注解，转为json传输（如果传的是对象实例），可以和服务端实例不同，只要两个转换的json能相互转换即可。但是为了方便我们还是使用同一个传输对象作为保准比较好对应。</p><p>但这里我们调用远端服务使用的是逆向工程直接创建的方法，参数不好改，也可以直接使用实体类，因为json可以互转。</p><h2 id="商品详情"><a href="#商品详情" class="headerlink" title="商品详情"></a>商品详情</h2><p>采用CompletableFuture异步编排进行优化，商品信息是逐个查询的，采用异步编排，自定义线程池，对商品查询进行多线程任务，加快信息的查询速度。</p><h1 id="阿里云第三方服务"><a href="#阿里云第三方服务" class="headerlink" title="阿里云第三方服务"></a>阿里云第三方服务</h1><h2 id="第三方服务云存储OSS"><a href="#第三方服务云存储OSS" class="headerlink" title="第三方服务云存储OSS"></a>第三方服务云存储OSS</h2><p>由于微服务负载均衡，图片等本地存储资源不能存放于服务器，否则其他服务器找不到服务。我们跨域统一存放这类资源到云服务器上，进行统一的调用。阿里云OSS</p><p>文件上传，<strong>使用服务端签名后直传</strong>，借助阿里云封装的sdk完成上传</p><p><a href="https://help.aliyun.com/document_detail/32009.html">https://help.aliyun.com/document_detail/32009.html</a></p><p><a href="https://github.com/alibaba/aliyun-spring-boot/tree/master/aliyun-spring-boot-samples/aliyun-oss-spring-boot-sample">https://github.com/alibaba/aliyun-spring-boot/tree/master/aliyun-spring-boot-samples/aliyun-oss-spring-boot-sample</a></p><p>官方依赖有坑，yml也坑，这里建议比对网络博客</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># 阿里云服务配置</span></span><br><span class="line">    <span class="attr">alicloud:</span></span><br><span class="line">      <span class="attr">access-key:</span> </span><br><span class="line">      <span class="attr">secret-key:</span> </span><br><span class="line">      <span class="attr">oss:</span> </span><br><span class="line">        <span class="attr">endpoint:</span> <span class="string">oss-cn-shanghai.aliyuncs.com</span></span><br></pre></td></tr></table></figure><h2 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h2><p>去阿里云随便找一家短信服务提供商免费测试即可，0元20次套餐够用了，看官方的接口文档进行参数配置。</p><p>调用官方封装的java类，自定义传参即可。还可抽取配置文件，将路径、api等信息再配置文件中进行配置，使用@ConfigurationProperties注解自定义配置文件属性。</p><ul><li>接口防刷</li><li>验证码多次校验</li></ul><h1 id="Elasticsearch（7-6-2）"><a href="#Elasticsearch（7-6-2）" class="headerlink" title="Elasticsearch（7.6.2）"></a>Elasticsearch（7.6.2）</h1><p>索引、文档、倒排索引、分词匹配。</p><p>elasticsearch + kibana，分词器ik-analyzer。</p><p>我们项目使用es使用9200端口，9300相关连接方法已舍弃，只支持6.x。可通过Elasticsearch-Rest-Client，跟进新版本迭代，支持7.x。</p><p>官方：<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.6/java-rest-high.html">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.6/java-rest-high.html</a></p><h2 id="商品上架"><a href="#商品上架" class="headerlink" title="商品上架"></a>商品上架</h2><p>ES只检索上架的商品，上架商品改变状态，并存放到ES，只选择存储关键信息，如商品标题字段就是关键，还要配置分词器，其他的一些展示字段如图片等则不参与聚合操作，只是为了显示.</p><h2 id="检索功能"><a href="#检索功能" class="headerlink" title="检索功能"></a>检索功能</h2><p>检索有多个方式，如关键字检索、分类检索、排序、过滤等。将检索页面需要用到的条件，全部封装成一个对象。</p><p>先封装dsl请求检索语句，将语句通过es对象search后，封装其返回数据交予前端。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ES有更新和检索两个功能，更新在商品上架时，由product远程调用，检索则是页面搜索框调用，其url拼接条件进行检索，根据不同情况写全拼接的状态，如关键词搜索，会对检索关键字自行前端标签的拼接，使其在其前端展示时，取出高亮的前端标签字段。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>ES更新操作怎么处理？我们先将商品下架，删除ES，随后上架再更新？</p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>动静分离，nginx分离静态资源和动态资源。修改hosts，配置虚拟机ip映射。使用插件SwitchHosts。</p><p>nginx代理网关时，会丢失host等信息。请求发送到nginx，nginx转发到网关进一步分配。</p><p>修改host将商城域名映射到linux的ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.56.11 mall.com</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen  [::]:80;</span><br><span class="line">    server_name  mall.com *.mall.com;</span><br><span class="line">    </span><br><span class="line">    location /static/ &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_pass http://mall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream mall&#123;</span><br><span class="line">server 192.168.158.1:3000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以上配置，访问mall.com以及其子域名，会走nginx，若是静态资源，其后链接会跟static，然后走conf的配置，请求去查看nginx的静态资源。其他的正常连接，则走网关代理，网关的ip我们会在nginx.conf中配置，也就是我们主机的网关ip和端口。而且要设置host值，nginx代理会丢失。</p><p>然后我们在网关中进行host映射配置。nginx转发到网关进行代理，会有一开始输入的域名host，这个host则对应网关配置的映射，路由到对应的微服务。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">mall_host_route</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">lb://mall-product</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Host=mall.com,item.mall.com</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">mall_search_route</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">lb://mall-search</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Host=search.mall.com</span></span><br></pre></td></tr></table></figure><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>静态资源放置于nginx，而不是项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /static/ &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_pass http://mall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置请求路径的分发策略，页面所有静态资源+static前缀，对应nginx来匹配其static路径下的资源，其他的接口url走项目。静态资源由nginx处理，和我们服务器无关。</p><p>前端页面有static前缀资源就走nginx内部请求，其他请求走页面请求。</p><h1 id="测试与调优"><a href="#测试与调优" class="headerlink" title="测试与调优"></a>测试与调优</h1><p>使用Jmeter压力测试，Jvisualvm操作JVM（jdk自带，直接命令行启动）。通过测试来判断程序性能，进而对数据库和代码进行调优。</p><p>代码逻辑应尽少于数据库交互，以此来优化代码。所以需要使用缓存来提高性能。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="redis缓存"><a href="#redis缓存" class="headerlink" title="redis缓存"></a>redis缓存</h2><p>设计缓存是为了减少数据库的压力，将部分数据存放到缓存中，比如：</p><ul><li>高访问量，且更新频率小的数据，多读少写（高频热点数据）</li><li>对即时性、数据一致性要求不高的数据</li></ul><p>我们注入redis的start依赖，使用StringRedisTemplate操纵redis</p><p>对即时性、一致性要求高的数据就应该去查数据库，不要求的数据则放入缓存，设置过期时间保证隔段时间获得最新数据。</p><h2 id="分布式锁（Redisson）"><a href="#分布式锁（Redisson）" class="headerlink" title="分布式锁（Redisson）"></a>分布式锁（Redisson）</h2><p>保证多服务调用的数据一致性。</p><p>官方配置了不同语言的分布式锁实现，Java 对应 Redisson。</p><p>Redisson和JUC锁的使用相对应。</p><h2 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h2><p>主启动类 + @EnableCaching</p><p>方法 + @Cacheable等注解，不同注解效果不同，默认是对注解方法的结果进行缓存操作，若结果存在则不调用方法。</p><p>@CacheEvict缓存失效模式</p><p>@Caching多个缓存操作进行组合</p><p>使用SpringCache是再进行复杂查询操作时使用，将结果进行缓存，若在方法内部想使用缓存可直接操作redisTemplate对象，这个注解只是用于缓存返回值。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>登录验证码</li><li>多次查询的数据，如多级菜单</li><li>全局统一存储session</li><li>购物车信息</li><li>热点数据</li></ul><h1 id="系统登录"><a href="#系统登录" class="headerlink" title="系统登录"></a>系统登录</h1><h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>以前都是使用controller，进行mapping路径映射返回string走对应页面，现在由于请求路径过多，配置一个config实现WebMvcConfigurer接口，调用addViewControllers添加路径映射。以防controller有太多空请求方法，导致代码冗余。</p><h2 id="注册时发送验证码"><a href="#注册时发送验证码" class="headerlink" title="注册时发送验证码"></a>注册时发送验证码</h2><p>验证码有很多种情况，我们一个账户当然可以要很多个验证码，一般过期时间时5min，但间隔请求时间是60s。</p><p>由于前端规定验证码获取是60s一次，但可以通过直接接口调用等手段避开前端判断，所以我们需要后端进行逻辑验证。</p><p>在生成验证码时，我们是随机数UUID生成，然后可在其后拼接一个系统时间。</p><p>当前端请求验证码时，先在缓存中获取当前手机的验证码信息，若验证码信息不为空则继续判断，若其生成时间和当前时间间隔不到60s，则需要等待，返回报错信息，这是后端进行接口层上的逻辑完善。</p><p>当然验证码我们拼接了系统时间，可以通过截取字符串来获取前几位的校验字段发给用户，后几位截取记为标记时间。</p><h2 id="注册信息校验"><a href="#注册信息校验" class="headerlink" title="注册信息校验"></a>注册信息校验</h2><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><p>又是md5 + 盐值。。。</p><p>不过有改进，可以使用spring的<code>BCryptPasswordEncoder</code>，不用另行存储盐值，其生成密文通过算法可自行解析盐值，省去了在数据库中进行盐值存储，进一步加强了安全。</p><p>同一个密码明文 + 不同盐值生成的不同随机数，经过算法解密后可得到同一个明文，所以同一个密码无影响，算法自身会解析盐值。</p><p>而登录进行验证时，调用<code>BCryptPasswordEncoder</code>的<strong>matches方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span></span><br></pre></td></tr></table></figure><p>参数一是页面输入原密码，参数二是数据库存储加密密码，由于这个加密是该方法自行生成的，所以可自行验证页面原密码的正确性。返回boolean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span></span><br></pre></td></tr></table></figure><p>通过调用encode方法对原密码加密。</p><h2 id="社交登录-OAuth2-0协议"><a href="#社交登录-OAuth2-0协议" class="headerlink" title="社交登录 OAuth2.0协议"></a>社交登录 OAuth2.0协议</h2><p>系统登录向用户申请第三方请求认证，用户前往第三方服务器进行登录操作，通过验证后，由第三方向系统发送登录令牌，我们系统可通过登录令牌访问第三方服务器获取头像、昵称等公开资源。</p><p>使用QQ作为社交登录，自行验证身份并创建应用。</p><p><a href="https://op.open.qq.com/appregv2/">https://op.open.qq.com/appregv2/</a></p><p><a href="https://connect.qq.com/manage.html#/">https://connect.qq.com/manage.html#/</a></p><p>可以根据官方api获取一些数据。</p><p>。。。。。审核太恶心，不做了。注意社交登录也应将信息注册到系统的数据库。</p><h2 id="Session的状态记录"><a href="#Session的状态记录" class="headerlink" title="Session的状态记录"></a>Session的状态记录</h2><p>以前的单体项目可以使用Session，但Session不能跨域名共享。</p><p>但现在是微服务的项目，服务是分模块的，不同服务间的Session也是不共享的，集群也是。</p><ul><li><p>同一个服务，不同机器，也就是同一个服务的集群session共享解决：</p><ul><li><strong>session复制</strong>，进行集群间机器的session同步，但是同步数据需要数据传输，占用网络资源，且为了保证同步，所有的服务器都要保存，每台服务都要开辟这个session的空间，对于分布式集群很不友好。</li><li><strong>客户端存储</strong>，用户自行保存session到cookie，不安全，而且cookie不能存储大量数据。</li><li><strong>hash一致性</strong>，根据服务ip，将同一个ip的请求都分配到同一个服务器上，也就是负载均衡是分配不同ip的，同一个ip一直用同一个服务器，但是机器水平扩展会导致hash算法出现问题。</li><li><strong>统一存储</strong>，将session不存到服务器，而是redis或其他数据库，没有安全隐患，水平扩展集群不会影响，但缺点是需要多进行一次网络连接数据库，且查询数据库一定比直接的内存查询慢。</li></ul><p><strong>推荐使用hash一致性 或 数据库统一存储。</strong></p></li></ul><h2 id="SpringSession"><a href="#SpringSession" class="headerlink" title="SpringSession"></a>SpringSession</h2><p><a href="https://docs.spring.io/spring-session/docs/2.4.6/reference/html5/#samples">https://docs.spring.io/spring-session/docs/2.4.6/reference/html5/#samples</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml需要指定session的存储数据库，主启动类加上注解@EnableRedisHttpSession，需要修改session的作用域，作用于父域则所有子域都会被辐射到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallSessionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">// 扩大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">&quot;mall.com&quot;</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">&quot;MALL_SESSION&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们每个服务需要用到session时，需要加载pom、config配置类、主启动类注解、yml的配置（redis、session-type）</p><ul><li>spring-session，yml配置其缓存使用的数据库，我们使用redis</li><li>session需要存储的实体类实现序列化Serializable接口，然后在config中自行配置放大作用域，以及redis的json序列化存储。因为我们是用户登录服务进行登录的，是二级域名，需要放大作用域，以便辐射其他服务。</li><li>session首次被set是按kv设置的，我们后续从redis取，也是用这个key去拿。</li></ul><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>多系统间登录互通，比如登录百度账号，所有百度的应用都会自行登录。</p><p>我们前面使用session是对子域名来说的，即mall.com是顶级域名，search.mall.com和auth.mall.com都是其子域名。而单点登录是作用于完全不同的几个域名之间的不同1.com、2.com、3.com。</p><p><a href="https://gitee.com/xuxueli0323/xxl-sso?_from=gitee_search">https://gitee.com/xuxueli0323/xxl-sso?_from=gitee_search</a></p><p>单点登录一般有一个认证服务器，通过该服务器进行跳转。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在子域名进行注册操作，导致要使用统一存储session，并自定义sesssion扩域的config配置，redis缓存session，让每个域名都来使用session。这个项目用不到单点登录，因为只有一个域名，其余都是其子域名。</p><h1 id="购物车（redis-hash存储）"><a href="#购物车（redis-hash存储）" class="headerlink" title="购物车（redis hash存储）"></a>购物车（redis hash存储）</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>购物车缓存使用hash存储，key是固定封装前缀 + 用户id，从session取用户id，value是商品id和商品信息的kv组合，商品信息是远程商品服务调用查询的。</p><h2 id="分析概述"><a href="#分析概述" class="headerlink" title="分析概述"></a>分析概述</h2><p>购物车首先分两种情况，登录用户和游客。</p><ul><li>登录用户：选择redis，由于购物车需要多读写不应使用mysql造成压力，可使用nosql频繁读写。</li><li>游客：可以存储到本地的cookie或localstorage，但这些数据我们服务器后端是没有数据的，就无法对用户的喜好进行分析进而推送数据，综合大数据时代的现状，游客数据也会存储到redis。</li></ul><p>当然大数据是使用redis，减轻mysql的压力，小数据量使用mysql也可以。但是基于现在的商城业务，离线购物车这个应该舍弃，因为连账号都没有的用户，更容易利用这一点存储垃圾数据。</p><p>redis存储使用hash结构。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>redis存储购物车，先查session拿id，添加购物车时，若已经拥有则直接修改，没有则新增。</p><p>使用ThreadLocal，让service层可以使用session信息，配置到自定义拦截器中，然后将自定义拦截器注入。</p><p>添加购物车数据采用异步任务，提高效率。</p><p>关于价格，我们封装类就重写了get、set方法，在get、set时会计算值。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>把ThreadLocal配置到拦截器中，session存在则存储到threadlocal中，保证当前线程的session共享，后续订单服务也要使用这个。</p><h1 id="订单服务"><a href="#订单服务" class="headerlink" title="订单服务"></a>订单服务</h1><h2 id="Service层获取Session"><a href="#Service层获取Session" class="headerlink" title="Service层获取Session"></a>Service层获取Session</h2><p>我们设置mvc拦截器，除了拦截未登录用户外，还可以定义一个ThreadLocal变量，该变量在同一个线程中不会改变，我们可以在拦截器中，通过request获取session，然后将session的值存储到ThreadLocal中，在Service层就可以直接使用ThreadLocal的存储数据即可，解决了service层获取session的问题。</p><p>或者注入HttpSession，在Service获取session信息，但拦截器本来就要获取session，可以直接在拦截器里获取。这也为了实战ThreadLocal。</p><h2 id="远程调用与session冲突"><a href="#远程调用与session冲突" class="headerlink" title="远程调用与session冲突"></a>远程调用与session冲突</h2><p>场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们确认订单信息，远程调用服务，首先使用用户服务获取用户地址，我们这个远程服务传入了该线程中的session相关数据，成功调用。</span><br><span class="line">然后我们要获取所有购物车的内容，调用购物车远程服务，但是购物车这个远程服务无需参数，当时写功能时，就是让它通过当前拦截器ThreadLocal拿Session数据进行处理的。结果这里远程调用出现的了问题，ThreadLocal拿不到数据。</span><br></pre></td></tr></table></figure><p>原因是<strong>feign远程调用会丢失请求头信息</strong>，它会创建一个新请求去访问远端服务，但原请求的请求头信息就没有了。这时远程购物车服务会判断我们没有登录，所以拿不到session，ThreadLocal肯定拿不到值。</p><p><strong>解决办法：添加一个feign调用的请求拦截器，将原请求Cookie信息存储到新的远程调用请求。配置RequestInterceptor这个拦截器。</strong></p><p>因为feign处理远程服务使用的是一个初始化的拦截器，我们对这个拦截器进行配置，可将原请求的cookie封装到新请求。防止Cookie信息丢失。</p><h2 id="异步任务与feign调用冲突"><a href="#异步任务与feign调用冲突" class="headerlink" title="异步任务与feign调用冲突"></a>异步任务与feign调用冲突</h2><p>ThreadLocal只能同一个线程中变量共享。</p><p>我们使用CompletableFuture异步任务加快服务操作的效率，但信息不能共享，我们可以在主线程获取上下文信息，然后在子线程执行操作时先将上下文信息保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestContextHolder.setRequestAttributes(requestAttributes);</span><br></pre></td></tr></table></figure><h2 id="接口幂等性问题"><a href="#接口幂等性问题" class="headerlink" title="接口幂等性问题"></a>接口幂等性问题</h2><p>对于提交订单这个操作，用户市不能对一个订单进行多次提交操作的，也就是幂等性问题。</p><p>幂等性即多次请求结果一致，多次接口请求只提交一次订单。一些场景如下：</p><ul><li>用户多次操作</li><li>页面回退后返回再次提交</li><li>微服务间的调用，如库存克扣问题。</li></ul><p>解决方法有：</p><ul><li>数据库设计唯一，标记唯一标识，如数据库唯一索引</li><li>携带token，令牌机制，其令牌操作要保证原子性，redis存储token可使用lua进行辅助</li><li>悲观锁、乐观锁</li><li>分布式锁</li><li>携带全局的唯一id</li></ul><h2 id="Token令牌防重"><a href="#Token令牌防重" class="headerlink" title="Token令牌防重"></a>Token令牌防重</h2><p>redis存储令牌，使用string结构，k是用户id，v是uuid生成的token，并设置30min过期时间。后续提交订单要通过token进行防重操作。</p><p>在购物车确认并生成订单，封装订单信息时，会生成一个防重令牌并缓存到redis（token是string结构，反复确认订单会把上次的token覆盖），然后controller会将封装信息设置到model中并跳转到订单提交页，提交订单去结算时，会使用lua脚本比对缓存与订单信息的token，比对通过就删除token，并创建订单、锁库存，然后通过mq进行解锁判定处理。订单创建完后将购物车session信息删除。</p><p>使用lua脚本是为了保证令牌的获取、比较、删除三个操作的原子性，防止多次请求同时完成操作，导致订单重复创建。</p><h2 id="提交订单"><a href="#提交订单" class="headerlink" title="提交订单"></a>提交订单</h2><p>直接去购物车获取信息，而不是提交页面，因为用户可能提前打开提交页面，然后再去购物车操作数据，所以直接去购物车拿数据即可。</p><p>提交订单后，可以分成以下操作。</p><ul><li><p>下单</p></li><li><p>创建订单</p></li><li><p>验证令牌并删除</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] </span><br><span class="line">    <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>使用lua脚本保证令牌验证与删除操作的原子性。</p><p>令牌即用即删，防止其他订单使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String orderToken = vo.getOrderToken();</span><br><span class="line">Long result = stringRedisTemplate.execute(</span><br><span class="line">        <span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;(script, Long.class),</span><br><span class="line">        Arrays.asList(OrderConstant.USER_ORDER_TOKEN_PREFIX + memberResponseVo.getId()),</span><br><span class="line">        orderToken</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里script即上述脚本，我们在购物车确认订单界面，会在redis存储token，kv示例上面说过，然后在提交订单到支付界面进行token二次确认。获取当前订单id，从redis取token并与当前订单自身携带的token进行对比，二者相同说明是同一个订单未被消费，然后去付款。校验后马上删除redis的token，确保订单不会被重复创建。</p></li><li><p>验证价格</p><p>将页面价格与购物车价格计算后校验。</p></li><li><p>锁库存</p><p>先锁在卖，订单远程调用库存服务的方法，使用事务。</p><p>由于存在远程服务调用，对于锁库存涉及到分布式事务。</p></li></ul><p><strong>首先整个订单提交服务是一个本地事务，有多次校验，令牌校验、价格校验（订单总额与购物车总额对比，防止用户在订单页去修改购物车）、库存校验，一次校验失败就会返回对应报错信息，并执行回滚操作；而其远程调用库存涉及分布式事务，采用MQ实现最终一致性来解决</strong></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>由于我们服务会远程调用服务，如a、b两次远程调用，a成功，b失败，但b失败只会导致b服务与当前服务回滚，a服务因为远程调用并通过，后续回滚它却不会接收到信息。</p><p>在分布式项目中，我们可能服务嵌套调用，以往的本地事务就不在适用，所以我们需要使用分布式事务。</p><p>库存回滚使用分布式事务。CAP性质保证AP，即可用性，一致性不用特别强制。</p><p>可以使用微服务组件seata解决分布式事务。</p><h2 id="seata"><a href="#seata" class="headerlink" title="seata"></a>seata</h2><p>首先数据库中每个微服务需要创建undo_log回滚日志记录表，这是官方规定的。然后启动seata服务器。</p><p>在需要的类上添加<code>@GlobalTransactional</code>开启全局事务。</p><p>而对于需要使用分布式事务的微服务，需要由seata代理其数据源。</p><p>分布式事务主入口标明全局事务，其他的远端调用仍使用本地事务注解即可。</p><h2 id="消息队列最终一致性"><a href="#消息队列最终一致性" class="headerlink" title="消息队列最终一致性"></a>消息队列最终一致性</h2><p>定时任务，订单超时关闭订单，而下单的时候会锁定库存，库存设置定时任务，若一定时间后订单不存在，则相应的库存自行解锁。但定时任务资源开销大，不建议使用。</p><p>延迟队列，订单创建后进行锁库存，锁库存存入延迟队列，过期后交予解锁库存服务，此时解库存再去看订单是否存在进而判断是否解库存。采用主题模式，消息进来按照路由键走死信，过期后设置路由键走解库存队列。</p><p>延迟队列相比于定时任务，优点在于其处理一定在当前订单过期时间之后，定时任务则不稳定。</p><h2 id="库存解锁！！！"><a href="#库存解锁！！！" class="headerlink" title="库存解锁！！！"></a>库存解锁！！！</h2><p>柔性事务，最终一致性：<a href="https://www.jianshu.com/p/d70df89665b9">https://www.jianshu.com/p/d70df89665b9</a></p><p>mq使用时选择手动应答ack。只有死信队列转发后的订单表信息，其订单不存在或订单取消支付，此时将会解库存。手动ack模式，我们可以确保业务执行完毕在应答队列。</p><p>由死信转发到解库存的消息，若当前机器服务出现异常或宕机，则将消息重新放入队列，等待下一次的消费。直到消息全部消费。</p><p>取消订单后主动发消息给解库存MQ。</p><p>一开始设置订单支付等待1min，库存解锁等待2min，解库存mq收到消息时，订单状态肯定从新建变为了支付或取消，这是正常状态，但如果我们遇到网络问题，导致订单支付在解库存后才响应，解库存判断状态是新建则不会有动作，所以为了保底，我们取消订单时要去通知解库存mq，以防上述情况发生，当然支付成功就不用通知。</p><p>消息的手动接收和业务处理都是写在try-catch中，捕获异常就拒收消息并将其重入队。</p><h2 id="消息确认、重复"><a href="#消息确认、重复" class="headerlink" title="消息确认、重复"></a>消息确认、重复</h2><p>队列和交换机一定是开启持久化，保存到磁盘上。</p><p>保证手动ack，业务执行无误再进行消息确认，关闭自动ack。</p><p>由于服务器宕机等因素，业务完成后没有及时应答，导致消息重回队列进行消费，我们可以再业务相关处理中设置状态，比方说上述订单解库存，只处理被取消的订单和不存在的订单，且解库存时只处理被锁定的库存，已解锁过的当然不用二次处理了。保证业务的幂等性。</p><h2 id="支付宝沙箱模拟支付"><a href="#支付宝沙箱模拟支付" class="headerlink" title="支付宝沙箱模拟支付"></a>支付宝沙箱模拟支付</h2><p>调用官方sdk，引用方法即可支付选择支付宝，成功后跳转回我们的结算页面。还可以配置支付宝提供的自动收单，因为订单会在规定时间内失效，如果等到订单失效后再支付，我们库存都回滚了，但支付成功订单仍变为了已付款，这样肯定是逻辑问题，所以我们配置自动收单，保证付款窗口的有效期不超过订单过期区间。保证订单过期后不能付款。</p><h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><ul><li><p>定时任务，库存预热</p><p>秒杀商品上架使用定时任务，执行异步编排。采用cron表达式 + 注解完成定时任务。</p><p><code>@EnableScheduling</code>：定时调度，<code>@EnableAsync</code>：异步任务</p><p>或者直接执行异步任务。</p><p>定时上架，选择流量较小的深夜错峰上架。提前3天扫描秒杀活动场次，提前将数据缓存到redis</p></li><li><p>时间处理</p><p>使用java8新增的时间处理类，LocalTime，LocalDate，获取当天准确日期、时间，完成秒杀获取3天商品的时间需求。</p></li><li><p>秒杀加密</p><p>携带随机码，获取秒杀商品数据时，会进行时间校验，只有到时了才会给当前商品添加随机码，也就是秒杀生效，其余时间还是正常价。</p></li><li><p>动静分离</p><p>只让后端承受动态请求，降低静态请求带来的压力。</p></li><li><p><strong>信号量限流</strong></p><p>信号量即redis库存，靠这个保证库存</p><p>设置Redisson信号量</p><p><a href="https://blog.csdn.net/weixin_43931625/article/details/103232670">https://blog.csdn.net/weixin_43931625/article/details/103232670</a></p></li><li><p>流量错峰</p><p>验证码过滤，不是即点即用。加入购物车</p></li><li><p>限流、熔断、降级 sentinel</p><p>页面降级，点击频率过高就挂掉</p></li><li><p>队列消峰</p><p>信号量再redis，扣减是原子性操作</p></li></ul><h2 id="库存"><a href="#库存" class="headerlink" title="库存"></a>库存</h2><p>库存在上架前提前扣减了，活动结束后再根据失效订单进行解锁，上架库存就以信号量保存到redis中，通过redisson分布式锁完成原子性扣减，保证不会超卖，信号量用完即止。</p><h2 id="秒杀设计"><a href="#秒杀设计" class="headerlink" title="秒杀设计"></a>秒杀设计</h2><p>设置秒杀限制数，限制商品的抢购件数。</p><p>上架时会设置商品随机码，在主页<strong>进入商品页</strong>时，会先判断当前商品是否秒杀，如果秒杀，在判断当前是否处于秒杀时间段（封装了起始时间），<strong>不存在时间段就将随机码至null</strong>，然后传到前端，商品的封装包括了秒杀信息。在<strong>秒杀商品页面进行秒杀click时</strong>，会传入当前商品的秒杀信息，包括秒杀商品id、秒杀商品的随机码、秒杀数量，然后进行请求，秒杀时进行校验，通过秒杀id获取缓存中的对应商品，校验页面随机码和缓存是否相等，若当前商品不是在秒杀时间内进入则随机码为null，无法通过校验。</p><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>熔断：多服务相互调用，某个服务的调用失败比例超过设定值，或调用失败频率超过设定值。则将异常服务停止，但后续会根据策略对该服务测试，若该服务调用比例恢复到正常值，则重新启用服务。</p><p>降级：对某个方法、接口采用兜底方法，即某个方法、接口请求频率达到一定次数就返回兜底方法进行处理，防止大量请求进行访问。</p><h1 id="面试mark"><a href="#面试mark" class="headerlink" title="面试mark"></a>面试mark</h1><ul><li><p>如何保证缓存与数据库的双写一致性？</p><p>双写（mysql修改后修改redis）</p><p>失效（mysql修改后删除redis缓存）</p><p><strong>对于购物车缓存情况如何处理</strong></p></li><li><p>Java设计缓存（Map本地缓存）</p><p>和单例模式的双重锁定类似。</p><p>对于分布式微服务，不能使用，因为本地缓存时相互隔离的，服务每次负载均衡到其他服务器还要重新加载缓存。且多个服务器间还有数据一致性的问题。</p><p><a href="https://blog.csdn.net/u010452388/article/details/82725299">https://blog.csdn.net/u010452388/article/details/82725299</a></p></li><li><p>点赞功能设计</p><p><a href="https://www.cnblogs.com/liuyupen/p/14015407.html">https://www.cnblogs.com/liuyupen/p/14015407.html</a></p><p><a href="https://www.zhangshengrong.com/p/281oD6Yawz/">https://www.zhangshengrong.com/p/281oD6Yawz/</a></p></li><li><p>账号重复登录问题</p><p>建立在线活跃用户表</p><p><a href="https://blog.csdn.net/weixin_38295272/article/details/117964982">https://blog.csdn.net/weixin_38295272/article/details/117964982</a></p><p>登录存储客户端ip，若多次登录ip不同，说明是不同ip登录，提醒上次登录用户。可以kv存redis，k是用户id，v是客户端ip。还要设置过期时间，如果正常下线，会发请求删除，非正常下线自动过期。一直在线会自动续期。也就是活跃操作续期。</p><p>文章中用token，这个可能会受浏览器影响，我们可使用用户的ip。</p></li><li><p>幂等性</p></li><li><p>rabbitmq怎么保证消息可靠：开启队列、交换机的持久化，开启手动ack模式。</p><p>发生时消息丢失、发送后消息丢失：保证双端确认，消费者手动ack，出现异常拒收消息将消息重入队。</p><p>消息重复：业务逻辑避免，如我们解库存业务，消息来了，要解库存，会判断商品库存，只处理锁定状态的商品。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚拟机环境配置&quot;&gt;&lt;a href=&quot;#虚拟机环境配置&quot; class=&quot;headerlink&quot; title=&quot;虚拟机环境配置&quot;&gt;&lt;/a&gt;虚拟机环境配置&lt;/h1&gt;&lt;p&gt;这次使用Virtual Box + Vagrant完成虚拟机安装，比传统VMware配置镜像更方便，</summary>
      
    
    
    
    <category term="后端" scheme="http://aidianfirst.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式八股</title>
    <link href="http://aidianfirst.com/2021/10/07/%E5%85%AB%E8%82%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E8%82%A1/"/>
    <id>http://aidianfirst.com/2021/10/07/%E5%85%AB%E8%82%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E8%82%A1/</id>
    <published>2021-10-07T11:04:07.000Z</published>
    <updated>2023-07-30T11:20:17.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><ul><li><strong>单一职责原则：</strong>一个类只负责一个功能，降低耦合性，方便迭代维护。</li><li><strong>开放封闭原则：</strong>类、方法可以进行功能扩展，但不能修改。对扩展开放，对修改封闭。</li><li><strong>依赖倒置原则：</strong>高级模块不能依赖低级模块，都应该依赖于接口。先将类进行抽象，先设计功能接口，再对接口进行功能细节的实现。</li><li><strong>接口隔离原则：</strong>不同接口定义不同的功能。</li><li><strong>里氏代换原则：</strong>子类可替换其父类。</li><li><strong>迪米特原则：</strong>每个模块间要尽可能少的相互调用，减少依赖，降低耦合性。</li></ul><p>设计模式讲解链接：</p><p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80</a></p><h1 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h1><h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazyInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getLazyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyInstance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式是指先不创建实例，当首次调用后再创建。</p><p>私有化构造方法，不能使用 new 进行实例化，使用方法判断当前实例是否已存在，不存在则创建，保证实例的单一性。</p><p><strong>线程不安全，</strong>在多线程情况下，可能首次会有多个线程一起调用 getLazyInstance方法 ，那么此时实例为空，会同时创建多个实例。</p><h2 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry hungryInstance = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getHungryInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式指无论是否要使用实例，先进行一次实例化，随后需要实例时直接调用方法返回即可；</p><p><strong>线程安全，</strong>因为初始化类时已经进行了实例化。但若长时间不使用该实例会造成资源浪费。</p><h2 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyConcurrent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyConcurrent lazyInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyConcurrent</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyConcurrent <span class="title">getLazyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyInstance = <span class="keyword">new</span> LazyConcurrent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例化执行方法上加锁保证线程安全。</p><p><strong>线程安全，</strong>但效率低，多线程争夺锁会造成线程阻塞。</p><h2 id="双重检查锁实现（线程安全）"><a href="#双重检查锁实现（线程安全）" class="headerlink" title="双重检查锁实现（线程安全）"></a>双重检查锁实现（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheck doubleCheckInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheck <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(doubleCheckInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheck.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(doubleCheckInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    doubleCheckInstance = <span class="keyword">new</span> DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doubleCheckInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁相当于是线程安全懒汉式的优化版。</p><p><strong>首先我们不是在执行方法上加锁，而是在方法内部加锁。</strong>先进行一次实例判断，如果为空则获得锁然后再进行一次判断，因为第一次判断可能有多个线程同时通过，而获取锁后需要第二次判断再实例对象，以防同时通过第一次判断线程进行多次实例化。</p><p><strong>实例变量使用volatile修饰。</strong>我们正常代码实例化执行步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doubleCheckInstance &#x3D; new DoubleCheck();</span><br><span class="line">1、为对象分配内存空间</span><br><span class="line">2、初始化对象</span><br><span class="line">3、将对象指向分配好的内存空间</span><br></pre></td></tr></table></figure><p>由于JVM的指令重排机制，指令执行顺序可能会由原来的123变为132。而在多线程的影响下，会导致线程得到一个尚未初始化的实例。为了解决该问题可以在声明实例变量时加上 volatile，禁止JVM进行指令重排，保证多线程的安全。</p><h2 id="静态内部类实现（线程安全）"><a href="#静态内部类实现（线程安全）" class="headerlink" title="静态内部类实现（线程安全）"></a>静态内部类实现（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single instance = <span class="keyword">new</span> Single();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleInner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部类Single加载时，其静态内部类SingleInner并未加载，当调用实例获取方法走到返回值时，才会去加载静态内部类，并进行实例化。</p><p>使用静态内部类可以延迟实例化，节省资源，并保证线程安全。</p><h2 id="枚举实现（线程安全）"><a href="#枚举实现（线程安全）" class="headerlink" title="枚举实现（线程安全）"></a>枚举实现（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Unique</span> </span>&#123;</span><br><span class="line">    INTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举默认即线程安全 + 单例，还可防范一系列反射破解单例的操作。</p><h1 id="工厂模式（简单工厂、工厂、抽象工厂）"><a href="#工厂模式（简单工厂、工厂、抽象工厂）" class="headerlink" title="工厂模式（简单工厂、工厂、抽象工厂）"></a>工厂模式（简单工厂、工厂、抽象工厂）</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>一个产品接口，有多种具体实现，我们创建一个工厂类，声明一个实例获取的方法，根据参数和if - else判断生成哪一个具体的产品实例。然后可以使用该实例。</p><p>工厂类使用if - else判断，扩展性差。</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/1.jpg" alt="1.jpg"></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>将工厂抽象化，通过工厂的具体子类创建具体产品实例，工厂抽象类中将实例产品的方法抽象化，交由具体子类实现，而其他的功能方法则可以直接写。</p><p>这样我们有新产品加入时，只需要创建对应的子工厂继承抽象工厂，然后使用子工厂进行操作即可，不用修改其他类。</p><p>但如果我们产品种类很多时，不可能为每一个产品都创建一个子工厂，这会大大增加代码的复杂度。</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/2.jpg" alt="2.jpg"></p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>为了缩减工厂子类的数量，我们不必为每一个产品分配一个工厂类，可将产品分组，比如有产品键盘和鼠标，然后我们将工厂分类，工厂接口声明可创建很多产品（键盘、鼠标等），然后创建具体品牌工厂实现接口，声明各品牌的键盘鼠标。比如戴尔工厂有戴尔的键盘和鼠标，联想工厂有联想的键盘和鼠标。此时需要哪个品牌的哪种产品直接去对应品牌工厂获取即可。</p><p>但是抽象工厂每次新增一个产品需要进行很多扩展，对产品和工厂都要新增。</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/3.jpg" alt="3.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>简单工厂：单一工厂类，单一产品接口，创建工厂根据方法的入参判断需要创建的具体产品实例。</li><li>工厂：多个工厂类，单一产品接口，通过子工厂实现多态，完成不同产品实例的创建，避免入参判断。</li><li>抽象工厂：多个工厂类，多个产品抽象类，产品会根据子类分组，同一个产品工厂实现同种组件，减少了工厂子类的数量。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式七大原则&quot;&gt;&lt;a href=&quot;#设计模式七大原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式七大原则&quot;&gt;&lt;/a&gt;设计模式七大原则&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单一职责原则：&lt;/strong&gt;一个类只负责一个功能，降低耦合性</summary>
      
    
    
    
    <category term="八股" scheme="http://aidianfirst.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud简单学习</title>
    <link href="http://aidianfirst.com/2021/10/06/%E5%90%8E%E7%AB%AF/Spring%20Cloud%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aidianfirst.com/2021/10/06/%E5%90%8E%E7%AB%AF/Spring%20Cloud%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-10-06T07:58:39.000Z</published>
    <updated>2023-07-30T11:20:17.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud简述"><a href="#Spring-Cloud简述" class="headerlink" title="Spring Cloud简述"></a>Spring Cloud简述</h1><p>Spring Cloud微服务是由多功能模块组成的，每个模块实现耦合性降低。</p><p>注意微服务是多个模块进行组合，我们对版本的控制必须严谨。</p><p>通过url：</p><p><a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a> 获取json数据，查看版本对应关系。</p><p>或 <a href="https://spring.io/projects/spring-cloud#learn">https://spring.io/projects/spring-cloud#learn</a> 自行查看版本对应关系。</p><p>Spring Cloud模块分布如下：</p><ul><li>注册中心：Nacos、Eureka、Zookeeper、Consul</li><li>服务调用：LoadBalancer、Ribbon、OpenFeign（Feign）</li><li>服务熔断：Sentinel、Resilience4j、Hystrix</li><li>服务网关：Gateway、Zuul</li><li>服务配置：Nacos、Config</li><li>服务总线：Nacos、Bus</li></ul><p><strong>Spring Cloud Alibaba官网：</strong><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p><p><strong>Spring Cloud Alibaba组件版本关系：</strong><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p><h1 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h1><p>先开启一个干净的maven父工程，随后会展开模块，pom文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  版本管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="模块配置-依赖-yml"><a href="#模块配置-依赖-yml" class="headerlink" title="模块配置 + 依赖 + yml"></a>模块配置 + 依赖 + yml</h2><p>使用父子工程配置各个模块。</p><p>子模块依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql-connector-java--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml配置参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span>     <span class="comment"># mysql驱动</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spring_cloud?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">111111</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.tang.springcloud.entity</span></span><br></pre></td></tr></table></figure><h2 id="微服务支付服务端-entity-dao-service-controller"><a href="#微服务支付服务端-entity-dao-service-controller" class="headerlink" title="微服务支付服务端 entity-dao-service-controller"></a>微服务支付服务端 entity-dao-service-controller</h2><p>我们按照前后端分离的规范，每次执行操作后，向前端返回状态码信息，所以还要写一个状态码的封装类</p><ul><li><p>CommonResult</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResult</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonResult</span><span class="params">(Integer code, String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(code, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PaymentMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span> <span class="params">(Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PaymentMapper.xml</p><p>为了规范一般都会自行封装一个resultmap作为返回类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tang.springcloud.dao.PaymentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- useGeneratedKeys 添加语句执行后返回自增主键</span></span><br><span class="line"><span class="comment">         keyProperty 是配合自增主键使用的，将值返回给实体类的对应属性，然后get获取 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;create&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Payment&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into payment(serial) values(#&#123;serial&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.tang.springcloud.entity.Payment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">property</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getPaymentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from payment where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>PaymentServiceImpl</p><p>接口省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceImpl</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentMapper paymentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentMapper.create(payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentMapper.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PaymentController</p><p>对应url的http方法：post增、delete删、put改、get查</p><p>注意对象参数要使用@RequestBody，接收客户端发送的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">&quot;添加的结果&quot;</span> + result);</span><br><span class="line">        <span class="keyword">if</span>(result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;插入成功&quot;</span>, result);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">404</span>, <span class="string">&quot;插入失败&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        Payment payment = paymentService.getPaymentById(id);</span><br><span class="line">        log.info(<span class="string">&quot;查询结果&quot;</span> + payment);</span><br><span class="line">        <span class="keyword">if</span>(payment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;查询成功&quot;</span>, payment);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">404</span>, <span class="string">&quot;查询失败，失败id是&quot;</span> + id, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试功能"><a href="#测试功能" class="headerlink" title="测试功能"></a>测试功能</h2><p>由于浏览器限制，我们可以使用Postman测试post、get等请求</p><p>localhost:8001/payment/get/1</p><p>localhost:8001/payment/create?serial=wewewew</p><h2 id="Devtools开启热部署"><a href="#Devtools开启热部署" class="headerlink" title="Devtools开启热部署"></a>Devtools开启热部署</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 热部署依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父类工程启用插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在setting–Build–Compiler下勾选，以下四个开头的条件：</p><p>Auto···、Display···、Build···、Compile···。</p></li><li><p>组合键：ctrl + alt + shift + 左斜杠，选中1、Registry···，勾选：</p><p>compiler.automake.allow.when.app.running</p><p>actionSystem.assertFocusAccessFromEdt</p></li></ul><h2 id="微服务客户端-entity-controller"><a href="#微服务客户端-entity-controller" class="headerlink" title="微服务客户端 entity-controller"></a>微服务客户端 entity-controller</h2><p>客户肯定是不能操作业务的，所以我们肯定没有service进行调用，<strong>使用RestTemplate</strong>。</p><p>RestTemplate是HTTP请求工具，提供了常见的请求方案模板。</p><p>这里客户端使用http默认端口80，不用主动指明端口号，因为客户是不用关心端口的，只用输入对应的url即可。</p><ul><li><p>entity实体类和服务端一致</p></li><li><p>AppliCationContextConfig配置RestTemplate</p><p>将组件进行手动注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OrderController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">&quot;http://localhost:8001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayemntById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>客户端：<a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></p><p>无需端口号，对服务器进行访问。</p><h2 id="工程重构"><a href="#工程重构" class="headerlink" title="工程重构"></a>工程重构</h2><p>我们发现客户端与服务端实体类重复，希望进行复用操作。单独分一个模块方实体类、工具类等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 综合工具包，时间、钱等转换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把实体类和工具类都写到这个模块，在maven工具上进行clean-install操作打包，接下来我们去之前的模块把实体类删除，在pom中引用改模块的依赖即可导入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义api包通过maven生成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>服务的中转站，发现并维护服务，让后提供服务给客户，比如长时间未使用的服务则自行删除，不再提供给客户。</p><p>Eureka分为服务端与客户端，我们需要在注册中心的启动器入口上进行服务端配置，其余组件进行客户端配置。</p><ul><li><p>Eureka Server</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Eureka Client</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基础配置（服务端）"><a href="#基础配置（服务端）" class="headerlink" title="基础配置（服务端）"></a>基础配置（服务端）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka-server--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义api包通过maven生成 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--boot web actuator--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span>     <span class="comment"># eureka服务端实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示自己不会注册到注册中心</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>   </span><br><span class="line">    <span class="comment"># 自身就是注册中心，不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>         </span><br><span class="line">    <span class="comment"># 与Eureka进行查询服务和注册服务需要用到的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defalutZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基础配置（客户端）"><a href="#基础配置（客户端）" class="headerlink" title="基础配置（客户端）"></a>基础配置（客户端）</h3><p>pom导入Eureka-client的依赖。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 开启Eureka对1组件进行检索与注册</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>在启动入口上添加注解：@EnableEurekaServer。</p><p>然后在7001端口的eureka可以看到注册进来的8001组件。</p><h3 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h3><p>Eureka包括多台服务器，每台服务器都会注册除自己以外的所有服务器，保证能获取其他服务器的信息。以便切换。</p><p>修改host文件，加入自己eureka的多机ip配置</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       eureka7001.com</span><br><span class="line">127.0.0.1       eureka7002.com</span><br></pre></td></tr></table></figure><p>服务器修改yml，每个服务器配置其他所有服务器，逗号分隔。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span>     <span class="comment"># eureka服务端实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示自己不会注册到注册中心</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 自身就是注册中心，不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 与Eureka进行查询服务和注册服务需要用到的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><p>客户端修改yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 开启Eureka对1组件进行检索与注册</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><p>然后我们发现集群的eureka都注册了实例，且集群之间服务器都相互加载。</p><h3 id="支付服务端集群"><a href="#支付服务端集群" class="headerlink" title="支付服务端集群"></a>支付服务端集群</h3><p>拷贝一个8002支付工程，和8001一模一样，注意改端口号。在Controller中添加以下内容，并在后续操作中返回端口号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;查询成功,serverPort:&quot;</span> + serverPort, payment);</span><br></pre></td></tr></table></figure><p><strong>此时客户端不能写死端口号，转变成微服务名，且要开启负载均衡，因为集群服务名相同，没有配置负载均衡则无法识别。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url改变为服务名称，不是写死的端口号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">&quot;http://cloud-payment-service&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端config中，给restTemplate组件添加注解</span></span><br><span class="line"><span class="comment">// @LoadBalanced开启负载均衡</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好后发现集群服务器会交替使用，负载均衡。</p><h3 id="完善处理"><a href="#完善处理" class="headerlink" title="完善处理"></a>完善处理</h3><p>在eureka界面发现各个服务的默认名是带有主机的，很冗杂，可以自定义名称，并且可以开启服务的正确ip跳转。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>配置支付服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">discovery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 发现服务</span></span><br><span class="line">        List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">for</span>(String s : services)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;服务：&quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发现服务下是实例</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;cloud-payment-service&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(ServiceInstance instance : instances)&#123;</span><br><span class="line">            log.info(instance.getServiceId() + <span class="string">&quot;\t&quot;</span> + instance.getHost() + <span class="string">&quot;\t&quot;</span> + instance.getPort() + <span class="string">&quot;\t&quot;</span> + instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>@EnableDiscoveryClient</strong>需要加到服务启动类上开启服务发现</p><h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p>当一个微服务不能使用时，eureka不会马上进行清理，而是对该服务信息进行保存。</p><p><strong>在分布式架构CAP理论中属于AP分支。</strong></p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>apache官方下载zookeeper，在linux完成解压</p><p><a href="https://dlcdn.apache.org/zookeeper/zookeeper-3.6.3/apache-zookeeper-3.6.3-bin.tar.gz">https://dlcdn.apache.org/zookeeper/zookeeper-3.6.3/apache-zookeeper-3.6.3-bin.tar.gz</a></p><p>解压后进入bin目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br><span class="line">./zkCli.sh</span><br></pre></td></tr></table></figure><h3 id="支付业务注册到zookeeper"><a href="#支付业务注册到zookeeper" class="headerlink" title="支付业务注册到zookeeper"></a>支付业务注册到zookeeper</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.137</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8004</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8004.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成基础配置，启动服务，在linux查看zookeeper注册情况是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /</span><br><span class="line">[services, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] ls /services</span><br><span class="line">[cloud-provider-payment]</span><br></pre></td></tr></table></figure><p>业务测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentzk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with zookeeper:&quot;</span> + serverPort + <span class="string">&quot;\t&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走<a href="http://localhost:8004/payment/zk%EF%BC%8C%E5%8F%91%E7%8E%B0uuid%E8%BF%94%E5%9B%9E%E6%88%90%E5%8A%9F">http://localhost:8004/payment/zk，发现uuid返回成功</a></p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>可对比Eureka自我保护，zookeeper是临时节点，当服务宕机后，过了一个心跳时间不会保存服务。重启服务后则是新开的一个服务。</p><h3 id="客户端调用服务"><a href="#客户端调用服务" class="headerlink" title="客户端调用服务"></a>客户端调用服务</h3><p>pom服务端一致</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.138</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><p>controller调服务，template需要先注册，和之前一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderZKController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL = <span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(INVOKE_URL + <span class="string">&quot;/payment/zk&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后发现客户端可以使用，且linux上的zookeeper也能发现两个服务。</p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>官方下载windows版本：<a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a></p><p>解压后进入文件目录命令行执行<strong>consul agent -dev</strong>开启consul可视化界面</p><p><a href="http://localhost:8500/ui/dc1/services">http://localhost:8500/ui/dc1/services</a> 访问可视化界面</p><h3 id="服务端注册"><a href="#服务端注册" class="headerlink" title="服务端注册"></a>服务端注册</h3><p>相关配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8006</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p>业务和zookeeper一样，进行简单端口返回测试，查看consul是否注册成功。主启动类使用@EnableDiscoveryClient。</p><h3 id="客户端注册调用服务"><a href="#客户端注册调用服务" class="headerlink" title="客户端注册调用服务"></a>客户端注册调用服务</h3><p>pom同服务端。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-consumer-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p>config注册template组件，然后controller使用网络连接调用服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderZKController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL = <span class="string">&quot;http://consul-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(INVOKE_URL + <span class="string">&quot;/payment/consul&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后url测试，服务调用成功。</p><h2 id="注册中心的选择"><a href="#注册中心的选择" class="headerlink" title="注册中心的选择"></a>注册中心的选择</h2><p>注册中心作用都一样，但每一个在分布式系统中的定位不同，也就是CAP实现不同。</p><ul><li>C：Consistency（强一致性），所有节点在集群中具有相同数据</li><li>A：Avaliability（可用性），保证请求无论成功失败都有响应，但可能接收到的数据节点是过时或错的。</li><li>P：Partition（分区容错性），对于分布式分区容错是必备的，也就是集群中部分机器宕机，不会影响整个系统的运作。</li></ul><p>一般来说分布式系统必须实现P，但全部特性又不能同时满足，所以一般是CP、AP两种方式。</p><ul><li>CA：单点集群，满足一致性，一般不利于扩展。、</li><li><strong>CP(Zookeeper、Consul)：</strong>满足一致性、分区容错，但性能不高。</li><li><strong>AP(Eureka)：</strong>满足可用性、分区容错，对一致性要求低。</li></ul><h1 id="服务调用（负载均衡）"><a href="#服务调用（负载均衡）" class="headerlink" title="服务调用（负载均衡）"></a>服务调用（负载均衡）</h1><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>我们在eureka集群环境下测试该技术</p><p>Ribbon主要实现负载均衡（Load Balance）</p><ul><li>集中式LB（Nginx）：在服务消费者与提供方之间独立的负载均衡设施，如Nginx反向代理，由该设备将请求通过策略转发给服务的提供方。</li><li>进程内LB（Ribbon）：将负载均衡逻辑集成到消费者，由消费者从注册中心选取合适的服务器进行调用。</li></ul><p>对应依赖（不适用）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>我们在注册中心的客户端就使用过@LoadBalance + RestTemplate完成服务调用及负载均衡。这里要说说RestTemplate。</p><p>RestTemplate对应get、post都有两种请求方法，这里以get举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回json</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayemntById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回ResponseEntity对象，包含响应头、响应体、状态码等，可获取更多信息</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayemntById2</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">    ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + <span class="string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象可根据状态码进行判断</span></span><br><span class="line">    <span class="keyword">if</span>(entity.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">        <span class="keyword">return</span> entity.getBody();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">404</span>, <span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getForObject：获取响应数据，类似一个json</li><li>getForEntity：获取整个响应，信息更多。</li></ul><p>分情况使用，post和get一样，只是换了前缀。</p><h3 id="负载均衡算法替换"><a href="#负载均衡算法替换" class="headerlink" title="负载均衡算法替换"></a>负载均衡算法替换</h3><p>Ribbon依赖中有一个接口IRule，一般实现该接口的类就对应了一种算法，抽象类除外。有轮询、随机等。</p><p>我们不想使用默认的轮询算法。可以自行构造一个新算法规则，但官方规定这个规则不应该放在@ComponentScan能扫描的包中，这样做不到特殊化，也就是说我们要跳出主启动类所在包，新建一个规则包来实现规则。</p><p><strong>注意坑，现在版本eureka-client没有集成ribbon，所以不能直接使用IRule自定义策略，需要去导入Ribbon包，但我执行导入Ribbon运行都会冲突报错，没找到原因，只能说老技术没人维护是这样的，赶紧往后学Nacos配合Feign，负载均衡策略都可以在yml改，不用自定义类过于麻烦。</strong></p><p>解决办法：<a href="https://blog.csdn.net/Curtain_show01/article/details/116838815">https://blog.csdn.net/Curtain_show01/article/details/116838815</a></p><p>或 <a href="https://www.cnblogs.com/minejava/p/14851495.html">https://www.cnblogs.com/minejava/p/14851495.html</a></p><p>我们使用Spring Cloud LoadBalancer顶替Ribbon，LoadBalancer被Eureka所集成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义负载均衡算法配置，不用@Configuration注册</span></span><br><span class="line"><span class="comment">// 但测试后发现加不加@Configuration都可，应该是不用注册成组件的，这里不太清楚</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="title">randomLoadBalancer</span><span class="params">(Environment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            LoadBalancerClientFactory loadBalancerClientFactory)</span> </span>&#123;</span><br><span class="line">        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原本的RestTemplate设置类中使用注解@LoadBalancerClient修改配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@LoadBalancerClient(name = &quot;cloud-payment-service&quot;, configuration = MyLoadBalance.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再使用改客户端即可完成随机算法的负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种方法是自定义负载均衡配置加上@Configuration进行注册，然后在主启动类加上以下注解</span></span><br><span class="line"><span class="meta">@LoadBalancerClients(defaultConfiguration = MyLoadBalance.class)</span></span><br></pre></td></tr></table></figure><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>传统Ribbon + RestTemplate对http请求封装，形成模板化调用方法，而Feign在该基础上进一步封装，通过接口 + 注解进行配置，进一步简化操作。（类比Dao层配合Mapper注解）</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>基础配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><p>service对应你要调用的服务端服务，我们原本业务是使用RestTemplate + 逻辑自行实现Controller，而OpenFeign是先定义服务的接口，指明服务与业务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;cloud-payment-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller直接获取业务接口的实例，通过它调用服务端的业务，不用注入RestTemplate。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymetById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类使用@EnableFeignClients，开启OpenFeign</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试客户端链接，发现能调用业务，且开启了轮询负载均衡。</p><h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>OpenFeign默认等待服务1s，我们模拟业务等待3s，客户端调用后会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">paymentFeignTimeOut</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paymentFeignService.paymentFeignTimeOut();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>配置yml可延长超时时间。</p><p><strong>ps：不知道是什么问题，我客户端一直在等待，没有默认1s的判断？？？不管了反正只是一个小点</strong></p><h3 id="OpenFeign自带日志输出"><a href="#OpenFeign自带日志输出" class="headerlink" title="OpenFeign自带日志输出"></a>OpenFeign自带日志输出</h3><ul><li>NONE：默认不显示日志</li><li>BASIC：记录请求方法、URL、响应状态码、执行时间</li><li>HEADERS：除BASIC定义的信息外，还有请求和响应的头信息</li><li>FULL：除HEADERS定义的信息外，还有请求与响应的正文、元数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLogLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml配置需打印日志的接口的等级</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.tang.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>当微服务配置多了，一个微服务会调用多个微服务，也就是扇出（广播），而其中某一个微服务出现问题，会影响其他所有微服务，好比雪崩。简单就是说高可用被破坏。</p><p><strong>Hystrix在某一个服务出现问题时，不会导致整个服务全部失败，避免级联故障，可以提高分布式系统的弹性。</strong></p><h2 id="基础服务构建"><a href="#基础服务构建" class="headerlink" title="基础服务构建"></a>基础服务构建</h2><ul><li>服务端：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com/7001/eureka</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务模拟，一个耗时短，一个耗时长</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;paymentInfo_OK, id:&quot;</span> + id + <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;paymentInfo_TimeOut, id:&quot;</span> + id + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;耗时&quot;</span> + time + <span class="string">&quot;s&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Feign接口调服务</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller服务注入</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们现在对服务端施加压力测试，多线程执行服务，那么客户端和服务端执行操作时都会变慢，加载时间变长，此时需要相应措施。</p><h2 id="服务降级（fallback）"><a href="#服务降级（fallback）" class="headerlink" title="服务降级（fallback）"></a>服务降级（fallback）</h2><p>服务器压力剧增，可对不重要的服务进行延迟或暂停处理，以便释放服务器资源，保证核心服务正常运行。</p><p>服务端设置服务时间阈值，若超时则执行兜底方法处理，也就是进行降级操作。且以下情况都会发生服务降级：<strong>程序运行异常</strong> + <strong>超时</strong>。</p><p><strong>注意，以下配置超时时间，不配置则使用默认值1s。</strong></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主启动类开启Hystrix</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程超时，执行兜底方法，参数1兜底方法，参数2超时时间</span></span><br><span class="line"><span class="comment">// 服务出现异常也会直接进行降级操作，比如执行10/0</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandle&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="comment">// int i= 10 / 0;</span></span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(time);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;paymentInfo_TimeOut, id:&quot;</span> + id + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;耗时&quot;</span> + time + <span class="string">&quot;s&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandle</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;paymentInfo_TimeOutHandle, id:&quot;</span> + id + <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>可以发现两端对应时间配置可以不一样的，这里服务响应是3s，刚刚服务端配置5s可以响应，现在客户端只配置1s则不能响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主启动类开启Hystrix</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandle&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandle</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;paymentInfo_TimeOutHandle, id:&quot;</span> + id + <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术重构–全局fallback配置"><a href="#技术重构–全局fallback配置" class="headerlink" title="技术重构–全局fallback配置"></a>技术重构–全局fallback配置</h3><p>对于兜底方法可以进一步简化，设置一个全局兜底，没有自行配置则走整个方法，不用每次服务降级都要自行配置兜底方法。以下为改变后的客户端，使用 <strong>@DefaultProperties</strong> 全局兜底</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;paymentGlobalFallbackMethod&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;5000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局fallback</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentGlobalFallbackMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;全局异常，稍后重试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局fallback，可应对服务端宕机"><a href="#全局fallback，可应对服务端宕机" class="headerlink" title="全局fallback，可应对服务端宕机"></a>全局fallback，可应对服务端宕机</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端配置熔断器</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置全局Fallback，直接实现业务接口</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;paymentInfo_OK,NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;paymentInfo_TimeOut,NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务接口fallback属性声明实现接口的Fallback类</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;, fallback = PaymentFallbackService.class)</span></span><br></pre></td></tr></table></figure><p><strong>经过实验，使用该方法开启全局fallback，可应对服务端宕机，宕机后不会显示服务404，而是走全局fallback进行服务提醒。而且注释前面的 @HystrixCommand + @DefaultProperties，我们服务超时和运行异常也会走这个全局fallback，可以说这个实现接口的全局fallback是最佳方案，其他几种可用来配置特殊情况。</strong></p><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>可类比保险丝，当某个服务不可用或响应超时时，急时停止该服务，防止系统雪崩现象出现。<strong>而当检测到某个微服务响应正常后，恢复调用链路。</strong></p><p><strong>HystrixCommandProperties</strong>，这个抽象类包含了我们可以配置的参数信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//service，服务端配置熔断</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;), //断路器是否开启</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;), //请求次数</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;), //请求时间ms</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;) //失败率，达到就熔断</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;------负数-------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自行封装的maven依赖中引用了hutool工具包，随机生成uuid</span></span><br><span class="line">    String serialNumber = IdUtil.simpleUUID();</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务降级调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;id 不能是负数，请稍后再试，id: &quot;</span> +id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//controller</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    String result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释以下配置的参数，开启断路器，若10s内10次请求失败率达到60%，则熔断。而后续正确回升则会恢复链路。我们测试时先输入正数会成功调用返回uuid，输入负数则抛异常走兜底方法处理。但10s内多次失败后，我们再去输入整数，返回的是兜底方法，因为失败率达到60%被熔断了，而我们后续多次调用正数，失败率降低，又可以走正常方法返回uuid。</p><p>熔断后不再走正常逻辑，而是执行服务降级的兜底方法，但熔断可以自行恢复链路重新执行正常逻辑。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/43.png" alt="43.png"></p><h2 id="图形化Dashboard"><a href="#图形化Dashboard" class="headerlink" title="图形化Dashboard"></a>图形化Dashboard</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其他模块记得配置actuator，进行图形化监控 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在被监控的模块主启动器上注入</span></span><br><span class="line"><span class="comment"> *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment"> *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment"> *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment"> *否则，Unable to connect to Command Metric Stream 404</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问仪表盘界面：<a href="http://localhost:9001/hystrix%EF%BC%8C%E8%BE%93%E5%85%A5">http://localhost:9001/hystrix，输入</a> <a href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a> 对服务进行图形化监控，然后我们就可以监控服务熔断demo的流程。</p><h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><h2 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>路由（Route）：匹配规则，由一系列断言和过滤器组成，若断言匹配成功则选择该路由。</li><li>断言（Predicate）：可以匹配HTTP请求的全部内容，断言判断为true则继续进行路由，即选择路由的路径。</li><li>过滤（Filter）：Spring的GatewayFilter实例，使用过滤器可在请求被路由前后对请求进行修改。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/44.png" alt="44.png"></p><p>客户端经过网关的路由、Predicate、以及过滤器的筛选后达到服务端。这个过程是双向的，其中过滤器分为pre、post两类，pre是过滤客户端到服务端，post过滤服务端到客户端。</p><h2 id="网关搭建"><a href="#网关搭建" class="headerlink" title="网关搭建"></a>网关搭建</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网关不是web工程，无需配置web、actuator启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="comment"># 在9527网关上配置8001服务信息</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route</span>           <span class="comment">#路由的ID</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>  <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>    <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route2</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>  <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/feign/**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><p>然后运行8001服务与9527网关，分别访问;</p><p><a href="http://localhost:8001/payment/feign/timeout">http://localhost:8001/payment/feign/timeout</a> 和 <a href="http://localhost:9527/payment/feign/timeout">http://localhost:9527/payment/feign/timeout</a></p><p>可以通过9527访问8001的服务，返回的端口号依旧是8001，通过网关进行中转，我们无需暴露真实服务端口。</p><h2 id="动态路由配置"><a href="#动态路由配置" class="headerlink" title="动态路由配置"></a>动态路由配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="comment">#开启从注册中心动态创建路由的过程，通过微服务名进行路由</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route2</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/feign/**</span></span><br></pre></td></tr></table></figure><p>先开启动态路由配置，然后对网关配置中写死的<strong>uri</strong>进行替换，从注册中心获取动态路由，格式是lb://微服务名，断言路径不变。</p><h2 id="常用的preticates"><a href="#常用的preticates" class="headerlink" title="常用的preticates"></a>常用的preticates</h2><p>官方配置：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></p><ul><li>时间限制</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时区时间的生成：ZonedDateTime time = ZonedDateTime.now();</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route2</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Path=/payment/feign/**</span></span><br><span class="line"><span class="comment"># 提前上线，定时起效</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">After=2021-10-17T10:40:00.781+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>示例：我们将上面的路由设置After时区，规定只有在这段时间之后服务网关才会生效，类似的还有before、between</p><ul><li>cookie限制</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Cookie=username,tang</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不带cookie无法通过，带cookie可以通过</span></span><br><span class="line">curl http://localhost:9527/payment/feign/timeout</span><br><span class="line">curl http://localhost:9527/payment/feign/timeout --cookie <span class="string">&quot;username=tang&quot;</span></span><br></pre></td></tr></table></figure><p>设置cookie的kv键值对，只有对应键值对的请求可以正常访问。</p><ul><li>Header限制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">  - Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure><p>请求头要有X-Request-Id这个属性，且值为整数（正则表达式）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 带有对应请求头的请求才能正常访问</span></span><br><span class="line">curl http://localhost:9527/payment/feign/timeout -H <span class="string">&quot;X-Request-Id:123&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>可在请求被路由前后对请求进行处理。</p><p>官方配置：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml可进行简单的请求头添加，但按照工作流程，filter是在predicates后执行的</span></span><br><span class="line"><span class="comment"># 所以这里添加请求头不会影响predicates的请求头筛选判断</span></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-Id,123</span></span><br></pre></td></tr></table></figure><p><strong>推荐使用全局Filter，功能更丰富，可自行配置日志输出。主要是实现两个接口，GlobalFilter和Ordered</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogGatewayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 请求过滤，不为空链路放行，为空打印日志</span></span><br><span class="line">        log.info(<span class="string">&quot;FilterLog&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        String name = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户名为null？？？&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://localhost:9527/payment/get/1?name=tang">http://localhost:9527/payment/get/1?name=tang</a> 符合过滤器的规则可以正常访问。</p><p><a href="http://localhost:9527/payment/get/1?username=xxx">http://localhost:9527/payment/get/1?username=xxx</a> 只要不符合直接404，无连接，后台也会打印日志。</p><h1 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>每个微服务都有一个配置文件，但服务多了以后一个个修改配置效率太低并任意出错，所以使用配置中心避免重复配置。为不同的微服务环境提供中心化的外部配置。这个外部配置指的是把配置文件上传到github/gitee上，然后通过yml读取仓库的配置。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigMain3344</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigMain3344.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></p><p><a href="http://config-3344.com:3344/master/config-prod.yml">http://config-3344.com:3344/master/config-prod.yml</a></p><p><a href="http://config-3344.com:3344/master/config-test.yml">http://config-3344.com:3344/master/config-test.yml</a></p><p>通过以上格式，/分支/文件名读取配置</p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p><strong>application.yml</strong>是用户级资源配置，<strong>bootstrap.yml</strong>是系统级资源配置，优先级更高。我们为了引入外部的配置文件，需要使用bootstrap.yml，其先于application加载，我们拉取外部配置后，再加载application。</p><p>springcloud默认关闭bootstrap，需要我们手动加入依赖开启。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称</span></span><br><span class="line">      <span class="comment">#上述3个综合：master分支上config-dev.yml被读取http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://config-3344.com:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过路径查看是否加载了正确的配置文件</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:3355/configInfo%EF%BC%8C%E5%92%8C%E4%B9%8B%E5%89%8Dconfig-dev%E5%86%85%E5%AE%B9%E4%B8%80%E8%87%B4%E3%80%82">http://localhost:3355/configInfo，和之前config-dev内容一致。</a></p><h3 id="客户端手动动态刷新"><a href="#客户端手动动态刷新" class="headerlink" title="客户端手动动态刷新"></a>客户端手动动态刷新</h3><p>我们实时修改仓库内的配置，3344可以实时更新，而3355服务读取配置却没有实时更新，需要我们重启服务才能更新配置。所以我们需要开启动态刷新解决该问题。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在刚刚资源访问路径业务类上添加刷新注解</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br></pre></td></tr></table></figure><p>但是直接网页刷新是不会变的。我们必须发送POST请求让服务刷新配置，但不用重启服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd发送post，然后再查看配置发现已更新</span></span><br><span class="line">curl -X POST <span class="string">&quot;http://localhost:3355/actuator/refresh&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Bus（jar包问题）"><a href="#Bus（jar包问题）" class="headerlink" title="Bus（jar包问题）"></a><del>Bus（jar包问题）</del></h2><p>上面Config并没有实现实时的更新，只是从重启服务变为了发送请求后更改，使用Bus消息总线完成自动动态刷新配置。Bus消息代理支持RabbitMQ和Kafka。</p><p>先再linux开启mq，访问mq图形化界面 <a href="http://192.168.158.138:15672。">http://192.168.158.138:15672。</a></p><p>自动动态刷新的两种实现：</p><ul><li>Bus触发一个客户端的刷新，进而传播所有客户端都刷新。</li><li>Bus触发服务端ConfigServer的刷新，然后由服务端广播所有客户端进行刷新。</li></ul><p>我们选择由服务端进行广播的模式吗，这种肯定是更优的。</p><h3 id="服务端广播动态刷新"><a href="#服务端广播动态刷新" class="headerlink" title="服务端广播动态刷新"></a>服务端广播动态刷新</h3><p>新建一个客户端3366一起测试，业务输出端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort + <span class="string">&quot;,&quot;</span> + configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在3344服务端和3355、3366客户端加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件也要引入mq相关，bus-refresh是官方指定的刷新端点。客户端也要配置mq的相关属性</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.138</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置，暴露bus刷新配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;bus-refresh&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:3344/actuator/bus-refresh&quot;</span></span><br></pre></td></tr></table></figure><p><strong>按理来说我们启动服务端和多个客户端，更新依赖后，往服务端端点bus-refresh发送POST请求即可广播全部的客户端。但我在使用bus-amqp这个mq连接依赖时遇到了问题，说缺失类（当前依赖缺失需要的类，使用其他依赖版本），自己删除jar包导入低版本仍无法解决，所以Bus的广播模拟失败，版本才是唯一神，更新换代太快了，网上也搜索不到解决办法就很难受，还得看我Nacos。</strong></p><h1 id="Stream（jar包问题）"><a href="#Stream（jar包问题）" class="headerlink" title="Stream（jar包问题）"></a><del>Stream（jar包问题）</del></h1><p>MQ有多种款式，可使用Stream进行统一。stream会忽略底层使用的MQ差异，适配不同版本的MQ。</p><p>通过Stream的Binder对象进行中间件的交互。定义绑定器Binder作为中间层，实现了中间件的版本隔离。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Input</td><td>注解标识输入通道，通过该输乎通道接收到的消息进入应用程序</td></tr><tr><td>@Output</td><td>注解标识输出通道，发布的消息将通过该通道离开应用程序</td></tr><tr><td>@StreamListener</td><td>监听队列，用于消费者的队列的消息接收</td></tr><tr><td>@EnableBinding</td><td>将信道channel和exchange绑定在一起</td></tr></tbody></table><p>现在这个绑定注解依旧过时了，可参考帖子下面的官方文档设置<a href="https://www.5axxw.com/questions/content/0b9xic%EF%BC%8C%E8%99%BD%E7%84%B6%E6%B3%A8%E8%A7%A3%E8%BF%87%E6%97%B6%E4%BA%86%E4%BD%86%E8%BF%98%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%94%A8%E7%9A%84%E3%80%82">https://www.5axxw.com/questions/content/0b9xic，虽然注解过时了但还是可以用的。</a></p><h2 id="消息生产者（output）"><a href="#消息生产者（output）" class="headerlink" title="消息生产者（output）"></a>消息生产者（output）</h2><p>依赖及配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.139</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">password:</span> <span class="number">111</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>接口 + 实现类 + 业务Controller，启动eureka7001，访问<a href="http://localhost:8801/sendMsg%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%90%8E%E5%8F%B0%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%8C%E4%B8%94MQ%E5%86%85%E5%88%9B%E5%BB%BA%E7%9A%84channel%E4%BA%A7%E7%94%9F%E4%BA%86%E6%B6%88%E6%81%AF%E3%80%82">http://localhost:8801/sendMsg，发现后台有随机数，且MQ内创建的channel产生了消息。</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(Source.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">MessageProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息消费者（input）"><a href="#消息消费者（input）" class="headerlink" title="消息消费者（input）"></a>消息消费者（input）</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.139</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">password:</span> <span class="number">111</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverMessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1，消息：&quot;</span> + msg.getPayload() + <span class="string">&quot;\t port: &quot;</span> + serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者发送随机序列号，通过withPayload发送，消费者通过getPayload获取序列号进行消费。开启8802消费8801信息，<strong>然后又遇到Bus的jar包问题，还好这个消息队列的处理不关键，我们记录一个大概即可，实在是不知道jar包问题该如何处理······</strong></p><h1 id="Sleuth链路跟踪"><a href="#Sleuth链路跟踪" class="headerlink" title="Sleuth链路跟踪"></a>Sleuth链路跟踪</h1><p>zipkin安装及启动 <a href="https://zipkin.io/">https://zipkin.io/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get the latest source</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openzipkin/zipkin</span><br><span class="line"><span class="built_in">cd</span> zipkin</span><br><span class="line"><span class="comment"># Build the server and also make its dependencies</span></span><br><span class="line">./mvnw -DskipTests --also-make -pl zipkin-server clean install</span><br><span class="line"><span class="comment"># Run the server</span></span><br><span class="line">java -jar ./zipkin-server/target/zipkin-server-*exec.jar</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:9411/">http://localhost:9411/</a> zipkin界面。</p><p>在服务8001和消费者80添加依赖和新的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment">#采样率值介于 0 到 1 之间，1 则表示全部采集</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务业务类添加链路请求路径</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/payment/zipkin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentZipkin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Zipkin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者调用服务端</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/zipkin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentZipkin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String result = restTemplate.getForObject(<span class="string">&quot;http://localhost:8001&quot;</span> + <span class="string">&quot;/payment/zipkin&quot;</span>, String.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用消费者调用服务，9411端口会出现记录。注意使用单机环境要先把集群的配置和负载均衡关闭，不然会报错。</p><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="下载及启动"><a href="#下载及启动" class="headerlink" title="下载及启动"></a>下载及启动</h2><p>Nacos充当服务配置中心，Nacos = Eureka + Config + Bus</p><p>在官方进行下载：<a href="https://github.com/alibaba/nacos/releases/tag/1.4.2">https://github.com/alibaba/nacos/releases/tag/1.4.2</a></p><p>在命令行进入bin/startup.cmd进行启动，微盟单机模式需要修改.cmd的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认集群</span></span><br><span class="line"><span class="built_in">set</span> MODE=<span class="string">&quot;cluster&quot;</span></span><br><span class="line"><span class="comment"># 切换单例</span></span><br><span class="line"><span class="built_in">set</span> MODE=<span class="string">&quot;standalone&quot;</span></span><br></pre></td></tr></table></figure><p>启动后访问：<a href="http://localhost:8848/nacos%EF%BC%8C%E5%88%9D%E5%A7%8B%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E5%9D%87%E4%B8%BAnacos%E3%80%82">http://localhost:8848/nacos，初始账号密码均为nacos。</a></p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>官方2.2.6版本相关配置：<a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_introduction">https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_introduction</a></p><p>父类进行pom管理，子类配置依赖无需版本号，在yml中将9001端口配置到nacos。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencymanagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencymanagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务类</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nacos registry, serverPort: &quot;</span>+ serverPort+<span class="string">&quot;\t id&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主启动</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain9001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在8848nacos上的服务列表中，可以找到注册的服务。</p><p>建立两个一样的服务端9001、9002，方便客户端测试Nacos负载均衡功能。</p><h2 id="客户端消费者"><a href="#客户端消费者" class="headerlink" title="客户端消费者"></a>客户端消费者</h2><p>nacos依赖集成ribbon，实现负载均衡</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain83</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain83.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL + <span class="string">&quot;/payment/nacos/&quot;</span> + id, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次访问请求localhost:83/consumer/payment/nacos/1，发现服务端轮询调用，实现了负载均衡。</p><h2 id="注册中心对比"><a href="#注册中心对比" class="headerlink" title="注册中心对比"></a>注册中心对比</h2><p>Eureka：AP</p><p>Zookeeper：CP</p><p>Consul：CP</p><p>Nacos：AP &amp; CP（可切换）</p><h2 id="服务配置中心"><a href="#服务配置中心" class="headerlink" title="服务配置中心"></a>服务配置中心</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两个相关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和config一样，bootstrap优先级高于application，而使用nacos后，bootstrap读配置可以从nacos上读取，不用去git读取。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bootstrap</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span> <span class="comment">#指定yml格式的配置</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line">    <span class="comment">#active: test # 表示测试环境</span></span><br><span class="line">    <span class="comment">#active: info</span></span><br></pre></td></tr></table></figure><p>注意配置注解@RefreshScope，动态更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方：<a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></p><p>在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure><ul><li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li><li><code>spring.profiles.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles">Spring Boot文档</a>。 <strong>注意：当 <code>spring.profiles.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>$&#123;prefix&#125;.$&#123;file-extension&#125;</code></strong></li><li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;spring.application.name&#125;</span>-<span class="variable">$&#123;spring.profile.active&#125;</span>.<span class="variable">$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># 我们nacos上的配置文件需要按照官方要求书写，服务名-配置类型-文件类型</span></span><br><span class="line"><span class="comment"># 也就是我们上面bootstrap和application的内容</span></span><br><span class="line">nacos-config-client-dev.yml</span><br><span class="line">nacos-config-client-test.yml</span><br></pre></td></tr></table></figure><p>在nacos上data id进行对应声明，内容则是yml/properties格式配置。</p><p>最后走请求 localhost:3377/config/info 可读取配置文件的config:info: 内容，且修改版本后会动态刷新，相比于config + bus，nacos又快又好。</p><h2 id="Nacos配置详解"><a href="#Nacos配置详解" class="headerlink" title="Nacos配置详解"></a>Nacos配置详解</h2><p><strong>Nacos配置由NameSpace + Group + Data Id构成，也就是逐层分类。</strong></p><p>NameSpace命名空间，实现环境隔离，如生产、测试、开发三个环境，它们之间是相互隔离的。</p><p>Group，默认为DEFAULT_GROUP，Group可将不同微服务划分到同一个分组中。</p><p>Data Id也就是Service服务，一个服务可包含多个集群。</p><h3 id="Data-Id"><a href="#Data-Id" class="headerlink" title="Data Id"></a>Data Id</h3><p>刚刚分析了Data Id的官方配置：<code>$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</code></p><p>我们配置是对应Data Id分为bootstrap 和 application两个文件，其中bootstrap用于读取nacos配置信息，后续不修改，applition记录配置类型，即生产、测试等版本。也就是要修改的单独放。之后只用改application就能换版本，无需改变bootstrap。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line"><span class="comment">#    active: test # 表示测试环境</span></span><br></pre></td></tr></table></figure><p>nacos-config-client-dev.yml、 nacos-config-client-test.yml，改配置文件spring.profiles.active属性即可指明要使用的环境。</p><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><table><thead><tr><th>Data Id</th><th>GROUP</th></tr></thead><tbody><tr><td>nacos-config-client-info.yml</td><td>DEV_GROUP</td></tr><tr><td>nacos-config-client-info.yml</td><td>TEST_GROUP</td></tr></tbody></table><p>配置服务名相同，组分配的不同的两个服务。通过config下group切换。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">TEST_GROUP</span></span><br></pre></td></tr></table></figure><h3 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h3><p>在Nacos命名空间处声明新的命名空间，默认为public保留空间不可删除，在config下namespace生成的将命名空间id进行配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">d52c7eba-1ada-4ed1-8934-69f388dbdbe9</span></span><br></pre></td></tr></table></figure><h2 id="Nacos持久化"><a href="#Nacos持久化" class="headerlink" title="Nacos持久化"></a>Nacos持久化</h2><p>官网配置信息：<a href="https://nacos.io/zh-cn/docs/deployment.html">https://nacos.io/zh-cn/docs/deployment.html</a></p><p>Nacos原本使用内置数据库derby进行持久化，我们可以对持久化存储的数据库进行配置。将脚本表在本地mysql中构建，然后配置nacos的application。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password.0</span>=<span class="string">111111</span></span><br></pre></td></tr></table></figure><h2 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h2><p>切记linux开启nacos集群，在start.sh中设置jvm大小限制以免越界，虚拟机容量建议分配多一点。</p><p>nginx + nacos集群模拟，将集群ip映射到nginx上进行反向代理，关于nginx和nacos的相关配置就不赘述了，资料很多。</p><h1 id="Sentinel（熔断-降级-限流）"><a href="#Sentinel（熔断-降级-限流）" class="headerlink" title="Sentinel（熔断 + 降级 + 限流）"></a>Sentinel（熔断 + 降级 + 限流）</h1><h2 id="下载、安装"><a href="#下载、安装" class="headerlink" title="下载、安装"></a>下载、安装</h2><p>官方文档：<a href="https://sentinelguard.io/zh-cn/docs/introduction.html">https://sentinelguard.io/zh-cn/docs/introduction.html</a></p><p>然后我们按照官方文档的版本对应，cloud2.2.6对应sentinel1.8.1：<a href="https://github.com/alibaba/Sentinel/releases/tag/1.8.1">https://github.com/alibaba/Sentinel/releases/tag/1.8.1</a></p><p>在jar包目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure><p>然后访问本机8080便是图形化界面，账号密码都是sentinel。</p><h2 id="监控初始化"><a href="#监控初始化" class="headerlink" title="监控初始化"></a>监控初始化</h2><p>xml新引入sentinel相关依赖，和nacos搭配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 激活Sentinel对Feign的支持</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelMain8401</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SentinelMain8401.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试业务</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;...testB&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sentinel采用懒加载机制，我们开启服务后不会主动监测，只有第一次服务被调用后才会被监控。</p><p>我们在簇点链路可以查看服务链接，并对它进行流控、降级、热点、授权等操作。</p><h2 id="流控规则（单机）"><a href="#流控规则（单机）" class="headerlink" title="流控规则（单机）"></a>流控规则（单机）</h2><ul><li>QPS：每秒请求数，可设置阈值<ul><li>流控模式<ul><li>直接：api接口达到限流条件时，进行限流</li><li>关联：A关联B资源，B达到阈值时，A自行限流</li><li>链路：层级链路，设置上层入口监控，若对应的下层资源达到阈值，则对入口进行限流。</li></ul></li><li>流控效果<ul><li>快速失败：直接报错，Blocked by Sentinel (flow limiting)</li><li>Warm Up：冷加载、预热，官方默认coldFactor为3，初次QPS阈值为 阈值/coldFactor，然后随着时间的预热，慢慢将阈值恢复到设定的值。让流量逐步增加，而不是瞬间反应。</li><li>排队等待：排队匀速通过，超时则排队，会设置超时等待时间。</li></ul></li></ul></li></ul><p>一开始使用直接失败的配置，当前点击超过1次/s，sentinel会自行限流控制（Blocked by Sentinel (flow limiting)）</p><p>使用关联模式，我们可以用Postman设置多次请求B，此时手动访问A发现被限流。</p><ul><li>线程数：每秒线程处理数量，可设阈值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置阈值为1，让第一个线程进来后睡10s，然后不断发起请求，前面的线程由于睡眠并没有处理完业务，然后当前申请的线程数超过阈值，则会进行限流。</p><p>线程数只有流控模式，没有流控效果选择（默认为直接失败）。</p><h2 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h2><p><a href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">https://sentinelguard.io/zh-cn/docs/circuit-breaking.html</a></p><ul><li><p>慢调用比例</p><p>设置RT最大响应时间，当前响应时间大于该值，则记为慢调用，同时规定时长、请求数、阈值比例。若在规定时长内，达到请求数且慢调用比例超过阈值，则发生熔断。此后经过一段熔断时长进入half-open半开状态，并放行一次请求做测试，若当前响应超过RT继续熔断，反之结束熔断。</p></li><li><p>异常比例</p><p>规定时间内，请求达到最小请求数，且异常发生的比例超过阈值，则发生熔断。经过一段熔断时长后进入half-open，通过放行一次请求来判断是否结束熔断。比例范围0% ~ 100%。</p></li><li><p>异常数</p><p>规定时间内，请求达到最小请求数，且异常发生次数超过阈值。经过熔断时长后进入half-open，放行一次请求判断是否结束熔断。</p></li></ul><h2 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h2><p>热点搜索访问量大，对热点数据进行限制。</p><p>controller新增兜底方法，使用**@SentinelResource<strong>对应Hystrix的</strong>@HystrixCommand**。</p><p><strong>@SentinelResource</strong>只能处理违反控制台配置的情况，并使用兜底方法处理。如果是代码本身抛出运行时异常，是不会用兜底方法处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int age = 10/0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//兜底方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置热点规则，资源名即@SentinelResource设置的value，设置的参数索引对应我们服务的参数，从0开始对应，也就是0对应第一个参数。只要当我们请求中有这个参数时就会走热点监控。超过设置的阈值就会走兜底方法，若我们没有兜底方法则直接报错。</p><p><strong>参数例外项：当配置参数时某个特殊值时，阈值会不一样，可自行确认值的类型和值。</strong></p><h2 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a></p><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>相当于一个全局入口配置。</p><h2 id="SentinelResource"><a href="#SentinelResource" class="headerlink" title="@SentinelResource"></a>@SentinelResource</h2><h3 id="blockHandler"><a href="#blockHandler" class="headerlink" title="blockHandler"></a>blockHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/byResource&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byResource&quot;, blockHandler = &quot;handleException&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;按资源名称限流测试OK&quot;</span>, <span class="keyword">new</span> Payment(<span class="number">2020L</span>, <span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handleException</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>, exception.getClass().getCanonicalName() + <span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byUrl&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;按url限流测试OK&quot;</span>, <span class="keyword">new</span> Payment(<span class="number">2020L</span>, <span class="string">&quot;serial002&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对资源进行限流处理时，可以对@SentinelResource声明的value处理，限流会走自定义方法，没有配置则走默认。或是直接走@GetMapping的url，限流只会走自定义的方法。</p><p>而兜底方法每次都要配置，我们需要进行解耦操作。设置自定义限流处理类：CustomerBlockHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">&quot;按客戶自定义,global handlerException----1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException2</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">&quot;按客戶自定义,global handlerException----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//controller调用兜底方法处理类</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomerBlockHandler.class,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;handlerException2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">customerBlockHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;按客戶自定义&quot;</span>, <span class="keyword">new</span> Payment(<span class="number">2020L</span>, <span class="string">&quot;serial003&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h3><p>配饰配置服务9003/9004和消费者84，消费者配置sentinel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9003/9004的业务类</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    <span class="comment">//模拟数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long, Payment&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>, <span class="keyword">new</span> Payment(<span class="number">1L</span>, <span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>, <span class="keyword">new</span> Payment(<span class="number">2L</span>, <span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>, <span class="keyword">new</span> Payment(<span class="number">3L</span>, <span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        Payment payment = hashMap.get(id);</span><br><span class="line">        CommonResult&lt;Payment&gt; result = <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;from mysql,serverPort:  &quot;</span> + serverPort, payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleBreakerController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_URL = <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;, blockHandler = &quot;blockHandler&quot;, fallback = &quot;handlerFallback&quot;， exceptionsToIgnore = IllegalArgumentException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span> + id, CommonResult.class, id);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id, Throwable e)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span> + e.getMessage(), payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span>  Long id, BlockException blockException)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>,<span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务，发现ribbon生效，默认轮询调用两个服务端口，且@SentinelResource可配置fallback 和 blockHandler。二者同时配置时，因控制台限流、降级抛出的异常优先由blockHandler处理。</p><ul><li><p>fallback可设置业务代码异常的兜底方法。</p></li><li><p>blockHandler可设置控制台配置的熔断降级处理的兜底方法。</p></li><li><p>exceptionsToIgnore配置异常进行过滤，兜底方法不会处理。</p></li></ul><h2 id="整合OpenFeign"><a href="#整合OpenFeign" class="headerlink" title="整合OpenFeign"></a>整合OpenFeign</h2><p>修改84消费者的配置，注意OpenFeign会与devtools依赖冲突，需去掉devtools</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>主启动类加上@EnableFeignClients注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;, fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;服务降级，PaymentFallbackService&quot;</span>, <span class="keyword">new</span> Payment(id, <span class="string">&quot;errorSerial&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller使用Feign配置兜底方法</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用OpenFeign配置熔断的兜底方法，接口声明服务，实现接口作为fallback为服务熔断后的处理具体实现。然后在controller中无需使用restTemplate，直接使用接口的组件调用服务。</p><h2 id="Sentinel持久化"><a href="#Sentinel持久化" class="headerlink" title="Sentinel持久化"></a>Sentinel持久化</h2><p>每次重启应用，规则配置都会重置，所以我们需要进行持久化操作。这里使用8401服务模拟。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos数据源配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span> </span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">sentinel-service</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure><p>完成依赖及配置后，进入Nacosxi新增配置，配置名即我们的服务名sentinel-service，选择json数据类型进行以下配置。然后在sentinel中我们就会加载这个限流的配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/rateLimit/byUrl&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;IimitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;grade&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;clusterMode&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><ul><li>resource：资源名称</li><li>limitApp：来源应用</li><li>grade：阈值类型，0表示线程数, 1表示QPS</li><li>count：单机阈值</li><li>strategy：流控模式，0表示直接，1表示关联，2表示链路</li><li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待</li><li>clusterMode：是否集群</li></ul><p>完成持久化配置后，我们每次调用服务后，sentinel会监听到服务，并加载Nacos中对应服务的流控配置。</p><h1 id="Seata（分布式事务）"><a href="#Seata（分布式事务）" class="headerlink" title="Seata（分布式事务）"></a>Seata（分布式事务）</h1><p>官网：<a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html">http://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><p>分布式事务要保证全局数据一致性。Seata由1 + 3组成，即一个全局唯一的事务ID + TC + TM + RM构成。</p><ul><li><p>TC (Transaction Coordinator) - 事务协调者</p><p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p></li><li><p>TM (Transaction Manager) - 事务管理器</p><p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p></li><li><p>RM (Resource Manager) - 资源管理器</p><p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud简述&quot;&gt;&lt;a href=&quot;#Spring-Cloud简述&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud简述&quot;&gt;&lt;/a&gt;Spring Cloud简述&lt;/h1&gt;&lt;p&gt;Spring Cloud微服务是由多功能模块</summary>
      
    
    
    
    <category term="后端" scheme="http://aidianfirst.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>秽翼的尤斯蒂娅</title>
    <link href="http://aidianfirst.com/2021/10/06/%E7%94%9F%E6%B4%BB/%E7%A7%BD%E7%BF%BC%E7%9A%84%E5%B0%A4%E6%96%AF%E8%92%82%E5%A8%85/"/>
    <id>http://aidianfirst.com/2021/10/06/%E7%94%9F%E6%B4%BB/%E7%A7%BD%E7%BF%BC%E7%9A%84%E5%B0%A4%E6%96%AF%E8%92%82%E5%A8%85/</id>
    <published>2021-10-06T07:15:27.000Z</published>
    <updated>2023-07-30T11:20:17.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秽翼的尤斯蒂娅"><a href="#秽翼的尤斯蒂娅" class="headerlink" title="秽翼的尤斯蒂娅"></a>秽翼的尤斯蒂娅</h1><p>因为自己玩过一些剧情作，所以感觉秽翼在剧情上并没有让人特别惊艳，但是秽翼在角色刻画以及整体世界观的构建上还是做的不错的。打完后最直接的感受就是这是一部佳作，适合萌新入坑，相信不那么完美的结局对萌新来说是一个美好的初体验（笑），特别是结尾CV放完后，我还以为有尾声剧情，没想到直接来了个经典CG，在伤口上撒盐了属于是。</p><p>个人感觉秽翼做成全年龄向食用更佳。</p><p>最后贴一个漫雨大大的杂谈，分析还是很到位的：<a href="https://www.bilibili.com/video/BV174411i73a">https://www.bilibili.com/video/BV174411i73a</a></p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/huiyi.png" alt="huiyi.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;秽翼的尤斯蒂娅&quot;&gt;&lt;a href=&quot;#秽翼的尤斯蒂娅&quot; class=&quot;headerlink&quot; title=&quot;秽翼的尤斯蒂娅&quot;&gt;&lt;/a&gt;秽翼的尤斯蒂娅&lt;/h1&gt;&lt;p&gt;因为自己玩过一些剧情作，所以感觉秽翼在剧情上并没有让人特别惊艳，但是秽翼在角色刻画以及整体世界观的构</summary>
      
    
    
    
    <category term="生活" scheme="http://aidianfirst.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx简单学习</title>
    <link href="http://aidianfirst.com/2021/10/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aidianfirst.com/2021/10/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-10-05T03:05:02.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx网络代理"><a href="#Nginx网络代理" class="headerlink" title="Nginx网络代理"></a>Nginx网络代理</h1><ul><li><p>正向代理（客户端）：</p><p>即代理客户端的访问，VPN就是典型的正向代理，正向代理中客户端是知道请求的目标的，而服务器不知道客户端是通过中间商访问的，它会认为是VPN的节点在访问。</p></li><li><p>反向代理（服务端）：</p><p>当我们访问大型网站时，肯定不是所有人都访问一个服务器，比如访问百度，我们使用外网访问固定url：<code>www.baidu.com</code>，而内网会通过反向代理，将访问请求转发到各地的服务器，是用来代理服务端的访问。</p></li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>根据服务器的情况进行分配，nginx负载均衡有两种策略：内置策略和扩展策略。</p><ul><li><p>内置策略</p><ul><li>轮询：均衡分配，一个一个来</li><li>加权轮询：按自定义的权重比例进行分配</li><li>ip hash：对客户端url请求的ip进行hash，然后根据hash结果分配给对应的服务器，可解决session不共享的问题。</li></ul></li><li><p>外置策略：即自行设置算法分配</p></li></ul><h1 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h1><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/42.png" alt="42.png"></p><p>相当于nginx对反向代理的实际应用，使用Nginx处理请求，动静分离节省服务器资源。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网自行下载linux版本</p><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf &lt;压缩包&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入解压文件，执行配置脚本</span></span><br><span class="line">./configure</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若出现nginx error可执行</span></span><br><span class="line">yum -y install pcre-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行安装命令</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h1 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nginx version: nginx/1.20.1</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-p prefix]</span><br><span class="line">             [-e filename] [-c filename] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /usr/local/nginx/)</span><br><span class="line">  -e filename   : set error log file (default: logs/error.log)</span><br><span class="line">  -c filename   : set configuration file (default: conf/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx网络代理&quot;&gt;&lt;a href=&quot;#Nginx网络代理&quot; class=&quot;headerlink&quot; title=&quot;Nginx网络代理&quot;&gt;&lt;/a&gt;Nginx网络代理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正向代理（客户端）：&lt;/p&gt;
&lt;p&gt;即代理客户端的访问，VPN就是</summary>
      
    
    
    
    <category term="中间件" scheme="http://aidianfirst.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>了解JVM（深入了解Java虚拟机浅读）</title>
    <link href="http://aidianfirst.com/2021/10/02/%E5%90%8E%E7%AB%AF/%E4%BA%86%E8%A7%A3JVM%EF%BC%88%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B5%85%E8%AF%BB%EF%BC%89/"/>
    <id>http://aidianfirst.com/2021/10/02/%E5%90%8E%E7%AB%AF/%E4%BA%86%E8%A7%A3JVM%EF%BC%88%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B5%85%E8%AF%BB%EF%BC%89/</id>
    <published>2021-10-02T09:59:30.000Z</published>
    <updated>2023-07-30T11:20:17.735Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-12-1 更新记录</span><br><span class="line">周志明老师这本书讲的太深了，自己主要针对八股常问的一些点进行了阅读理解，发现网上的好多文章都是来自于此😂，相对于上次背八股的JVM记录，这次浅读对这些点有了一定的理解，确实很细，以后工作了可以再抽空深挖一下虚拟机的其他内容。</span><br></pre></td></tr></table></figure><h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ul><li>进程中线程共享：<ul><li>堆</li><li>方法区</li></ul></li><li>进程中线程私有：<ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li></ul><h3 id="程序计数器（一块较小的内存空间）"><a href="#程序计数器（一块较小的内存空间）" class="headerlink" title="程序计数器（一块较小的内存空间）"></a>程序计数器（一块较小的内存空间）</h3><ul><li>java是编译成字节码运行，程序计数器可看作当前线程执行字节码的行号指示器。</li><li>多线程情况下，程序计数器用于记录当前线程的执行位置，当线程切换回来可知道线程上次运行的位置。</li></ul><p>各线程之间程序计数器互不影响，独立存储，这一块内存是线程私有的内存。</p><h3 id="虚拟机栈（Java方法）"><a href="#虚拟机栈（Java方法）" class="headerlink" title="虚拟机栈（Java方法）"></a>虚拟机栈（Java方法）</h3><p>与程序计数器一样，Java虚拟机栈是线程私有的，用于描述Java方法执行的内存模型，每次方法调用数据都是通过栈传递。</p><p>虚拟机栈生命周期与线程一样，当方法被执行时，JVM会同步创建一个<strong>栈帧</strong>（用于存储局部变量表、操作数栈、动态链接、方法出口等信息），每一个方法执行的过程就相当于栈帧在虚拟机栈中入栈到出栈。</p><p>Java内存可大致分为堆内存和栈内存，栈指的是虚拟机栈，或者是虚拟机栈的局部变量表部分。</p><p><strong>局部变量表用于存放方法参数和方法内部定义的局部变量。其存放了编译期可知的8种基本数据类型、对象引用</strong>（reference类型，并不等于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）、<strong>returnAddress类型</strong>（指向了一条字节码指令的地址，也就是方法退出时的返回地址，有正常调用退出和异常调用完成退出两种情况，该字节码是为了方法结束时，将结果返回上层调用者）。</p><h3 id="本地方法栈（Native方法）"><a href="#本地方法栈（Native方法）" class="headerlink" title="本地方法栈（Native方法）"></a>本地方法栈（Native方法）</h3><p>作用与虚拟机栈相似，虚拟机栈为JVM使用的Java方法服务，本地方法栈为JVM使用的Native方法服务。功能和虚拟机栈一致。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>JVM内存管理中最大的一块，堆是所有线程共享的内存区域，在虚拟机启动时创建。<strong>该区域的唯一目的就是存放对象实例，几乎所有对象实例及数组都在这分配内存，Java堆是垃圾收集器的主要区域，也被称作GC堆。</strong></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与堆一样，方法区是线程共享的内存区域，它用于存储已被JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据。也称作非堆。JDK8前方法区实现为永久代，JDK8后实现为元空间。</p><p><strong>JDK7将字符串常量池、静态变量等移至堆，JDK8后移除永久代，被元空间代替。</strong></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。</p><p>字符串常量池在JDK7后移至堆，属于JVM常量池，包装类常量池准确说时对象池，只是用了常量池技术而已，其属于Java层面。如Integer常量池是一个cache数组存储。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并非是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。</p><h2 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h2><p>JVM相当于一个虚拟机规范，而HotSpot就是规范的具体实现。以下基于HotSpot。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ul><li><p>new，类加载检查</p><p>虚拟机遇到一条new指令时，会检查当前指令的参数是否能在常量池中定位到这个类的符号引用，并检查该符号引用的类是否已加载。若没有，则执行相应的类加载过程。</p></li><li><p>分配内存</p><p>在类加载检查后，虚拟机会为新对象分配内存。类加载完成后可确定对象所需的内存大小，此时只需要将确定大小的内存从Java堆中划分出来。Java堆有两种分配方式：</p><ul><li><p><strong>指针碰撞</strong></p><p>内存空间规整，即一边是使用过的内存，另一边是空闲内存，指针只需要在中间挪动</p></li><li><p><strong>空闲列表</strong></p><p>内存空间分布不规整，占用内存和空闲内存相交错，JVM需要维护一个列表，记录可用的内存块。</p></li></ul><p>分配的方法是根据其规整情况，也就是垃圾收集器来选择，其回收算法不同，导致内存空间情况不同。</p><p>而对于并发情况下的内存分配有两种方法：</p><ul><li>分配操作同步处理，CAS + 失败重试保证操作原子性</li><li>本地线程分配缓冲TLAB，每个线程在堆中预先分配内存，在各自内存进行操作</li></ul></li><li><p>初始化零值</p><p>内存分配后，虚拟机将分配的内存空间都初始化为零值<strong>（不包括对象头）</strong>，该操作是为了保证对象的实例字段可不赋初始值就直接使用，程序则会访问该实例字段对应类型的初始值。</p></li><li><p>设置对象头</p><p>初始化零值后，虚拟机会将对象的相关信息存放到对象头中，如哈希码、GC分代年龄、锁相关信息、类的元数据信息等。</p></li><li><p>执行<code>&lt;init&gt;()</code>方法，构造函数</p><p>虚拟机完成了对象创建，但对于程序来说，对象创建才刚开始，此时执行init()方法，初始化对象。new指令后接着执行<code>&lt;init&gt;()</code>方法。</p></li></ul><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>对象在内存中布局可分为3快区域：<strong>对象头、实例数据、对齐填充。</strong></p><ul><li><p><strong>对象头：</strong>包含两部分信息，一部分<strong>用于存储对象自身运行时数据</strong>，另一部分是<strong>类型指针</strong>（对象指向其类元数据的指针），虚拟机通过该指针确定对象是某个类的实例。</p></li><li><p><strong>实例数据：对象真正存储的有效信息。</strong></p></li><li><p><strong>对齐填充：不是必要的，仅仅起占位作用。</strong>由于HotSpot虚拟机要求对象大小必须是8字节的整数倍，通过对齐填充补齐。</p></li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>通过<strong>句柄</strong>和<strong>直接指针</strong>两种方式实现访问定位。</p><ul><li><p><strong>句柄访问</strong></p><p>Java堆会划分出句柄池的内存，reference存放对象的句柄地址，句柄中包含了对象实例数据和类型数据的具体地址信息。根据想访问的信息，进行间接访问。</p><p>优点：reference存储的句柄地址稳定，对象被移动时，只会改变句柄中的指针信息，reference本身不会修改。</p></li><li><p><strong>直接指针访问（HotSpot）</strong></p><p>reference存储的是对象地址，此时Java堆中对象的内存布局需要考虑如何放置访问类型数据的相关信息。如果之访问对象实例信息，则无需间接访问的开销，因为对象内存布局包含了对象的实例信息。</p><p>优点：访问速度快，节省了指针定位的时间开销。</p></li></ul><p>java实例数据：堆（对象布局）</p><p>java类型数据：方法区</p><h1 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h1><h2 id="堆空间分配与垃圾回收"><a href="#堆空间分配与垃圾回收" class="headerlink" title="堆空间分配与垃圾回收"></a>堆空间分配与垃圾回收</h2><p><strong>基本结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/35.png" alt="35.png"></p><p>新生代内存：eden、from survivor0（s0）、to survivor1（s1）</p><p>老年代内存：old memory</p><p>Minor GC：新生代垃圾回收</p><p>Major GC：老年代垃圾回收，CMS</p><p>Mixed GC：对整个新生代与部分老年代进行垃圾回收，G1</p><p>Full GC：清理整个Java堆和方法区的垃圾收集</p><ul><li><p><strong>对象会优先在eden区域分配</strong></p></li><li><p><strong>大对象直接进入老年代，大对象即大量连续内存空间的Java对象，如长字符串，元素数量庞大的数组</strong></p></li><li><p><strong>长期存活对象进入老年代，JVM为每个对象定义了一个对象年龄计算器，存储在对象头中，一般对象在eden区诞生，若经过一次Minor GC并被Survivor区容纳，则年龄+1，达到一定值（默认15）则晋升为老年代。</strong></p></li></ul><h2 id="如何判断对象是否可回收"><a href="#如何判断对象是否可回收" class="headerlink" title="如何判断对象是否可回收"></a>如何判断对象是否可回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象添加引用计数器，每次引用+1，引用失效-1，计数器=0即对象可回收。</p><p><strong>但由于对象之间会产生循环引用问题，主流虚拟机并没有使用该算法进行内存管理。</strong></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列称为GC Roots的根对象作为起始节点集，所有该节点可达到的对象是存活的，不可达的对象可被回收。</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/36.png" alt="36.png"></p><p>GC Roots的选取一般为以下几种：</p><ul><li>虚拟机栈中引用的对象，如方法参数、局部变量等</li><li>本地方法栈中（Native方法）引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JVM内部引用，如基本数据类型对应的Class对象</li></ul><p>在可达性算法中，为了完成对象图的遍历，引入了三色标记进行辅助：</p><ul><li>白色：当前对象尚未被访问，最终仍为白色的对象即不可达的</li><li>黑色：对象及其引用都被访问过，全部存活，后续不会重复扫描</li><li>灰色：当前对象被访问过，但其关系上至少有一个引用未被扫描</li></ul><p>在可达性扫描中可能会遭遇并发问题，导致黑色对象更改后关系链上多出了白色对象，一般是插入或删除了一些引用导致的，进而引申出两种解决方法 <strong>增量更新</strong> 和 <strong>原始快照（SATB）</strong>，它们解决办法都是记录更改，后续重新遍历关系进行确认。</p><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><ul><li><p>强引用</p><p><strong>被强引用关联的对象不会回收</strong>。</p><p>使用 new 关键字来创建强引用。</p></li><li><p>软引用</p><p><strong>软引用关联对象只有在内存不足时才会被回收</strong>。</p><p>使用 SoftReference类 来创建软引用。</p></li><li><p>弱引用</p><p><strong>弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前。</strong></p><p>使用 WeakReference类 来创建软引用。</p></li><li><p>虚引用</p><p><strong>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到对象。</strong></p><p>为一个对象设置虚引用的唯一作用，就是该对象被回收时会收到一个系统通知。</p><p>使用 PhantomReference类 来创建虚引用。</p></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>垃圾收集算法可划分为 <code>引用计数式垃圾收集</code> 和 <code>追踪式垃圾收集</code> 两类，也叫做直接、间接垃圾收集，而我们主流JVM使用的算法都是属于<code>追踪式垃圾收集</code>。</p><p>而垃圾收集器都是以 <code>分代收集</code> 理论作为基础的，其建立在几个假说之上：</p><ul><li>弱分代假说：大部分对象都会朝生夕灭，即在新生代就被GC。</li><li>强分代假说：对象活的越久，经历过更多次的GC，该对象就功能消亡，也就是晋升为老年代。</li><li>跨代引用假说：跨代引用，即两个相互作用的对象，其更倾向于同生同灭，如新生代对象与老年代对象相互作用，那么新生代在GC时因为引用得以存活，逐渐晋升到老年代，跨代引用消除。</li></ul><h3 id="标记–清除（内存分配复杂，老年代）"><a href="#标记–清除（内存分配复杂，老年代）" class="headerlink" title="标记–清除（内存分配复杂，老年代）"></a>标记–清除（内存分配复杂，老年代）</h3><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/37.png" alt="37.png"></p><p>标记所有要回收（不要回收）的对象，标记完成后，统一回收所有标记（未被标记）的对象，该算法是最基础的回收算法，其余算法都是对它的改进。</p><p>缺点：</p><ul><li>标记==清除执行效率不稳定，会随着对象数量增长而降低</li><li>会导致内存空间碎片化</li></ul><h3 id="标记–整理（内存回收复杂，老年代）"><a href="#标记–整理（内存回收复杂，老年代）" class="headerlink" title="标记–整理（内存回收复杂，老年代）"></a>标记–整理（内存回收复杂，老年代）</h3><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/38.png" alt="38.png"></p><p>让所有的存活对象向内存空间一端移动，随后清理边界以外的内存。</p><p>优点：不会产生内存碎片</p><p>缺点：移动大量对象，需要暂停用户应用程序进行，效率低</p><h3 id="标记–复制（新生代）"><a href="#标记–复制（新生代）" class="headerlink" title="标记–复制（新生代）"></a>标记–复制（新生代）</h3><p> <img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/39.png" alt="39.png"></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存使用完后，先将存活对象全部复制到另一块上，然后再将这一块内存清理。保证有一半的区域充当备用。</p><p>后续Andrew Appel进行优化，称作 Appel式回收，将新生代分为一块较大的Eden空间和两块较小的Survivor空间，而每次的内存分配只使用Eden和其中一块Survivor，复制算法会体现在两个Survivor空间上，当Survivor空间没有空闲时，对象将有分配担保机制进入老年代。</p><p>HotSpot默认分配Eden和Survivor的比例是8:1:1，也就是说新生代可用空间为总空间的90%，只浪费了10%的空间。</p><p>缺点：内存只能使用部分，空间浪费。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/blog13.jpg" alt="blog13.png"></p><p><strong>新生代（标记–复制）</strong></p><ul><li><p><strong>Serial收集器（Client，单线程）</strong></p><p>单线程收集器，GC时会暂停所有其他工作线程，但相比其他收集器的单线程更加简单高效，且对于内存受限的环境，它是所有收集器里额外内存消耗最小的，没有线程交互的开销。</p></li><li><p><strong>ParNew收集器（Server，多线程）</strong></p><p><strong>Serial的多线程版本</strong>，除了支持多线程外和Serial一致，除了Serial外，只有它可以和CMS收集器配合使用。</p></li><li><p><strong>Parallel Scavenge收集器（吞吐量优先）</strong></p><p>多线程收集器，其他收集器在意的是用户线程的停顿时间，而它的关注点是达到一个可控的吞吐量，即高效利用CPU时间。适合用于后台运算且无需太多交互的任务。</p></li></ul><p><strong>老年代（标记–清除、标记–整理）</strong></p><ul><li><p><strong>Serial Old收集器（Client，单线程）</strong></p><p><strong>Serial的老年代版本</strong>。主要有两大作用：一是JDK1.5以前与 Parallel Scavenge 搭配使用，二是作为CMS收集器发送失败的后备方案。</p></li><li><p><strong>Parallel Old收集器（多线程，吞吐量）</strong></p><p><strong>Parallel Scavenge的老年代版本</strong>，注重吞吐量或CPU资源敏感时，可考虑使用Parallel Scavenge + Parallel Old。</p></li><li><p><strong>CMS收集器（Concurrent Mark Sweep）</strong></p><p>CMS的MS即Mark Sweep标记清除算法，此处实现步骤分4步：</p><ul><li><strong>初始标记：</strong>标记GC Roots能直接关联的对象，速度快，需要停顿。</li><li><strong>并发标记：</strong>从GC Roots的直接关联对象遍历整个对象图的过程，在整个回收过程中耗时最长，无需停顿。</li><li><strong>重新标记：</strong>为了修正并发标记期间，因用户程序继续运作，进而导致标记产生变动的部分对象的标记记录，需要停顿。也就是可达性算法并发情况下增量更新解决的问题。</li><li><strong>并发清除：</strong>清理标记阶段判断为已死亡的对象，无需停顿。</li></ul><p>优点：并发收集，低停顿。</p><p>缺点：</p><ul><li>吞吐量低，CPU利用率不高。</li><li>无法处理浮动垃圾，可启用Serial Old进行替代。</li><li>标记–清除算法会产生空间碎片，使得没有大空间来分配对象，进而导致提前使用Full GC。可以在多次 标记–清除 后执行 标记–整理 避免空间浪费。</li></ul></li><li><p><strong>G1收集器（server）</strong></p><p>G1不在局限于分代，它可以处理新生代和老年代，是特殊的Mixed GC。</p><p>G1不在以固定大小和固定数量划分分代空间，而是将连续的Java堆分为多个大小相同的<strong>独立区域（Region）</strong>，每一个Region根据需求扮演新生代（Eden、Survivor）、老年代。</p><p>运作过程：</p><ul><li><strong>初始标记：</strong>GC Roots能直接关联的对象·····，需要暂停。</li><li><strong>并发标记：</strong>从GC Roots进行可达性分析，递归整个对象图</li><li><strong>最终标记：</strong>处理 原始快照SATB 问题。短暂暂停。</li><li><strong>筛选回收：</strong>更新Region，对Region回收价值与成本进行排序，然后进行回收。需要暂停。</li></ul><p>特点：</p><ul><li>空间整合：整体基于 标记–整理 实现，局部基于 标记–复制 实现，即运行时不会产生空间碎片。</li><li>可预测停顿：指明使用者在某长度时间片段内，GC不得超过相应的规定时间。</li><li>分Region的内存分布</li></ul></li></ul><h3 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h3><ul><li>Shenandoah收集器</li><li>ZGC</li></ul><p>二者都是基于Region的内存布局，ZGC更优秀，<strong>可在任意内存大小下，都将垃圾收集的停顿时间限制在10ms以内的低延迟</strong>。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p><strong>只有6种主动引用才会触发初始化，其他的引用类型方式都不会触发初始化，称为被动引用。</strong></p><p><strong>主动引用</strong></p><ul><li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四个字节码指令时，若当前类型没有初始化则触发其初始化。<ul><li>使用new实例化对象</li><li>读取 或 设置 一个类型的静态字段时（被final修饰的静态字段 和 在编译器将结果放入常量池的静态字段 除外）</li><li>调用一个类型的静态字段时</li></ul></li><li>对类型进行反射调用时，该类型没有初始化。</li><li>当初始化类时，其父类未初始化，则先去初始化该父类；而接口初始化时，不要求其父接口全部初始化，只有用到父接口时才会初始化。</li><li>JVM启动时，优先初始化主类（含main()的类）。</li><li>使用JDK7加入的动态语句支持，某实例解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial，这四种类型的方法句柄，且该方法句柄对应类未进行初始化时。</li><li>当一个接口定义了JDK8新加入的默认方法（default关键字修饰），若该接口的实现类发生了初始化，该接口要在其之前被初始化。</li></ul><p><strong>被动引用（举例）</strong></p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义该字段的类才会被初始化，所以当静态字段在父类时，通过子类引用该字段，只会触发父类的初始化。</li><li>通过数组定义来引用类，不会触发该类的初始化。定义一个类的数组，直接由虚拟机自动生成，继承于Object，创建动作由字节码指令anewarray触发，而该类不会初始化。</li><li>引用类的常量，（static final）常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，所以不会触发常量所属类的初始化。</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/40.png" alt="40.png"></p><ul><li><strong>加载</strong></li><li><strong>验证</strong></li><li><strong>准备</strong></li><li><strong>解析</strong></li><li><strong>初始化</strong></li><li>使用</li><li>卸载</li></ul><p>其中验证、准备、解析，统称为连接阶段。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>包括了加载、验证、准备、解析、初始化5个阶段。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，JVM会完成以下三件事：</p><ul><li><p>通过类的全限定名来获取此类的二进制字节流。</p></li><li><p>将字节流所代表的 静态存储结构 转换成方法区的 运行时存储结构。</p></li><li><p>在内存中生成一个代表该类的 java.lang.Class对象，作为方法区中该类各种数据的访问入口。</p></li></ul><p>但以上三点要求并不具体，有很大的发挥空间，如没有明确指明从哪里获取、如何获取等。由此引申出了一些技术，如ZIP压缩包读取加载，即JAR、WAR等；网络获取；JSP等。</p><p><strong>非数组类型的加载阶段可以用上述多种方式进行，而数组类本身不提供类加载器创建，其元素类型最终还是由类加载器完成加载。</strong></p><p>加载阶段与连接阶段的部分动作时交叉进行的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段大致可分为四步校验动作：</p><ul><li>文件格式验证：字节流是否符号Class文件格式规范</li><li>元数据验证：对字节码描述信息进行语义分析（父类、抽象类、继承、数据类型等相关校验）</li><li>字节码验证：通过数据流、控制流分析，确定程序语义是否合法，符合逻辑。（对方法体校验）</li><li>符号引用验证：该阶段实际发生在JVM将<strong>符号引用</strong>转化为<strong>直接引用</strong>时，是解析阶段才发生的。（该类是否 缺少 或 被禁止访问 它依赖的资源）</li></ul><p>验证阶段对于JVM类加载机制来说，是一个重要但不是必要的阶段，因为该阶段只有通过或不通过的差别，通过验证对后续程序运行无影响，所以当我们的程序被反复使用和验证后，可在生产环境的实施阶段关闭大部分的类验证措施（-Xverify:none），缩短JVM加载的时间。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类中定义的<strong>静态变量</strong>分配内存并设置<strong>类变量初始值</strong>的阶段，这些变量内存理论上应在方法区分配。而逻辑上的方法区有具体的实现，JDK7之前，是永久代实现方法区，变量分配在方法区上；而JDK7后<strong>类变量</strong>迁移到Java堆中进行分配。</p><p>当然准备阶段进行内存分配的仅仅是类变量，不包括实例变量，实例变量是随着对象实例化和对象一起分配到Java堆中。</p><p>设置类变量初始值也分情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>第一种value在准备阶段设置初值=0，而不是111，因为此时并未执行Java方法，只有value赋值111的对应putstatic指令被编译后，才会被复制，也就是到初始化阶段才会赋值111。</p><p>当然也有例外，如果类字段的字段属性表存在ConstantValue属性，准备阶段就会初始成该值。被final修饰的类变量，在编译时会生成ConstantValue属性，在准备阶段JVM根据该属性赋值value=111。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>JVM将常量池<strong>符号引用</strong>替换成<strong>直接引用</strong>的过程。</p><ul><li><p>符号引用：以一组符号描述引用的目标，可以是任何形式的字面量。与JVM内存布局无关，各自JVM实现内存布局不相同，但它们接受符号引用必须一致。<strong>（字符串）</strong></p><p>符号引用通常指代全限定名、包名、字段和方法的名称与描述符。</p></li><li><p>直接引用：可以是直接指向目标的指针、相对偏移量或一个间接定位目标的句柄。与JVM内存布局直接相关，有了直接引用，该引用的目标必定存在于JVM内存中。<strong>（内存地址）</strong></p></li></ul><p>也就是说将包名、全限定名这种字符串表示量转换成相应的内存地址。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段才是真正开始执行类中定义的Java代码，进行准备阶段时，变量已经设置了初值，到了初始化阶段，会根据程序编码去初始化类变量和资源。<strong>初始化阶段就是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</strong></p><p><code>&lt;clinit&gt;()</code> 方法是 类变量 + 静态语句块。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载阶段中 “通过类全限定名获取该类的二进制字节流”，JVM的设计团队希望这个动作可以放到JVM外部去实现，也就是让程序自行决定如何去获取所需要的类。类加载器只用于实现类的加载动作，可确定类在JVM中的唯一性，且每一个类加载器有独立的类名称空间。</p><p>可以比较两个类是否 “相等”，只有两个类是同一个类加载器加载的前提下才相等。即使两个类来自同一个Class文件，被同一个JVM加载，只要它们的类加载器不同，这两个类就不相等。</p><p>对于JVM来说，只存在两种类加载器，启动类加载器（C++实现，是JVM的一部分） 和 其他所有的类加载器（这些是由Java实现的，独立存在于JVM外部）。</p><p>Java一致保持三层类加载器、双亲委派的类加载结构。</p><h3 id="三层类加载器-双亲委派模型"><a href="#三层类加载器-双亲委派模型" class="headerlink" title="三层类加载器 + 双亲委派模型"></a>三层类加载器 + 双亲委派模型</h3><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/41.png" alt="41.png"></p><ul><li><p>启动类加载器：</p><p>负责加载 <code>&lt;JAVA_HOME&gt;\lib</code> 目录下 或 -Xbootclasspath参数指定路径 的类库（还必须时JVM可以识别的类库，名字不符的类库即使路径正确也不会加载）。启动类加载器无法被Java程序直接引用，用户编写自定义类加载器时，可将加载请求委派给启动类加载器处理。</p></li><li><p>扩展类加载器：</p><p>负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录下 或 java.ext.dirs系统变量指定路径 的所有类库。是Java系统类库的扩展机制，可自行添加到ext目录下扩展Java SE功能。</p></li><li><p>应用程序类加载器</p><p>加载用户类路径（ClassPath）上的全部类库，如果程序中没有自定义类加载器，一般情况下这个就是默认的类加载器。</p></li><li><p>自定义类加载器</p><p>可自定义拓展，如增加除磁盘位置外的Class文件来源。</p></li></ul><p><strong>各种类加载器之间的层次关系被称为类加载器的 “双亲委派模型”。</strong></p><p>双亲委派模型要求除顶层的启动类加载器外，其余的类加载器都要有自己的父类加载器。这里父子关系通过组合关系实现，而非继承关系。</p><ul><li><p>工作流程</p><p>一个类加载器首先将类加载请求委派给父加载器完成，每个层次的类加载器都是如此，最终所有的加载请求都会传送到顶层的启动类加载器，只有当父加载器无法完成加载请求时（其搜索范围内没有需要的类），子加载器才会尝试自行加载。</p></li><li><p>优点</p><p>双亲委派让类加载器之间具有优先级的层级关系，使得Java基础类稳定运行，避免类重复加载。</p><p>由于最终都是委派给启动类加载器类进行加载，因此Object类在程序的各种类加载器中都能保证是同一个类，而没有双亲委派模型，任由各个类加载器自行加载，我们自行编写一个Object类放到ClassPath中，系统中就会出现多个不同的Object类，导致Java体系的基础无从保证。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;</summary>
      
    
    
    
    <category term="后端" scheme="http://aidianfirst.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Java八股文-容器</title>
    <link href="http://aidianfirst.com/2021/09/30/%E5%85%AB%E8%82%A1/Java%E5%85%AB%E8%82%A1%E6%96%87-%E5%AE%B9%E5%99%A8/"/>
    <id>http://aidianfirst.com/2021/09/30/%E5%85%AB%E8%82%A1/Java%E5%85%AB%E8%82%A1%E6%96%87-%E5%AE%B9%E5%99%A8/</id>
    <published>2021-09-30T10:02:03.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器对比"><a href="#容器对比" class="headerlink" title="容器对比"></a>容器对比</h1><h2 id="集合框架简述"><a href="#集合框架简述" class="headerlink" title="集合框架简述"></a>集合框架简述</h2><ul><li>Collection<ul><li>List：有序，可重复。ArrayList、LinkedList</li><li>Set：无序，无重复。HashSet、TreeSet</li><li>Queue（Deque）：队列，有序，可重复。LinkedList、PriorityQueue</li></ul></li><li>Map：键值对key-value存储，一个键对应一个值。HashMap、TreeMap、HashTable、ConcurrentHashMap</li></ul><h2 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h2><ul><li><p><strong>线程安全：</strong>二者都不保证线程安全，Vector可以实现线程安全。</p></li><li><p><strong>底层数据结构：</strong></p><p>ArrayList对应数组。</p><p>LinkedList对应双向链表，每个结点有前驱后继两个指针。</p></li><li><p>查找操作多使用ArrayList，插入、删除操作多使用LinkedList。</p></li><li><p><strong>内存空间占用：</strong></p><p>ArrayList由于是数组实现，会预留一定容量空间。整体空间占比高。</p><p>LinkedList每一个元素空间占比更高，因为有前驱后继两个指针。</p></li><li><p><strong>实现RandomAccess接口</strong></p><p>由于ArrayList具有快速随机访问的功能，所以它实现了RandomAccess接口，但RandomAccess接口是没有内容定义的，仅仅是一个标识，代表可以快速随机访问，相对的LinkedList没有实现接口，因为其本身就不具有快速随机访问的功能，所以没有这个标识。</p><p>RandomAccess仅仅只是一个标识，并不是说实现这个接口就具有快速随机访问功能。</p></li></ul><h2 id="HashMap与HashTable区别"><a href="#HashMap与HashTable区别" class="headerlink" title="HashMap与HashTable区别"></a>HashMap与HashTable区别</h2><ul><li><p><strong>线程安全：</strong></p><p>HashMap非线程安全，HashTable内部方法有synchronized处理是线程安全的，但要保证线程安全推荐使用ConcurrentHashMap。</p></li><li><p><strong>效率：</strong>由于线程安全问题，HashMap比HashTable效率高，HashTable基本被淘汰。</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong></p><p>HashMap键值对可存储空值，HashTable不允许键值对存储空值，会抛出空指针异常。</p></li><li><p><strong>底层数据结构：</strong></p><p>HashMap1.7是数组+链表，1.8数组+链表+红黑树</p><p>HashTable是数组+链表</p></li><li><p><strong>初始容量以及扩容大小：</strong></p><ul><li>初始不指定容量<ul><li>HashTable默认初始大小11，每次扩容容量变为原来的2n+1</li><li>HashMap默认初始大小16，每次扩容变为原来2倍</li></ul></li><li>创建时指定初始容量<ul><li>HashTable直接使用给定的容量大小</li><li>HashMap会以给定容量为基础，扩充为2的幂的大小，因为HashMap的大小要保证是2的幂，为了提高算法效率使用按位与计算，必须是2的幂</li></ul></li></ul></li></ul><h2 id="HashMap与HashSet区别"><a href="#HashMap与HashSet区别" class="headerlink" title="HashMap与HashSet区别"></a>HashMap与HashSet区别</h2><p>HashSet底层其实是基于HashMap实现。</p><p>HashMap存储键值对，键唯一，使用键计算hashcode。</p><p>HashSet只存储对象，通过成员对象计算hashcode，但hashcode可能相同，一般使用equals()判断两个对象是否相同。</p><h2 id="ConcurrentHashMap与HashTable区别"><a href="#ConcurrentHashMap与HashTable区别" class="headerlink" title="ConcurrentHashMap与HashTable区别"></a>ConcurrentHashMap与HashTable区别</h2><p>主要体现在实现线程安全的方式不同。</p><p>HashTable使用全表锁，所有数据争夺一把锁，效率及其低下。</p><p><strong>ConcurrentHashMap（jdk1.7）</strong>使用分段锁，对桶数组进行分段，拆分成<strong>Segment</strong>数组，一个Segment包含多个HashEntry，也就是多个数组结点，这样每把锁就对应部分数据，减少锁竞争问题，提高并发访问效率。</p><p><strong>ConcurrentHashMap（jdk1.8）</strong>取消了Segment分段锁，<strong>采用CAS 和 synchronized</strong>来保证并发安全，数据结构和HashMap1.8一样。而操作对象由原本的Segment变为HashEntry，直接操作数组结点</p><p>CAS对应乐观锁，synchronized对应悲观锁，使用乐观锁进一步提高效率，当乐观锁失效时在采用悲观锁。也就是检测到并发冲突再加锁。</p><h1 id="ArrayList底层实现"><a href="#ArrayList底层实现" class="headerlink" title="ArrayList底层实现"></a>ArrayList底层实现</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>无参初始化：初始化为一个空数组，然后在执行第一个添加操作时进行扩容，容量变为10，扩容我们后面会细说。</li><li>有参初始化：初始化一个指定大小的数组。</li><li>参数为Collection的初始化：复制该集合的元素，不常用。</li></ul><h2 id="扩容机制（一般扩容1-5倍）"><a href="#扩容机制（一般扩容1-5倍）" class="headerlink" title="扩容机制（一般扩容1.5倍）"></a>扩容机制（一般扩容1.5倍）</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现add就是数组赋值并索引递增，但前提是执行ensureCapacityInternal方法。我们再来看看这个方法是干什么的。</p><h3 id="ensureCapacityInternal"><a href="#ensureCapacityInternal" class="headerlink" title="ensureCapacityInternal"></a>ensureCapacityInternal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以解释空数组的初始扩容为什么是10，ArrayList定义了默认容量10以及size变量，size是默认值0，这里我们初始化无参数组后，首次执行add方法，它会调用 ensureCapacityInternal(size + 1) 其中参数是1，也就是说 ensureCapacityInternal 方法的最小容量参数首次添加时为1。</p><p>然后按层次先执行 calculateCapacity方法，当当前数组为空时，它会比较数组的最小容量与默认容量，取较大值返回，不是空数组则返回最小容量。这里空数组会返回默认容量10。</p><p>接着执行 ensureExplicitCapacity方法 ，若最小容量大于数组长度则执行 grow方法进行扩容。这里首次无参初始化的空数组，其传入的最小容量参数大于空数组长度0相等，会进行第一次扩容。</p><p>其中modCount用于记录修改次数，为多线程服务，这里单线程就不用关心了。</p><h3 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里grow方法先是获取当前数组长度，将原长度&gt;&gt;1即除2，所以数组扩容为原来的1.5倍左右（奇数有损），然后比较扩容后长度与当前传入的最小容量参数，返回较大值。接着就对最大界限进行了限制。最后执行Arrays.copyOf，创建一个新数组，其长度设置为扩容容量，并把现在的元素复制过去。</p><h2 id="复制操作"><a href="#复制操作" class="headerlink" title="复制操作"></a>复制操作</h2><p>我们在扩容时往往是新建一个数组，把原本数组内容copy过去，会经常使用 Arrays.copyOf 和 System.arraycopy 这两个方法，这里来分析一下。</p><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf"></a>Arrays.copyOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他数组类似，这里选择了整数型数组，copy操作就是创建一个扩容容量的新数组，然后调用 System.arraycopy 进行复制最后返回新的数组。注意最后一个参数取要复制的数组长度，因为是要复制的数组，也就是待扩容的，肯定长度较小，所以取min。</p><h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>选择源数组的指定索引后的内容，然后从目标数组的指定索引处开始复制过来，长度代表要复制的数量。</p><h2 id="ensureCapacity"><a href="#ensureCapacity" class="headerlink" title="ensureCapacity"></a>ensureCapacity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是由用户自行调用的，ArrayList中并没有调用过。我们在进行大量add操作时可以先调用该方法，此时传入的是 add的操作次数。也就是说我们执行100000次add，先调用该方法，会在add操作执行前就用执行的总次数调用 ensureExplicitCapacity方法，先对数组进行扩容，我们传入的最小容量就是执行次数，这样就不用在执行add时频繁扩容，减少了时间的消耗。</p><h1 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h1><h2 id="HashMap为什么长度是2的幂"><a href="#HashMap为什么长度是2的幂" class="headerlink" title="HashMap为什么长度是2的幂"></a>HashMap为什么长度是2的幂</h2><p>这个属于HashMap的经典问题了，不得不说似懂非懂的人太多了，许多博客都在瞎讲，这里我就讲讲自己对这个问题的理解。（推荐看guide哥的容器讲解，这个点讲的很对）</p><h3 id="与-amp"><a href="#与-amp" class="headerlink" title="% 与 &amp;"></a>% 与 &amp;</h3><p>相信大家都知道，计算机在处理% 和 &amp;这两个运算符时，&amp;的效率是高于%的，因为&amp;是二进制计算，计算机处理效率更高。</p><h3 id="HashMap的算法"><a href="#HashMap的算法" class="headerlink" title="HashMap的算法"></a>HashMap的算法</h3><p>我们一般用算法处理散列值的分配问题，好的算法就可以有效降低hash冲突的发生。在HashMap中就是<strong>先用哈希值与数组长度取余，再存放到对应数组下标</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashCode % length</span><br></pre></td></tr></table></figure><p>而取余运算是可以转化为按位与的（<strong>前提为length是二进制数</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashCode &amp; (length - 1)</span><br></pre></td></tr></table></figure><p>这么看来只有当数组长度是2的幂时，才能将取余运算转换为按位与，然后我们便可大大提升运算效率，<strong>所以HashMap长度要是2的幂，每次扩容*2</strong>。</p><h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h3><p>由前两个分析来看，如果当数组长度是2的幂时，我们发现lenth-1的值会变成低位全为1的二进制数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length:  10000</span><br><span class="line">length-1: 01111</span><br></pre></td></tr></table></figure><p>此时我们再用散列值与这个低位全为1的二进制数进行与运算，并与其他情况对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01111011110100101001</span><br><span class="line">10101100111010110011</span><br><span class="line">--------------------</span><br><span class="line">00101000110000100001</span><br></pre></td></tr></table></figure><p>可以发现同样的数据，全为1按位与后的值冲突更不易发生。</p><p>这也是因为&amp;的特性导致的，&amp;计算的4种情况：00、01、10、11，结果是3个0，1个1，所以为了减少冲突我们尽量让值成为1，所以数组的长度要尽量全为1。</p><p>通过上述分析我们也可以理解为什么要让数组长度为2的幂，其length-1后是低位全1的二进制数，不仅加快了运算效率，而且不易产生hash冲突。 </p><h2 id="HashMap底层与红黑树"><a href="#HashMap底层与红黑树" class="headerlink" title="HashMap底层与红黑树"></a>HashMap底层与红黑树</h2><p>其实我一开始看Java并没有看集合类，毕竟学过数据结构，线性表、栈、队列、树、图、散列等底层我还是了解的，但在看面经的过程中，我突然发现了HashMap、红黑树这几个陌生的词汇经常被考察，所以我就去了解了一下。</p><p>了解后，我发现红黑树其实就是简易版的AVL树，也就是平衡二叉树，说简易版可能有点过了，红黑树只是没有AVL那么严格，但它也是通过结点的左旋、右旋来达到平衡状态的。二者相比下，AVL是树的高度平衡，查找效率高；而红黑树是高度平衡相差一层，但其插入删除操作的效率更高。</p><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p>数组+链表，发生哈希冲突时，将冲突元素存放到对数组的链表，使用头插法插入，但在多线程进行扩容操作时，使用头插法会形成环。</p><p><strong>多线程头插法为什么形成环</strong>，比方一个数组索引有三个冲突元素123，则依次头插法插入链表，变成321，而扩容后形成的新数组我们要把现在的元素移过去，再次使用头插就变成了123，这是单线程下的扩容。而多线程下扩容时，第一个线程执行完后轮到第二个线程，但因为头插法的影响导致扩容后的链表顺序发生了改变，之后再按原先的顺序操作就会出现环，导致死锁的发生。</p><p>总结就是头插法容易逆序+环形链表死循环，放一个视频讲解：</p><p><a href="https://www.bilibili.com/video/BV1n541177Ea?from=search&amp;seid=4027342742461950529">https://www.bilibili.com/video/BV1n541177Ea?from=search&amp;seid=4027342742461950529</a></p><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>数组+链表+红黑树，发生哈希冲突也会放入链表，使用的尾插法，但当链表长度超过8时，会将其数据结构转换为红黑树以提高效率。当链表长度小于6时，由红黑树转回链表。</p><p><strong>为什么当链表长度超过8转换为红黑树</strong>，因为当我们的算法足够好，链表达到8个结点的概率是非常低的，冲突能达到8说明当前算法不够好，导致散列不均匀，此时相对于特殊情况，我们需要转化成红黑树提高效率。</p><p><strong>为什么红黑树转变成链表的阙值是6</strong>，如果阙值设为8，一个删除和添加操作就会频繁的进行链表和红黑树的转换，所以设置退化的阙值为6，阙值不可太临界。 </p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>刚刚说过jdk1.7使用头插会导致在多线程操作时死锁，就算jdk1.8使用了尾插，HashMap还是多用于单线程，在并发情况下建议使用ConcurrentHashMap。</p><h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>众所周知HashMap负载因子是0.75，但这是为什么呢？首先我们要知道负载因子是用来衡量HashMap何时该扩容的，当HashMap中元素超过 数组长度 * 负载因子 就要进行2倍扩容。负载因子相当于一个容量界限。</p><p>如果负载因子是1，相对于数组占满时扩容，其时间利用率低空间利用率高，属于时间换空间，而负载因子为0.5时，数组占一半就要扩容，这时扩容会造成空间的浪费，属于空间换时间。所以我们综合并根据算法选择负载因子是0.75，此时时间、空间利用率比较均衡。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树可以理解成没有那么严格的平衡二叉树（AVL），它并不是完全平衡的，因此旋转次数也相应减少。但使用红黑树进行增删操作，效率是高于AVL的。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li>结点为红/黑</li><li>根结点为黑</li><li>叶子结点是黑色空结点null</li><li>每个红色结点的两个子结点均为黑色，不存在两个相连的红色结点</li><li>从任意结点到每个叶子结点的所有路径都包含相同数目的黑色结点</li></ul><h2 id="自平衡（旋转-变色）"><a href="#自平衡（旋转-变色）" class="headerlink" title="自平衡（旋转 + 变色）"></a>自平衡（旋转 + 变色）</h2><p><strong>注意插入的结点一定是红色的。</strong></p><p>红黑树在执行添加与删除操作时，如果破坏了红黑树的规则，那么红黑树会和AVL一样，通过旋转进行自平衡，并且还要进行变色操作。这里就体现了红黑树与AVL的区别，AVL是明确规定树的深度差不超过1作为平衡条件，而红黑树巧妙的将规则设定为平衡条件，省去了许多繁琐的操作步骤。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;容器对比&quot;&gt;&lt;a href=&quot;#容器对比&quot; class=&quot;headerlink&quot; title=&quot;容器对比&quot;&gt;&lt;/a&gt;容器对比&lt;/h1&gt;&lt;h2 id=&quot;集合框架简述&quot;&gt;&lt;a href=&quot;#集合框架简述&quot; class=&quot;headerlink&quot; title=&quot;集合框架简</summary>
      
    
    
    
    <category term="八股" scheme="http://aidianfirst.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ简单学习</title>
    <link href="http://aidianfirst.com/2021/09/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aidianfirst.com/2021/09/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-21T08:45:27.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>RabbitMQ基于erlang，我们需要先安装erlang。</p><p>erlang：<a href="https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm">https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm</a></p><p>RabbitMQ：<a href="https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm">https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p><p>也可以使用费其他版本，centos8就要使用el8，按自己情况来，然后进入界面右上角点击下载（最开始找半天，没看到下载按钮😂），然后可以使用xftp传到linux的文件夹中，我放在/usr/local/software。</p><ul><li><p><strong>安装命令，按序执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p><strong>基本指令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on# 开机启动服务设置</span><br><span class="line">/sbin/service rabbitmq-server start# 自行启动服务</span><br><span class="line">/sbin/service rabbitmq-server status# 查看服务状态</span><br><span class="line">/sbin/service rabbitmq-server stop# 停止运行</span><br></pre></td></tr></table></figure></li><li><p><strong>启动web管理插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要在mq服务停止时启动，然后再开启mq则插件生效</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>然后访问本机地址的15672端口，<a href="http://192.168.158.134:15672/%EF%BC%8C%E6%B3%A8%E6%84%8F%E9%9C%80%E8%A6%81%E5%85%88%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%EF%BC%8C%E6%88%96%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E3%80%82">http://192.168.158.134:15672/，注意需要先开放端口，或关闭防火墙。</a></p></li><li><p><strong>用户管理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置账号密码</span></span><br><span class="line">rabbitmqctl add_user admin 111</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置账号的角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置角色的权限，根目录下全部可读可写可执行</span></span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有账号</span></span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li><li><p><strong>代码实现</strong></p><p>我们通过Java来具体实现MQ的操作流程，先导入相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-nop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-nop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="生产消费者简单模式（Hello-World）"><a href="#生产消费者简单模式（Hello-World）" class="headerlink" title="生产消费者简单模式（Hello World）"></a>生产消费者简单模式（Hello World）</h1><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/27.png" alt="27.png"></p><p>一个生产者P通过队列queue发送信息，消费者C接收信息</p><p><strong>具体流程：</strong></p><ul><li>创建连接工厂对象</li><li>创建连接获取信道</li><li>通过信道创建消息队列</li><li>进行消息的发送与接收操作</li></ul><h2 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列name</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.158.135&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取连接的信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过信道创建队列声明queueDeclare</span></span><br><span class="line"><span class="comment">         * 1、队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable：队列是否持久化</span></span><br><span class="line"><span class="comment">         * 3、exclusive：队列是否排他</span></span><br><span class="line"><span class="comment">         * 4、autoDelete：队列是否自动删除</span></span><br><span class="line"><span class="comment">         * 5、argurnents：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  发送消息</span></span><br><span class="line"><span class="comment">         *  1、交换机名，不使用交换机则为&quot;&quot;</span></span><br><span class="line"><span class="comment">         *  2、发送信息的队列（RoutingKey）</span></span><br><span class="line"><span class="comment">         *  3、其他参数</span></span><br><span class="line"><span class="comment">         *  4、发送的消息体，必须是byte数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.158.135&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式简单编写回调接口</span></span><br><span class="line">        <span class="comment">//只需要返回消息体，若返回message则是一个地址</span></span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者接收消息</span></span><br><span class="line"><span class="comment">         * 1、队列名称</span></span><br><span class="line"><span class="comment">         * 2、autoAck：是否自动接收消息</span></span><br><span class="line"><span class="comment">         * 3、deliverCallback：消息的回调接口</span></span><br><span class="line"><span class="comment">         * 4、cancelCallback：消费者取消订阅时的回调函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作队列模式（Work-Queues）"><a href="#工作队列模式（Work-Queues）" class="headerlink" title="工作队列模式（Work Queues）"></a>工作队列模式（Work Queues）</h1><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/28.png" alt="28.png"></p><p>一个生产者通过队列发送大量消息，有多个消费者进行消息接收，其中队列唯一，而消费者不会重复处理消息，通过轮询的方式对消息进行处理。</p><p>我们可以在idea里选择多次运行消费者，然后在生产者中手动发送信息，会发现多个消费者轮询获取信息。</p><h2 id="通用信道工具类"><a href="#通用信道工具类" class="headerlink" title="通用信道工具类"></a>通用信道工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.158.135&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">workProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;WorkQueues&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息成功:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">workConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;WorkQueues&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的消息:&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------C2等待接收信息------------&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><p>为了保证MQ的消息在发送过程中不丢失，需要进行消息应答，即消费者在接收消息并处理消息后，会告诉MQ一处理消息，此时MQ才可以将消息进行删除。</p><p>一般分为自动应答与手动应答，我们推荐使用手动应答。</p><ul><li><p>应答的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确认</span></span><br><span class="line">channel.basicAck(···);</span><br><span class="line"><span class="comment">//不确认</span></span><br><span class="line">channel.basicNack(···);</span><br><span class="line"><span class="comment">//不确认，相比Nack，Reject少了一个参数</span></span><br><span class="line">channel.basicReject(···);</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息手动应答（推荐）"><a href="#消息手动应答（推荐）" class="headerlink" title="消息手动应答（推荐）"></a>消息手动应答（推荐）</h2><p>可以发现消费者1、2和最开始的工作队列模式一样是轮询获取信息，但一个处理快，一个处理慢，如果我们把处理慢的消费者宕机，由于打开了消息手动应答，本应由消费者2处理的消息不会丢失，而是由消费者1进行处理。生产者和一开始使用的工作队列模式的一致，只需要改变消费者。</p><ul><li><p>消费者1，处理时间短，使用手动应答与线程休眠</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ackConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;WorkQueues&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待处理，处理时间短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//休眠1s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的消息:&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答，basicAck肯定</span></span><br><span class="line"><span class="comment">             * 1、消息的标记，类似数组索引</span></span><br><span class="line"><span class="comment">             * 2、是否批量应答</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2，处理时间长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ackConsumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;WorkQueues&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待处理，处理时间长&quot;</span>);</span><br><span class="line"><span class="comment">//改为休眠20s，其余与消费者1一致</span></span><br><span class="line">···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="不公平分发（开启预取值）"><a href="#不公平分发（开启预取值）" class="headerlink" title="不公平分发（开启预取值）"></a>不公平分发（开启预取值）</h2><p>默认prefetchCount = 0，此时消费者对信息进行轮询处理，自定义prefetchCount&gt;0时，并通过信道的basicQos进行设置，则规定了每一个队列的当前看处理信息的最大数。也就说还是执行轮询操作，但某个消费者信息处理时不应答造成信息阻塞，这个阻塞队列的最大值即prefetchCount，当阻塞数据超过最大值，则该消费者不再接收新消息。而后续消息全由有空闲的消费者处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不公平分发</span></span><br><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建队列时，第二个参数durable设为true开启持久化</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//发布消息时，第二个参数进行响应的设置，实现消息持久化</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure><h2 id="发布与确认"><a href="#发布与确认" class="headerlink" title="发布与确认"></a>发布与确认</h2><p>当我们将队列以及消息进行持久化操作后，信息需要存储到磁盘上才可完成持久化操作，若存储到磁盘的过程发生了宕机，那么持久化也是失败的，所以我们还需要对信息进行发布与确认，保证信息持久化成功。</p><p>一般分为以下三种模式：</p><ul><li><p>单一确认：每发送一条消息就进行一次确认，效率低</p></li><li><p>批量确认：发送多条消息后，再进行一次确认</p></li><li><p>异步确认：先将消息全部发送，随后由broker进行确认并返回信息，相当于一个消息的监听器，生产者再将未确认的消息进行重新发送</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">confirmMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">//消息的数据量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_COUNT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        confirmMessage.singlePublish();             <span class="comment">//单一</span></span><br><span class="line">        confirmMessage.batchPublish();              <span class="comment">//批量</span></span><br><span class="line">        confirmMessage.asynchronousAllPublish();    <span class="comment">//异步批量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单一确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">singlePublish</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布与确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++)&#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;条数据，单一处理需要耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">batchPublish</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">//批量确认的消息数量限制</span></span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++)&#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">//消息发送达到限制时，需进行一次确认</span></span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;条数据，批量处理需要耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">asynchronousAllPublish</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置成功的消息监听器</span></span><br><span class="line">        ConfirmCallback ackCallback = (<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> mutiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//过滤确认消息，留下未确认的</span></span><br><span class="line">            <span class="keyword">if</span>(mutiple)&#123;</span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirm = map.headMap(deliveryTag);</span><br><span class="line">                confirm.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置失败的消息监听器</span></span><br><span class="line">        ConfirmCallback nackCallback = (<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> mutiple) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//异步通知</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++)&#123;</span><br><span class="line">            String message = <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">//记录所有要发送的消息，随后在监听器中删除一确认的消息，留下未确认的</span></span><br><span class="line">            map.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;条数据，异步处理需要耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Exchanges交换机"><a href="#Exchanges交换机" class="headerlink" title="Exchanges交换机"></a>Exchanges交换机</h1><ul><li>默认交换机：代码中就是使用””空字符串，即不使用</li><li>直连交换机direct：对应路由模式，使用RoutingKey匹配队列</li><li>主题交换机topic：对应主题模式</li><li>首部交换机headers</li><li>扇出交换机fanout ：对应发布与订阅模式，相当于广播</li></ul><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>也就是没有实现持久化的队列，其名字随机，断开消费者连接后，队列会自动删除。用完即删。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><h1 id="订阅与发布模式（Publish-Subscribe）"><a href="#订阅与发布模式（Publish-Subscribe）" class="headerlink" title="订阅与发布模式（Publish/Subscribe）"></a>订阅与发布模式（Publish/Subscribe）</h1><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/29.png" alt="29.png"></p><p>一个生产者，一个交换机，多个队列以及多个消费者。生产者的消息不会直接发送给队列，而是通过交换机对消息完成分配。将接收的消息通过广播的形式发送给所有队列。也就是不考虑RoutingKey的影响。没有设置RoutingKey。也就是交换机的fanout扇出类型的实现。</p><h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fanoutProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;fanout&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><p>多个相同的消费者，会通过交换机同时接收到消息，也就是fanout交换机实现了广播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fanoutConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;fanout&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机，1、交换机名，2、交换机类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机与队列，1、队列名，2、交换机名，3、RoutingKey</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待消息进行接收···&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1号测试接收的消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路由模式（Routing）"><a href="#路由模式（Routing）" class="headerlink" title="路由模式（Routing）"></a>路由模式（Routing）</h1><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/30.png" alt="30.png"></p><p>基于发布与订阅模式，只是交换机类型改为使用directt，交换机发送消息根据绑定的RoutingKey来分配队列。主要RoutingKey匹配的队列都会接收消息，所以若全部队列的RoutingKey一致，就相当于fanout类型进行广播。</p><h2 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h2><p>我们发送信息时，给交换机分配不同的RoutingKey，就会发送给相对应的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">directProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;222&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">directConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待消息进行接收···&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1号测试接收的消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主题模式（Topics）"><a href="#主题模式（Topics）" class="headerlink" title="主题模式（Topics）"></a>主题模式（Topics）</h1><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/31.png" alt="31.png"></p><p>由于路由模式使用direct，其消息是一一对应发送的，有一定的局限性，因为RoutingKey统一，我们队列不能同时接收多个不同的RoutingKey。例如我们队列想接收 tc.name 与 tc.age 这两个消息，但使用direct只能明确指明其中一种，此时就要使用topic主题模式，相当于对RoutingKey进行模糊化处理，匹配全部相关联的RoutingKey进行发送。</p><p>即使一个队列可以匹配多个RoutingKey，但同一个队列每次只能接收一次消息。</p><h2 id="定义以及模糊匹配"><a href="#定义以及模糊匹配" class="headerlink" title="定义以及模糊匹配"></a>定义以及模糊匹配</h2><p>主题模式的RoutingKey必须是一个单词列表，通过 . 进行分割，最多255字节。例如 tc.name、tc.age这样定义，一般带有一定的指向性。然后topic中就可以使用类似sql的通配符进行模糊匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 代表任意一个词</span><br><span class="line"># 可代表0或多个单词</span><br></pre></td></tr></table></figure><p>也就是说RoutingKey定义为 tc.* ，可以同时匹配tc.name 和 tc.age。 </p><p>*<em>注意若只绑定#，就相当于fanout类型，因为都可以匹配。而绑定的RoutingKey没有出现 <em>或#，说明没有做模糊匹配处理，就相当于direct类型。可以说topic包括了fanout与direct。</em></em></p><h2 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topicProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        HashMap&lt;String, String&gt; bindMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bindMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;Q1、Q2&quot;</span>);</span><br><span class="line">        bindMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;Q1、Q2&quot;</span>);</span><br><span class="line">        bindMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;Q1&quot;</span>);</span><br><span class="line">        bindMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;Q2&quot;</span>);</span><br><span class="line">        bindMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;Q2&quot;</span>);</span><br><span class="line">        bindMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        bindMap.put(<span class="string">&quot;quick.orange.male.rabit&quot;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        bindMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;Q2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : bindMap.entrySet())&#123;</span><br><span class="line">            String RoutingKey = entry.getKey();</span><br><span class="line">            String info = entry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, RoutingKey, <span class="keyword">null</span>, info.getBytes() );</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h2><p>测试后可以发现交换机按照模糊匹，向队列发送消息。</p><p>一个消费者可以绑定多个RoutingKey。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topicConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        String queueName = <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息······&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Q1队列接收的消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的队列是&quot;</span> + queueName + <span class="string">&quot;，绑定的Key是&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h1><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/32.png" alt="32.png"></p><h1 id="死信队列（DLX）"><a href="#死信队列（DLX）" class="headerlink" title="死信队列（DLX）"></a>死信队列（DLX）</h1><p>死信（dead-letter-exchange）即无法被消费的消息，例如我们微信付款，有一个付款时间，超过时间的付款应归为死信，需要由原队列推给死信队列进行处理。一般成为死信有以下几种情况：</p><ul><li>消息被拒绝：被正常队列拒绝，则归为死信</li><li>消息TTL过期：直到时间过期，仍未接收到消息则归为死信</li><li>队列达到最大长度：当消息超过队列的最大长度时，归为死信</li></ul><p>测试时，先将正常消费者启动创建需要的队列，然后停掉消费者，启动生产者，最后启动死信队列消费者查看死信队列的情况。</p><h2 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        <span class="comment">// 死信消息，设置TTL时间，若测试最大长度则要注释掉TTL</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)&#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;normal&quot;</span>, properties, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者-4"><a href="#消费者-4" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常队列消费者，需要关联死信队列</span></span><br><span class="line"><span class="comment">// 这里模拟了TTL和最大长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE = <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在要将普通队列与死信队列关联起来，方便死信消息的处理</span></span><br><span class="line">        <span class="comment">// 需要对最后一个参数进行设置</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为普通队列设置对应的死信交换机以及死信的RoutingKey</span></span><br><span class="line">        <span class="comment">// 注意这里键是规定好的</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可设置最大长度，超过长度的消息归为死信</span></span><br><span class="line">        <span class="comment">// arguments.put(&quot;x-max-length&quot;, 6);</span></span><br><span class="line">        </span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">&quot;normal&quot;</span>);</span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer1接收的消息是：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;&#125;;</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死信队列消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXConsumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = ChannelUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer2接收的消息是：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        CancelCallback cancelCallback = (String consumerTag) -&gt; &#123;&#125;;</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动拒绝消息，模拟消息拒绝的情况，替换正常消费者的DeliverCallback接口实现即可</span></span><br><span class="line">DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(msg.equals(<span class="string">&quot;info5&quot;</span>) || msg.equals(<span class="string">&quot;info8&quot;</span>) || msg.equals(<span class="string">&quot;info9&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1拒绝的消息是：&quot;</span> + msg);</span><br><span class="line">                <span class="comment">// 拒绝消息，false代表不返回队列</span></span><br><span class="line">                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1接收的消息是：&quot;</span> + msg);</span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">// 注意此时需要使用手动应答</span></span><br><span class="line">channel.basicConsume(NORMAL_QUEUE, <span class="keyword">false</span>, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><p><strong>延迟队列可理解为死信队列中的TTL过期情况</strong>。具体场景如我们网上购票，先确定订单，此时我们占用了一张票，若规定时间内我们没有付款，那么超时后就无法对订单付款，这个票也重新回到代售的状态。限时的短信验证也是延迟队列的运用。</p><p>而我们有两种方式实现延迟队列：</p><ul><li>基于死信队列的TTL实现</li><li>基于官方插件的交换机延迟实现</li></ul><h2 id="整合Spring-Boot依赖以及配置"><a href="#整合Spring-Boot依赖以及配置" class="headerlink" title="整合Spring Boot依赖以及配置"></a>整合Spring Boot依赖以及配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.50<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.136</span></span><br><span class="line">    <span class="comment"># 注意端口不是15672</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">111</span></span><br></pre></td></tr></table></figure><h2 id="基于死信实现的延迟队列（队列延迟）"><a href="#基于死信实现的延迟队列（队列延迟）" class="headerlink" title="基于死信实现的延迟队列（队列延迟）"></a>基于死信实现的延迟队列（队列延迟）</h2><p>整体流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image@main/33.png" alt="33.png"></p><p>我们通过设置队列的TTL失效时间来模拟延迟队列，但有一个缺陷，也就是我们不可能每次都规定好TTL，那么每有一个新TTL就要新增一个队列，这个问题可以使用自定义延时也就是queueC解决，但又有新问题，也就是多个自定义延迟是走同一个队列的，会有队列阻塞的情况发生，也就是当我们先发送一个延时时长较长的消息，后发送一个延时时长较短的消息，那么较短的消息需要等待较长消息处理完后再处理，严格遵守队列的先进先出。</p><ul><li>所有的队列以及交换机的设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通交换机与死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 多个普通队列，延时不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;queueA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;queueB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_C = <span class="string">&quot;queueC&quot;</span>; <span class="comment">//自定义延时</span></span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">&quot;deadQueue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将两个交换机、3个队列全部进行组件声明</span></span><br><span class="line">    <span class="meta">@Bean(&quot;nExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">nExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(NORMAL_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;dExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">dExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DEAD_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">30000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义队列，可满足不同的TTL</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;deadQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通队列与死信队列进行绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABindNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;nExchange&quot;)</span> DirectExchange nExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(nExchange).with(<span class="string">&quot;normalA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBindNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;nExchange&quot;)</span> DirectExchange nExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(nExchange).with(<span class="string">&quot;normalB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueCBindNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;nExchange&quot;)</span> DirectExchange nExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(nExchange).with(<span class="string">&quot;normalC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadQueueBindDead</span><span class="params">(<span class="meta">@Qualifier(&quot;deadQueue&quot;)</span> Queue deadQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@Qualifier(&quot;dExchange&quot;)</span> DirectExchange dExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deadQueue).to(dExchange).with(<span class="string">&quot;dead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者P</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始时间:&#123;&#125;，发送消息给两个TTL队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;normal_exchange&quot;</span>, <span class="string">&quot;normalA&quot;</span>, <span class="string">&quot;10s的TTL队列：&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;normal_exchange&quot;</span>, <span class="string">&quot;normalB&quot;</span>, <span class="string">&quot;40s的TTL队列：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendTTLMsg/&#123;message&#125;/&#123;TTL&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> String TTL)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始时间:&#123;&#125;，发送自定义TTL为&#123;&#125;ms的消息给队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), TTL, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;normal_exchange&quot;</span>, <span class="string">&quot;normalC&quot;</span>, message, msg -&gt;&#123;</span><br><span class="line">            <span class="comment">// 自定义延迟时长</span></span><br><span class="line">            msg.getMessageProperties().setExpiration(TTL);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者C</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">deadQueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;deadQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收时间:&#123;&#125;，收到死信队列的消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ插件实现延迟队列（交换机延迟，推荐）"><a href="#RabbitMQ插件实现延迟队列（交换机延迟，推荐）" class="headerlink" title="RabbitMQ插件实现延迟队列（交换机延迟，推荐）"></a>RabbitMQ插件实现延迟队列（交换机延迟，推荐）</h2><p>github：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0</a></p><p>下载官方插件，将压缩包放到MQ的插件目录 /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins ，然后重启MQ，随后我们在Web管理界面的交换机类型中看见 x-delayed-message ，也就是官方插件的延迟队列实现。</p><p>插件实现延迟，整体流程更简单，仅仅只需要一个队列和一个交换机。由交换机内部进行延时的设定，所以我们要对交换机进行参数配置。</p><p>完成插件延迟队列后，不会出现TTL那种同一个队列拥塞的情况。所以推荐使用插件实现延迟队列。</p><ul><li>插件声明队列与延迟交换机</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE = <span class="string">&quot;delayed_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE = <span class="string">&quot;delayed_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed_routing_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明自定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里其他参数代表直连的延迟类型，下面指这个是延迟消息</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、交换机名称</span></span><br><span class="line"><span class="comment">         * 2、交换机类型</span></span><br><span class="line"><span class="comment">         * 3、是否持久化</span></span><br><span class="line"><span class="comment">         * 4、是否自动删除</span></span><br><span class="line"><span class="comment">         * 5、其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedBind</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;开始时间:&#123;&#125;，发送插件延时为&#123;&#125;ms的消息给队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), delayTime, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE, DelayedQueueConfig.DELAYED_ROUTING_KEY, message, msg -&gt;&#123;</span><br><span class="line">        <span class="comment">// 自定义延迟时长ms</span></span><br><span class="line">        msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插件延迟消费者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">delayQueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收时间:&#123;&#125;，收到死信队列的消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发布与确认进阶"><a href="#发布与确认进阶" class="headerlink" title="发布与确认进阶"></a>发布与确认进阶</h1><p>若RabbitMQ服务器发生宕机，其重启期间生产者消息发送失败，导致消息丢失，此时我们需要手动恢复消息。也就是说生产者发送消息时，交换机或队列收不到消息该如何处理。</p><p><strong>就是当交换机与RoutingKey有错误时，可自定义错误的输出，方便我们查看哪一步出错，进而执行消息重发操作。</strong></p><h2 id="交换机确认消息（交换机匹配错误返回失败情况）"><a href="#交换机确认消息（交换机匹配错误返回失败情况）" class="headerlink" title="交换机确认消息（交换机匹配错误返回失败情况）"></a>交换机确认消息（交换机匹配错误返回失败情况）</h2><p>交换机判断消息的接收情况，执行回调方法的确认消息</p><ul><li>yml配置文件开启发布确认模式</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li>配置交换机与队列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE = <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE = <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY = <span class="string">&quot;routing1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(CONFIRM_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bind</span><span class="params">(Queue confirmQueue,DirectExchange confirmExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回调方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息的回调接口，判断消息的接收情况</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本方法是RabbitTemplate的一个实现类，我们只是实现了接口</span></span><br><span class="line">    <span class="comment">// 但是RabbitTemplate并没有注入这个实现类</span></span><br><span class="line">    <span class="comment">// 所以我们使用@PostConstruct注解在进行注入</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机的确认回调方法</span></span><br><span class="line"><span class="comment">     * 1、保存回调消息的ID及相关信息</span></span><br><span class="line"><span class="comment">     * 2、是否接收到消息</span></span><br><span class="line"><span class="comment">     * 3、失败的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String ID = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已收到ID为&#123;&#125;的消息&quot;</span>, ID);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机没有收到ID为&#123;&#125;的消息，其原因是&#123;&#125;&quot;</span>, ID, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendConfirmMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span></span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息为：&#123;&#125;&quot;</span>, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(AdvancedConfig.CONFIRM_EXCHANGE, AdvancedConfig.ROUTING_KEY, message, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">confirmConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = AdvancedConfig.CONFIRM_QUEUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recive</span> <span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收发布队列的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回退消息（返回key失败消息的信息）"><a href="#回退消息（返回key失败消息的信息）" class="headerlink" title="回退消息（返回key失败消息的信息）"></a>回退消息（返回key失败消息的信息）</h2><ul><li>yml配置文件开启回退</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>回退接口，在myCallBack中增加方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 注入一下</span></span><br><span class="line">    rabbitTemplate.setReturnsCallback(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage message)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息：&#123;&#125;，被交换机&#123;&#125;回退，回退原因：&#123;&#125;，路由key：&#123;&#125;&quot;</span>, <span class="keyword">new</span> String(message.getMessage().getBody()), message.getExchange(), message.getReplyText(), message.getRoutingKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>生产者</li></ul><p>此时routingKey有错误，会进行回退操作，也就是返回失败消息的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendConfirmMsg/&#123;message&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span></span>&#123;</span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;发送消息为：&#123;&#125;&quot;</span>, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(AdvancedConfig.CONFIRM_EXCHANGE, AdvancedConfig.ROUTING_KEY + <span class="string">&quot;1&quot;</span>, message, correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/34.png" alt="34.png"></p><p><strong>备份交换机优先级高于回退，优先备份，失败则进行回退。</strong></p><ul><li>队列与交换机配置</li></ul><p>在之前的配置中补上即可，注意备份模式是fanout，广播给备份队列和警告队列，无需RoutingKey。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedConfig</span> </span>&#123;</span><br><span class="line">    ·····</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACK_UP_EXCHANGE = <span class="string">&quot;back_up_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACK_UP_QUEUE = <span class="string">&quot;back_up_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE = <span class="string">&quot;warning_queue&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACK_UP_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backupQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACK_UP_EXCHANGE).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupBind</span><span class="params">(Queue backupQueue,FanoutExchange backupExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">warningBind</span><span class="params">(Queue warningQueue,FanoutExchange backupExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者</li></ul><p>备份队列消费者就是之前的发布确认的消费者，这里警告队列需要一个新的警告消费者。</p><p>然后通过错误的路由key查看警告处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">warningConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = AdvancedConfig.WARNING_QUEUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recive</span> <span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;警告：发现消息&#123;&#125;，存在路由问题&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;RabbitMQ基于erlang，我们需要先安装erlang。&lt;/p&gt;
&lt;p&gt;erlang：&lt;a href=&quot;https://package</summary>
      
    
    
    
    <category term="中间件" scheme="http://aidianfirst.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="学习" scheme="http://aidianfirst.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="MQ" scheme="http://aidianfirst.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单学习</title>
    <link href="http://aidianfirst.com/2021/09/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/Docker%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aidianfirst.com/2021/09/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/Docker%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-12T14:15:40.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><ul><li><p><strong>卸载旧版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li><li><p><strong>安装包与镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装包</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像仓库，可使用官方文档或阿里云的镜像</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以先更新软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p><strong>启动及基本操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> start启动</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行hello-world，若没有对应镜像会先拉取镜像</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p><strong>卸载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载</span></span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动删除资源，/var/lib/docker默认路径</span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure></li><li><p>使用阿里云给容器镜像加速</p><p><a href="https://cr.console.aliyun.com/cn-chengdu/instances/mirrors">https://cr.console.aliyun.com/cn-chengdu/instances/mirrors</a></p><p>使用对应的命令配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://wl2q99bq.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>镜像启动流程</p><ul><li>docker现在本地查找镜像，有就直接使用</li><li>本地镜像查找不到，就去Docker Hub上下载镜像</li><li>查找到了就下载并使用，官方查找不到则报错</li></ul></li></ul><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p>官网命令：<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li><p><strong>docker images 查看镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    d1165f221234   6 months ago   13.3kB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字段解释</span></span><br><span class="line">REPOSITORY 镜像仓库源</span><br><span class="line">TAG镜像标签</span><br><span class="line">IMAGE ID镜像id</span><br><span class="line">CREATED创建时间</span><br><span class="line">SIZE镜像大小</span><br><span class="line"><span class="meta">#</span><span class="bash"> 相关命令</span></span><br><span class="line">Options:</span><br><span class="line">  -a, --all# 显示全部镜像</span><br><span class="line">  -f, --filter # 根据条件过滤输出</span><br><span class="line">  -q, --quiet# 只显示镜像ID</span><br></pre></td></tr></table></figure></li><li><p><strong>docker search 搜索镜像</strong></p><p>和直接去Docker Hub官网搜索一致。</p></li><li><p><strong>docker pull 下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull 镜像名:tag 可下载对应版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认最新版本下载</span></span><br><span class="line">[root@localhost /]# docker pull mysql</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">a330b6cecb98: Pull complete # 分层下载</span><br><span class="line">9c8f656c32b8: Pull complete </span><br><span class="line">88e473c3f553: Pull complete </span><br><span class="line">062463ea5d2f: Pull complete </span><br><span class="line">daf7e3bdf4b6: Pull complete </span><br><span class="line">1839c0b7aac9: Pull complete </span><br><span class="line">cf0a0cfee6d0: Pull complete </span><br><span class="line">1b42041bb11e: Pull complete </span><br><span class="line">10459d86c7e6: Pull complete </span><br><span class="line">b7199599d5f9: Pull complete </span><br><span class="line">1d6f51e17d45: Pull complete </span><br><span class="line">50e0789bacad: Pull complete </span><br><span class="line">Digest: sha256:99e0989e7e3797cfbdb8d51a19d32c8d286dd8862794d01a547651a896bcf00c</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest # 真实地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定版本下载</span></span><br><span class="line">[root@localhost /]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分层下载，以前下过的组件就不用二次下载了，节省空间</span></span><br><span class="line">a330b6cecb98: Already exists</span><br><span class="line">9c8f656c32b8: Already exists </span><br><span class="line">88e473c3f553: Already exists </span><br><span class="line">062463ea5d2f: Already exists </span><br><span class="line">daf7e3bdf4b6: Already exists </span><br><span class="line">1839c0b7aac9: Already exists </span><br><span class="line">cf0a0cfee6d0: Already exists </span><br><span class="line">fae7a809788c: Pull complete </span><br><span class="line">dae5a82a61f0: Pull complete </span><br><span class="line">7063da9569eb: Pull complete </span><br><span class="line">51a9a9b4ef36: Pull complete </span><br><span class="line">Digest: sha256:d9b934cdf6826629f8d02ea01f28b2c4ddb1ae27c32664b14867324b3e5e1291</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p><strong>docker rmi 删除镜像（remove images）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定id删除镜像</span></span><br><span class="line">[root@localhost /]# docker rmi -f &lt;镜像对应ID&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查出所有的id，然后删除所有镜像</span></span><br><span class="line">[root@localhost /]# docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure></li></ul><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>拥有镜像后才能创建容器，使用centos镜像来进行实验</p><ul><li><p><strong>下载镜像：docker pull centos</strong></p></li><li><p><strong>docker run 新建容器并启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;参数&gt; &lt;镜像&gt;</span><br><span class="line"><span class="meta"> #</span><span class="bash"> 参数</span></span><br><span class="line"> --name = &quot;name&quot;# 容器名字自定义</span><br><span class="line"> -d# 在后台运行</span><br><span class="line"> -it # 使用交互方式运行，进入容器查看内容</span><br><span class="line"> -p# 指定容器端口 -p 8080端口</span><br><span class="line"> -p ip:主机端口:容器端口</span><br><span class="line"> -p 主机端口:容器端口</span><br><span class="line"> -p 容器端口</span><br><span class="line"> 容器端口</span><br><span class="line"> -P# 大写P，随机指定端口</span><br><span class="line"> </span><br><span class="line">[root@localhost /]# docker run -it centos /bin/bash</span><br><span class="line">[root@a0e3c05e1120 /]#</span><br></pre></td></tr></table></figure></li><li><p><strong>docker ps 查看所有运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps &lt;参数&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认展示正在运行的容器</span></span><br><span class="line">-a# 可查看所有运行过的容器</span><br><span class="line">-n=x# 列出最近创建的x个容器、</span><br><span class="line">-q# 只显示ID</span><br></pre></td></tr></table></figure></li><li><p><strong>退出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit# 容器停止并退出</span><br><span class="line">ctrl + P + Q# 容器不停止退出</span><br></pre></td></tr></table></figure></li><li><p><strong>docker rm 删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器ID&gt;# 删除指定ID，运行中的不能删除，可使用rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)# 全部删除</span><br></pre></td></tr></table></figure></li><li><p><strong>启动与停止容器的操作</strong></p><p>类似linux命令，这里启动可以启动以前运行过的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start ID</span><br><span class="line">docker restart ID</span><br><span class="line">docker stop ID</span><br><span class="line">docker kill ID</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p><strong>docker run 后台启动容器</strong></p><p>注意后台启动容器时，必须要有一个前台进程，若docker发现没有应用，则自动停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以写一个脚本，然后后台运行</span></span><br><span class="line">docker run -d centos /bin/sh -c &quot;while true;do echo tang;sleep 1;done&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>docker logs 查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;参数&gt; &lt;容器&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数</span></span><br><span class="line">-f# 跟踪日志输出</span><br><span class="line">-t# 显示日志的时间戳</span><br><span class="line">--since# 自某个时间开始的所有日志</span><br><span class="line">--tail # 只列出最新的n条日志</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以用上面的循环脚本进行日志测试</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现-f后日志会持续输出内容但是没有时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t会输出当前的全部内容有时间但不跟踪</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --since和--tail后面必须加相关条件进行信息筛选</span></span><br></pre></td></tr></table></figure></li><li><p><strong>docker top 查看容器中进程信息</strong></p><p>可以根据查询的进程号杀死进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;容器ID&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> UID用户ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PID 进程ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PPID父进程ID</span></span><br></pre></td></tr></table></figure></li><li><p><strong>docker inspect 查看容器源数据</strong></p><p>可以查看容器的相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器ID&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>docker exec / attach 进入当前正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入容器，然后开启一个新的终端</span></span><br><span class="line">docker exec -it &lt;容器ID&gt; /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器正在执行的终端</span></span><br><span class="line">docker attach &lt;容器ID&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>docker cp 容器拷贝文件到主机</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在容器中创建文件，然后在主机中使用cp命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将容器对应的文件拷贝到主机的指定目录</span></span><br><span class="line">docker cp &lt;容器ID&gt;:&lt;文件路径&gt; &lt;主机路径&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用练习"><a href="#使用练习" class="headerlink" title="使用练习"></a>使用练习</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br><span class="line">docker pull nginx</span><br><span class="line">docker run -d -p 8888:80 nginx# 使用8888替换默认80端口</span><br><span class="line">curl lcoalhost:8888 # 测试访问对应地址端口</span><br><span class="line">docker exec -it &lt;ID&gt; /bin/bash   # 可以进入容器 </span><br></pre></td></tr></table></figure><p>本机访问对应ip和端口也可以访问nginx容器，需要提前关闭防火墙开放端口。</p><h2 id="可视化面板"><a href="#可视化面板" class="headerlink" title="可视化面板"></a>可视化面板</h2><p>安装可视化工具：portainer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 --restart=always -v var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><p>运行测试，主机访问8088端口：<a href="http://192.168.158.131:8088/">http://192.168.158.131:8088/</a></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="镜像（分层复用）"><a href="#镜像（分层复用）" class="headerlink" title="镜像（分层复用）"></a>镜像（分层复用）</h2><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，<strong>还包含了一些为运行时准备的配置参数</strong>，如匿名卷、环境变量、用户等，<strong>镜像不包含动态数据，构建后内容不会被改变。</strong></p><p>Docker设计时，使用Union FS技术，使其成为一个分层存储架构。镜像由多层文件系统联合组成。<strong>Docker镜像可拆分成多个层次，两个不同镜像其中相同层次的文件是可以复用的。一层层构建镜像时，后一层是在前一层的基础上完成的，每一层构建完后不在发生改变，后一层的任何改变只会发生在自己这一层。</strong>也就说若后一层删除前一层的文件，只是在当前层标记文件删除，使得文件不显示，其实在前一层上数据并没有改变。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><strong>可以说容器是镜像运行时的实体，镜像与容器可以类比面向对象里的类与实例。容器是可以进行创建、启动、停止、删除等操作的。</strong></p><p>镜像一般是只读的，启动一个容器就是在镜像的最外层加上一个可读写层，镜像就像一个安装包，启动容器后才能对内部进行操作。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>仓库就是集中存储镜像文件的地方，很容易联想到Maven仓库。</p><p>官方镜像仓库搜索地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 官方的tomcat进行过简化，webapps文件夹是空的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以将基本信息拷贝进去，然后提交这个修改过的镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交后相当于新生成了一个镜像</span></span><br><span class="line">docker commit -a=&quot;作者&quot; -m=&quot;描述信息&quot; &lt;容器ID&gt; 自定义镜像名</span><br></pre></td></tr></table></figure><h1 id="容器数据卷（持久化与同步）"><a href="#容器数据卷（持久化与同步）" class="headerlink" title="容器数据卷（持久化与同步）"></a>容器数据卷（持久化与同步）</h1><p>我们希望Docker的数据是可以持久化的，但我们修改了容器内的数据，如果不生成一个新容器，删除容器后修改的数据就消失了，为了将数据持久化，我们要使用容器数据卷。卷就是目录或文件，存在于一个或多个容器中，但不属于Union FS（联合文件系统），不是分层架构的，可以进行<strong>数据的持久化或数据共享</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行容器，使用-v命令进行目录挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v &lt;主机目录&gt;:&lt;容器目录&gt;</span></span><br><span class="line">docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过inspect命令查看容器信息，Mounts就是卷挂载的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Source：主机目录，Destination：容器目录</span></span><br><span class="line">docker inspect &lt;容器ID&gt;</span><br><span class="line">···</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/home/ceshi&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/home&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>通过以上操作，两个目录就完成了同步操作，其内容完全一致。</p><p>同理我们操作一下mysql，且使用本地数据库操作工具可以对该数据库连接。</p><p><strong>而且将数据库删除后，我们data中的数据依旧存在。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br></pre></td></tr></table></figure><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>Dockerfile是一个用来构建镜像的文本文件。其包含构建镜像所需的指令与说明。相当于一个命令脚本，使用脚本生成镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在指定目录下，写一段简单脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我的路径/home/dockerfile-test/dockerfile01</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;--------END--------&quot;</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>有了脚本后，就可以使用docker build命令创建镜像,<strong>末尾有个 . 不要忘了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker build命令创建镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f 脚本路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 镜像名:版本号</span></span><br><span class="line">docker build -f /home/dockerfile-test/dockerfile01 -t tang/centos:1.0 .</span><br></pre></td></tr></table></figure><p>运行自己创建的镜像，在根目录下可以发现脚本中写好的卷：volume01、volume02，但这里是匿名挂载，需要通过inspect查看主机对应生成的随机文件夹名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it tang/centos:1.0 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="卷数据同步（–volumes-from）"><a href="#卷数据同步（–volumes-from）" class="headerlink" title="卷数据同步（–volumes-from）"></a>卷数据同步（–volumes-from）</h2><p>将不同容器的挂载卷的数据同步，如两个不同容器的mysql使用同一个数据库。当然删除其中一个容器，其他容器内的卷数据不会消失。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们这里只是要使用同一个数据库，可使用匿名挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个mysql使用--volumes-from和第一个mysql进行卷数据同步</span></span><br><span class="line">docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -d -p 3310:3306 --name mysql02 --volumes-from mysql:5.7</span><br></pre></td></tr></table></figure><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p>我们写dockerfile脚本时常用的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM# 基础镜像</span><br><span class="line">MAINTAINER# 镜像作者</span><br><span class="line">RUN# 镜像构建时要执行的命令</span><br><span class="line">ADD# 将文件添加到镜像中</span><br><span class="line">WORKDIR# 镜像的工作目录</span><br><span class="line">VOLUME# 挂载的目录</span><br><span class="line">EXPOSE# 配置端口</span><br><span class="line">CMD# 容器启动时要运行的命令，可被替代</span><br><span class="line">ENTRYPOINT# 容器启动时要运行的命令，可追加命令</span><br><span class="line">ONBUILD # 该命令下的内容只对当前镜像的子镜像生效</span><br><span class="line">COPY# 类似ADD，将文件拷贝到镜像</span><br><span class="line">ENV# 构建时配置环境变量</span><br><span class="line">LABEL# 为镜像指定标签</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul><li><p>编写dockerfile脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER aidianfirst&lt;AVG--lover&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置默认的工作目录</span></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自行添加命令，原生centos命令很少</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo ----------END----------- </span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>docker build命令构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f myDockerfile -t mycentos:1.0 .</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动我们自定义的镜像后，我们就可以使用自行添加的命令了</span></span><br><span class="line">docker run -it mycentos:1.0</span><br></pre></td></tr></table></figure></li></ul><h2 id="CMD-与-ENTRYPOINT区别"><a href="#CMD-与-ENTRYPOINT区别" class="headerlink" title="CMD 与 ENTRYPOINT区别"></a>CMD 与 ENTRYPOINT区别</h2><p>cmd：命令只能被替换，不能拼接。</p><p>entrypoint：命令可以被拼接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用CMD，启动容器后就会执行ls -a命令</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若我们启动时在结尾添加新指令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 希望容器启动后执行ls -al，但CMD只能命令替换</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也就是将原本的ls -a替换为 -l，这不是一个命令会报错</span></span><br><span class="line">docker run e457b67ad5eb -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要写成一个完整命令对CMD的命令进行替换，而不是拼接</span></span><br><span class="line">docker run e457b67ad5eb ls -al</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用ENTRYPOINT</span></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用命令行启动，发现可以进行命令拼接</span></span><br><span class="line">docker run -it fe4bf4cb9f12 -l</span><br></pre></td></tr></table></figure><h1 id="Docker流程一图看懂"><a href="#Docker流程一图看懂" class="headerlink" title="Docker流程一图看懂"></a>Docker流程一图看懂</h1><p>pull下载镜像、run启动容器、Dockerfile编写镜像脚本，build一个脚本生成镜像，save/load打包传输。</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/26.png" alt="26.png"></p><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="docker是如何处理容器网络访问的？（ip）"><a href="#docker是如何处理容器网络访问的？（ip）" class="headerlink" title="docker是如何处理容器网络访问的？（ip）"></a>docker是如何处理容器网络访问的？（ip）</h2><p>使用 ip addr 命令可以查看虚拟机的网络，然后我们可以发现有一个叫docker0的网络。我们启动一个容器，进入配置文件查看ip，然后用本机ping这个ip，发现网络是通的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker exec -it tomcat01 /bin/bash</span><br><span class="line">cat /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 172.17.0.278c064e8db0a</span></span><br><span class="line">ping 172.17.0.2 # 网络是通的</span><br></pre></td></tr></table></figure><ul><li>启动docker容器，docker会为容器分配一个ip，且安装docker后会生成一个网卡docker0，使用的是桥接模式，技术是veth-pair。</li><li>每次启动容器都会新建一个网卡，成对出现的。使用veth-pair充当桥梁连接虚拟网络设备。其中容器之间也可以相互ping。</li><li>我们不同容器可以使用ip进行连接。</li></ul><h2 id="–link（run启动时）"><a href="#–link（run启动时）" class="headerlink" title="–link（run启动时）"></a>–link（run启动时）</h2><p>其实就是在/etc/hosts配置文件中声明了，名称对应的ip，所以我们后续可直接使用名字连接，不使用ip。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动一个test2的tomcat，使用--link指令将其与test1连通</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可直接使用ping test1，2与1不适用ip九年连通，但link是单向的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 想要1与2连通，我们需要对test1也进行声明</span></span><br><span class="line">docker run --name test2 --link test1 tomcat</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/install/centos/&quot;&gt;https://docs.</summary>
      
    
    
    
    <category term="中间件" scheme="http://aidianfirst.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL八股文</title>
    <link href="http://aidianfirst.com/2021/09/09/%E5%85%AB%E8%82%A1/MySQL%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://aidianfirst.com/2021/09/09/%E5%85%AB%E8%82%A1/MySQL%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2021-09-09T05:21:25.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 添加</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `表`(`字段`) <span class="keyword">values</span> (<span class="string">&#x27;值&#x27;</span>)</span><br><span class="line"># 删除，<span class="keyword">truncate</span>清全表</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `表` <span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> `表`</span><br><span class="line"># 修改</span><br><span class="line">update `表` <span class="keyword">set</span> `字段` <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"># 查询 后面可以使用很多的关键字辅助查询</span><br><span class="line"># <span class="keyword">select</span> <span class="operator">-</span> <span class="keyword">from</span> <span class="operator">-</span> <span class="keyword">where</span> <span class="operator">-</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">-</span> <span class="keyword">having</span> <span class="operator">-</span> <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">select</span> `字段` <span class="keyword">from</span> `表` <span class="keyword">where</span>··· </span><br></pre></td></tr></table></figure><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>去重查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> `字段`, `字段` <span class="keyword">from</span> `表`</span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>连接字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;我的名字是:&#x27;</span>,`name`) <span class="keyword">as</span> 学生姓名 <span class="keyword">from</span> `users`</span><br></pre></td></tr></table></figure><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>limit一般有两个参数，第一个表示返回数据的起始位，第二个表示要返回的行数。若只有一个参数，即省去了第一个参数，使用默认值0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回前<span class="number">5</span>行数据（默认从第<span class="number">0</span>行开始，返回后<span class="number">5</span>行数据）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表` limit <span class="number">5</span></span><br><span class="line"># 从第<span class="number">3</span>行开始，返回后<span class="number">3</span>行数据，也就是<span class="number">4</span>、<span class="number">5</span>、<span class="number">6</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表` limit <span class="number">3</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>排序，<strong>ASC升序（默认），DESC降序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表`</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `字段` <span class="keyword">ASC</span> <span class="operator">/</span> <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>可使用的判断语句 </p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在两个值之间</td></tr><tr><td align="center">IS NULL</td><td align="center">为 NULL 值</td></tr></tbody></table><ul><li><p><strong>and、or</strong>可用于来连接多个条件判断。优先处理and。</p></li><li><p><strong>in</strong>常用于匹配一组值，也可以跟一个查询语句，匹配子查询得到的一组值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表` <span class="keyword">where</span> `字段` <span class="keyword">in</span> (<span class="string">&#x27;值&#x27;</span>···)</span><br></pre></td></tr></table></figure></li><li><p><strong>not</strong>相当于否定，可加在一般的判断语句前面表否定</p></li></ul><h2 id="通配符（模糊查询）"><a href="#通配符（模糊查询）" class="headerlink" title="通配符（模糊查询）"></a>通配符（模糊查询）</h2><p>通配符用于过滤，但只能用于文本字段。</p><p>要使用<strong>like</strong>进行通配符匹配。就是使用两个通配符进行字符串拼接，然后进行模糊查询。</p><ul><li><strong>%</strong> 可替换0或多个任意字符</li><li><strong>_</strong>  只可替换1个任意字符</li></ul><h2 id="计算函数"><a href="#计算函数" class="headerlink" title="计算函数"></a>计算函数</h2><p>函数对select后的查询字段操作即可。</p><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">AVG()</td><td align="center">返回某列的平均值</td></tr><tr><td align="center">COUNT()</td><td align="center">返回某列的行数</td></tr><tr><td align="center">MAX()</td><td align="center">返回某列的最大值</td></tr><tr><td align="center">MIN()</td><td align="center">返回某列的最小值</td></tr><tr><td align="center">SUM()</td><td align="center">返回某列值之和</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(money) <span class="keyword">AS</span> `sum` <span class="keyword">FROM</span> `account`</span><br></pre></td></tr></table></figure><h2 id="group-by，having"><a href="#group-by，having" class="headerlink" title="group by，having"></a>group by，having</h2><p>通过查询语句查找表的某个字段，然后按照字段进行分组展示。</p><p>首先可以通过where对原表数据进行筛选操作，然后使用group by对查询数据进行分组操作，分组后的数据若还需要筛选，则使用having操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `字段`, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 别名 <span class="keyword">FROM</span> `表`</span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>对原表数据操作<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> `字段` </span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>对分组数据操作<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>就是查询语句套查询，使用子查询的结果来进行操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="keyword">IN</span> (<span class="keyword">SELECT</span> `password` <span class="keyword">FROM</span> users)</span><br></pre></td></tr></table></figure><p>子查询密码字段的结果，查询姓名，其中姓名和子查询的密码字段有相同值则筛选出来。</p><h2 id="连接（join-on）"><a href="#连接（join-on）" class="headerlink" title="连接（join on）"></a>连接（join on）</h2><h3 id="内连接（inner-join）"><a href="#内连接（inner-join）" class="headerlink" title="内连接（inner join）"></a>内连接（inner join）</h3><p>查询用户的邮箱与账户的金额，找到两个表id相同的数据进行返回。inner join来连接查询后，使用on进行条件筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.money, u.email</span><br><span class="line"><span class="keyword">FROM</span> account <span class="keyword">AS</span> a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> users <span class="keyword">AS</span> u</span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>表与表自身进行连接查询，相当于复制一个表，两个相同的表进行连接查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u1.email, u1.id</span><br><span class="line"><span class="keyword">FROM</span> users <span class="keyword">AS</span> u1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> users <span class="keyword">AS</span> u2</span><br><span class="line"><span class="keyword">ON</span> u1.id <span class="operator">=</span> u2.id</span><br></pre></td></tr></table></figure><h3 id="外连接（左外连、右外连、全外连）"><a href="#外连接（左外连、右外连、全外连）" class="headerlink" title="外连接（左外连、右外连、全外连）"></a>外连接（左外连、右外连、全外连）</h3><p>左连接用户表与账户表，返回需要的字段，使用左右连接时，出来查询两个表符合的字段，还要展示左表或右表的剩余全部内容。没有字段则记为null，但一定要有。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.id, u.name, u.password</span><br><span class="line"><span class="keyword">FROM</span> users <span class="keyword">AS</span> u <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> account <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>组合多个查询语句，但每个查询的返回格式必须一样，如列相同等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> `name`<span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p><a href="https://zhuanlan.zhihu.com/p/194270249">https://zhuanlan.zhihu.com/p/194270249</a></p><ul><li><p>1NF</p><p>数据库每一列（每个属性字段），都是不可分割的原子数据项。也就说字段内容可以二次拆分，那么就不满足1NF。</p><p>比如学生课程关系表，不可以一个学生直接对应一个课程的信息集合，而是分多个条目进行记录。</p></li><li><p>2NF</p><p>表中非主键字段应该和主键完全依赖，而不是部分依赖。</p><p><strong>当表中主键由多个字段组成时会出现该问题</strong>，部分字段只和其中一个主键有关联，比方说订单表主键由订单号 + 产品组成，一些订单具体数据信息应该单独与订单号记录，而不是混合在订单产品表中。</p></li><li><p>3NF</p><p>非主键字段不能传递依赖于主键，也就是不能产生依赖传递关系。主键外的所有字段互不依赖。</p><p>比如有ABC三个字段，A是主键，C是通过B与A主键进行关联，此时就违反了3NF。需要拆分成AB，BC两张表，消除传递依赖。</p></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引底层数据结构"><a href="#索引底层数据结构" class="headerlink" title="索引底层数据结构"></a>索引底层数据结构</h2><h3 id="使用B树与B-树引擎的区别"><a href="#使用B树与B-树引擎的区别" class="headerlink" title="使用B树与B+树引擎的区别"></a>使用B树与B+树引擎的区别</h3><ul><li>B树其所有节点都会存放 key 和 data ，但B+树只有叶子节点会存放 key 和 data ，其余内部节点存放key。也就是说B树所有节点都可以保存数据，索引很大，但B+树只有叶子节点保存数据，其内部节点相当于一个查找的索引。</li><li>B+树的叶子节点通过链表相连，而B树叶子节点是单独的。</li><li>B+树相当于B树检索更加稳定，B树可能没有走到叶子节点就查到数据了，而B+树数据都是存在与叶子节点上的，且叶子节点还可进行顺序查找，不用返回上一节点。B+树更便于区间查找和遍历。</li><li>为什么不用红黑树，因为B、B+树都是一个节点包含多个key的数据结构，它们的树高相比红黑树更低，而数据库磁盘IO次数就是由树高决定的，使用B+树结构IO效率更高。</li></ul><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li><p><strong>主键索引（唯一索引）</strong></p><p>数据表的主键就是主键索引。主键和主键索引一致，只能有一个，且主键不为空，不能重复。聚簇索引。</p></li><li><p><strong>二级索引（辅助索引）</strong></p><p>InnoDB中非主键索引的就是二级索引，二级索引的叶子节点存储的数据是主键值，可通过二级索引确定主键的位置，也就是回表查询。</p></li><li><p><strong>唯一索引</strong></p><p>唯一索引的属性列不可出现重复数据，但允许数据为null，一张表允许多个唯一索引。一般是为了保证数据列的唯一性，不是为了查找性能考虑。</p></li><li><p><strong>普通索引</strong></p><p>普通索引唯一的作用就是为了快速查询数据，一张表允许多个普通索引，且允许数据重复和null。</p></li><li><p><strong>前缀索引</strong></p><p>索引很长的字符列，导致索引很大且慢。前缀索引只适合字符串类型数据。前缀索引对文本的前几个字符创建索引，节省索引空间，提高索引效率。</p></li><li><p><strong>哈希索引</strong></p><p>基于哈希表实现，为了精确匹配索引所有列的查询才有效。无法用于排序，不支持部分索引列的匹配查询，哈希索引始终使用索引列的全部内容计算哈希值。</p></li><li><p><strong>全文索引</strong></p><p>全文索引主要为了检索大文本数据的关键字信息。</p></li><li><p><strong>多列索引</strong></p><p>多个列组成的索引即联合索引。遵循最左匹配原则。</p></li></ul><h2 id="聚簇索引与非聚簇索引（InnoDB）"><a href="#聚簇索引与非聚簇索引（InnoDB）" class="headerlink" title="聚簇索引与非聚簇索引（InnoDB）"></a>聚簇索引与非聚簇索引（InnoDB）</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>一个表只有一个聚集索引。聚集索引就是索引结构与数据一起存放的索引。主键索引是聚集索引。B+树结构，叶子节点data存储数据。</p><ul><li>优点：聚集索引查询速度很快，使用的是B+树的存储结构。</li><li>缺点：<strong>依赖有序数据</strong>，因为B+树数据有序，遇到无序数据我们还要先进行排序处理，而像UUID这种杂乱数据处理效率就更低了。</li></ul><p>InnoDB默认将逐渐设置为聚簇索引，若没有定义主键，InnoDB会选择一个唯一的非空索引代替。若没有这种索引，InnoDB会隐式定义一个主键作为聚簇索引。</p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>二级索引是非聚集索引。叶子节点存放主键值，一般是查询到主键值后对主键索引进行回表查询。叶子节点data存储指向数据的指针。</p><ul><li>缺点：也依赖有序数据。且非聚集索引可能发生回表查询。</li></ul><h2 id="InnoDB与MyISAM"><a href="#InnoDB与MyISAM" class="headerlink" title="InnoDB与MyISAM"></a>InnoDB与MyISAM</h2><ul><li>事务：InnoDB支持事务操作，MyISAM不支持</li><li>锁：InnoDB使用行级锁，MyISAM使用表级锁</li><li>索引：InnoDB是聚集表，MyISAM是非聚集表</li><li>外键：InnoDB支持外键，MyISAM不支持</li></ul><h2 id="最左匹配与覆盖索引"><a href="#最左匹配与覆盖索引" class="headerlink" title="最左匹配与覆盖索引"></a>最左匹配与覆盖索引</h2><p>首先说说多列索引的<strong>最左匹配原则</strong>，一个多列索引（ a | b | c ），可以匹配三种查询条件，a、ab、abc，且where查询条件的先后不影响索引，只要有符合的字段就可以使用索引，因为MySQL的优化器会优化字段顺序走多列索引。而bc的查询条件是无法使用该多列索引的。</p><p><strong>最左匹配原则会向右匹配直至遇到范围查询（&gt;、&lt;、between、like）。</strong></p><p>然后说说<strong>覆盖索引</strong>，如果我们要<strong>查询的字段全部被一个索引所包含，那么该查询只需要去扫描索引树而无需回表</strong>。（回表查询就是查二级索引拿主键值，再去查主键索引拿数据）这里覆盖索引只有部分覆盖也是可以的。</p><p>所以有时会出现特殊情况，导致我们误以为最左匹配失效，例如我们给表中所有字段设置为多列索引，那么对该表的查询一定会走覆盖索引的操作，此时我们无论怎么写where条件语句，都不会全表查询，导致最左匹配看似失效了。</p><h2 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h2><ul><li><p>索引列字段使用函数</p></li><li><p>索引列涉及表达式计算</p></li><li><p>模糊查询，查询条件%在右侧可以走索引，%在左侧索引失效。**%在右侧的情况下，mysql根据实际情况进行优化，判断是全表扫描还是走索引，所以在模糊查询的时候最好不要用左%，且内容要写详细点。**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: 微信%</span><br><span class="line">2: 微信小程序%</span><br><span class="line">3: 微信公众号%</span><br><span class="line">上面三种模糊查询条件，可能情况1会被MySQL进行优化走全表扫描，这个涉及到优化算法。而详细一点的查询条件2、3就会走索引。</span><br><span class="line">我实践后的猜测是条件目标数据占比权重过高，如果当前模糊查询条件目标数据在整个表中占比过高，这个条件的索引应该会位于B+树最上面的几层，那么遍历走到的叶子节点会比较多，索性进行全表扫描不走索引</span><br></pre></td></tr></table></figure></li><li><p>索引列属性是字符串，查询条件使用数字，不走索引。底层会进行优化进行格式转换，而数字整型格式条件使用字符串确可以。建议查询条件都用引号 <code>&#39;条件&#39;</code>进行修饰。</p></li><li><p>查询条件中有or，不一定走索引，此时要看MySQL优化器</p></li><li><p>in的范围查询，条件目标过多时会被优化成全表扫描，具体问题具体分析</p></li><li><p>正则表达式</p></li><li><p>MySQL优化器，当全表扫描效率更高时，不走索引。一般通过EXPLAIN相关参数进行分辨。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prossible_keys: 此处为可能运用到的索引，优化器处理前</span><br><span class="line">key: 实际用到的索引，优化器处理后</span><br></pre></td></tr></table></figure></li></ul><p>特殊情况：覆盖索引，即使是失效场景仍可以命中，其实场景很多，索引还跟数据量有关，实际中我们需要使用 EXPLAIN 对自己的SQL性能进行评估。</p><p>EXPLAIN 相关参数：<a href="https://www.jianshu.com/p/8fab76bbf448">https://www.jianshu.com/p/8fab76bbf448</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from &#96;表名&#96;</span><br></pre></td></tr></table></figure><p>我们还可以通过以上语句来查看每张表索引的指标，其中 cardinality 代表 “索引基数” ，该参数涉及到优化器的索引选择，基数越大的索引性能越好。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>多个对数据库操作构成的一个逻辑整体，这就是数据库事务，这个逻辑整体的所有操作，要么全部成功，要么全部不成功。</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul><li><strong>原子性：</strong>原子性表示事务是最小的执行单位，这个整体只能同时完成操作，不能只完成部分操作。</li><li><strong>一致性：</strong>执行事务前后，数据整体要保持一致，也就是把事务当作一个整体，比如进行转账操作，无论操作是否成功，账户之间的操作的金额整体是不变的。</li><li><strong>隔离性：</strong>并发访问数据库时，一个事务的执行不受其他事务干扰，事务之间时相互隔离的。</li><li><strong>持久性：</strong>一个事务执行提交后，它在数据库中的改变是永久的，数据库发生故障也不会影响数据。</li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>多个事务并发运行，经常会有多个用户操作同一数据，并发是不可避的，但会导致一些问题，一般是因为并发破坏了事务的隔离性才导致以下问题的发生。</p><ul><li><p><strong>脏读：</strong>一个事务A正在访问数据并进行修改，但修改还未提交到数据库中，此时另一个事务B访问该数据并使用，由于这个数据还未提交，事务A后续可能对事务进行回滚操作，那么数据就没有进行修改，事务B读取到的数据就是脏数据。</p></li><li><p><strong>丢失修改：</strong>事务A读取数据时，同时另一个事务B也访问该数据，此时事务A先修改数据，然后事务B也修改数据，最后事务B的修改操作会覆盖事务A的修改操作。</p></li><li><p><strong>不可重复读：</strong>事务A对同一数据进行多次读取操作，在A进行多次读取之间，有事务B对该数据进行了修改操作，导致事务A同一数据的多次读取结果不一致。</p></li><li><p><strong>幻读：</strong>事务A对多条数据进行读取操作，但中途事务B执行了插入或删除操作，随后事务A再次对多条数据进行读取，发现和前一次读取结果不一致。</p></li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>隔离级别依次递增</p><ul><li><strong>读取未提交：</strong>允许读取未提交的数据，所有并发问题都会出现。</li><li><strong>读取已提交：</strong>允许事务读取已提交的数据，也就是说一个事务所做的修改在提交前对其他事务是不可见的。可以阻止脏读的发生。</li><li><strong>可重复读：</strong>保证在同一个事务中，多次读取同一数据是一致的，除非事务本身进行修改操作。可阻止脏读与不可重复读。</li><li><strong>可串行化：</strong>完全服从ACID的隔离级别。强制事务串行执行，多个事务间互不干扰，不会出现并发相关问题。该隔离级别需要进行加锁操作，以确保同时间只有一个事务执行，也就是串行执行。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h1&gt;&lt;h2 id=&quot;增删改查&quot;&gt;&lt;a href=&quot;#增删改查&quot; class=&quot;headerlink&quot; title=&quot;增删改查&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="八股" scheme="http://aidianfirst.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>计网八股文</title>
    <link href="http://aidianfirst.com/2021/09/06/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://aidianfirst.com/2021/09/06/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2021-09-06T15:15:14.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网模型"><a href="#计网模型" class="headerlink" title="计网模型"></a>计网模型</h1><ul><li><p>OSI七层</p><p>物理层、数据链路层、网络层、传输层、会话层、表示层、网络层</p></li><li><p>TCP/IP四层</p><p>网络接口层、网络层（IP）、传输层（TCP、UDP）、应用层</p></li><li><p>五层协议</p><p>物理层、数据链路层、网络层、传输层、应用层</p></li></ul><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="握手流程"><a href="#握手流程" class="headerlink" title="握手流程"></a>握手流程</h2><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/24.png" alt="24.png"></p><p>A作为客户端，B作为服务端。SYN是同步序列编号，ACK是确认标志位。</p><ul><li>B处于LISTEN，等待客户端的连接请求，<strong>A向B发送请求报文，SYN=1、ACK=0</strong>，并选择一个初始序号x，代表这是一个同步请求。</li><li>B收到请求报文，若同意建立连接，<strong>则B向A发送连接确认报文，SYN=1、ACK=1</strong>，且确认号是x+1，并选择一个初始序号y，这一步是对第一次握手的SYN同步进行确认。</li><li>A收到B的来连接确认报文后，还需<strong>A向B发出确认报文，ACK=1</strong>，确认号是y+1，序号是x+1，然后B收到A的确认报文后，连接成功建立。</li></ul><h2 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h2><p>三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求若在网络中长时间滞留，那么间隔很长的时间才收到服务端的连接确认。但客户端在等待一个超时重传时间后，会重新请求连接。最后这个滞留的请求还是会到达服务器。若不进行三次握手，那么服务器会打开两个连接，<strong>若进行三次握手，客户端会忽略服务器后续发来对滞留连接请求的确认报文，于是不进行对该请求的第三次握手，因此不会打开多个连接。</strong></p><h2 id="为什么第二次握手除了回传ACK，还要回传SYN？"><a href="#为什么第二次握手除了回传ACK，还要回传SYN？" class="headerlink" title="为什么第二次握手除了回传ACK，还要回传SYN？"></a>为什么第二次握手除了回传ACK，还要回传SYN？</h2><p>回传SYN代表服务端收到了客户端的请求，证明客户端到服务端的通信是正常的，现在返回一个SYN来建立并确认服务端到客户端的通信是否正常。</p><p>回传ACK代表服务端告诉客户端收到了它的请求。</p><p>客户端发出SYN请求，服务端使用SYN–ACK进行应答这个请求，最后客户端再以ACK进行连接的最后确认，于是客户端和服务端间建立了可靠的TCP连接。</p><h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><h2 id="挥手流程"><a href="#挥手流程" class="headerlink" title="挥手流程"></a>挥手流程</h2><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/25.png" alt="25.png"></p><p>A作为客户端，B作为服务端。FIN代表结束。</p><ul><li><strong>A向B发送连接释放报文，FIN=1。</strong></li><li>B收到A的释放请求，随后<strong>B向A发出确认连接释放报文，ACK=1</strong>，此时TCP处于半关闭状态，B可以向A发送数据，但A不可以向B发送数据。</li><li>此时A到B的连接关闭，然后我们要关闭B到A的连接，<strong>B向A发送连接释放报文，FIN=1，由于现在是半关闭状态，服务器可能又发送了一些数据，此时B进入LAST–ACK（最后确认状态），然后B向A发送确认，ACK=1</strong>，等待关闭。</li><li>A收到B的连接关闭请求和最后确认请求后，<strong>A进入TIME–WAIT状态，A向B发送确认报文，ACK=1，再等待2MSL后释放连接。</strong></li><li>B收到A的确认连接，释放连接。</li></ul><h2 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h2><p>客户端先发送FIN连接释放报文，服务端收到报文后就进入CLOSE–WAIT状态。该状态是为了让服务端发送还未传输完毕的数据，待数据传输完毕后，服务器会发送FIN连接释放报文。</p><p>而客户端收到服务器的连接释放请求后，进入TIME–WAIT状态，然后等待2MSL的时间后，进入CLOSED状态。等待的原因有两点：</p><ul><li><p>确保客户端的最后一个确认报文可以到达服务端。若B没有收到A的确认报文，那么A会重新发送确认连接释放报文，A等待一段时间就是为了处理这种情况。</p></li><li><p>等待一段时间，是为了等待本连接持续时间内产生的所有报文从网络中消失，使下一次新连接不会出现旧连接的请求报文。</p></li></ul><h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h1><ul><li>UDP<ul><li>无连接</li><li>传输不可靠</li><li>传输形式：数据报文端</li><li>传输效率快</li><li>耗资源少</li><li>首部字节：8字节</li><li>一般用于通信速度要求高的场景，即时通信，如QQ语音、视频直播等</li></ul></li><li>TCP<ul><li>面向连接</li><li>可靠传输</li><li>传输形式：字节流</li><li>传输效率慢</li><li>耗资源多</li><li>首部字节：20-60</li><li>多用于要求通信可靠的场景，如文件传输、发送接收邮件、远程登录等场景</li></ul></li></ul><h1 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h1><ul><li><strong>校验和：</strong>TCP校验和覆盖TCP首部与TCP数据，这是一个发送端到接收端的校验和。目的是检测数据在传输过程中的任何变化，若收到的校验和有差错，TCP会丢弃和不确认接收这个报文段。</li><li><strong>流量控制：</strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收。当接收方来不及处理发送方数据时，接收方发送的确认报文中的窗口字段可用来控制发送方窗口大小，进而影响发送方的发送速率。<strong>（TCP利用滑动窗口实现流量控制）</strong></li><li><strong>拥塞控制：</strong>网络拥塞时，减少数据的发送，降低网络拥塞程度。<strong>（维护拥塞窗口，其大小取决于网络的拥塞程度）</strong></li><li><strong>ARQ协议：</strong>实现可靠传输，基本原理是每次发送完一个分组就停止发送，等待对方进行确认后，再进行下一个分组的发送。</li><li><strong>超时重传：</strong>TCP发送报文后会启动一个定时器，等待接收端确认这个报文。若在限制时间内没有收到接收端的确认返回，TCP会重新发送这个报文段。</li></ul><h1 id="浏览器从输入url到展示网页发生了什么"><a href="#浏览器从输入url到展示网页发生了什么" class="headerlink" title="浏览器从输入url到展示网页发生了什么"></a>浏览器从输入url到展示网页发生了什么</h1><ul><li><p><strong>解析URl：</strong>也就是分析我们网址的请求路径</p></li><li><p><strong>浏览器封装HTTP请求报文：</strong>对URL进行分析后，浏览器确定了目标服务器以及请求路径对应的文件。随后浏览器就将这些信息封装成一个HTTP请求报文发送出去。</p></li><li><p><strong>DNS域名解析获取IP地址：</strong>域名并不是目标服务器的详细地址，所以我们还要解析获取其详细的IP地址。而DNS获取地址是先去缓存查找，没有则去查询，具体步骤如下，<strong>注意DNS使用UDP协议，以下请求的转发都是基于UDP。</strong></p><ul><li><strong>搜索浏览器DNS缓存</strong></li><li><strong>搜索操作系统DNS缓存</strong></li><li>缓存中都没有找到，操作系统会将域名发送到<strong>本地域名服务器</strong>，通过本地域名服务器查询DNS缓存，找到则返回<strong>（主机与本地域名服务器之间查询方式是递归查询）</strong></li><li>若本地域名服务器DNS缓存没有命中，则本地域名服务器向上级域名服务器进行<strong>迭代查询</strong>。<strong>（本地域名服务器与其他域名服务器之间迭代查询，防止根域名服务器压力过大）</strong><ul><li>本地域名服务器<strong>向根域名服务器发起请求</strong>，根域名是最高层次的，它不会直接指明一个IP地址，而是返回顶级域名服务器地址，逐层查询</li><li>本地域名服务器<strong>向顶级域名服务器发起请求</strong>，获取权限域名服务器地址</li><li><strong>本地域名服务器向权限域名服务器发起请求，得到域名的IP地址</strong></li></ul></li><li>本地域名服务器获取IP后返回给操作系统，同时自己也会缓存IP地址，方便后续查找</li><li>操作系统将IP地址返回给浏览器，同时自己也会将IP地址缓存起来</li><li>浏览器得到域名对应IP地址，同时把IP地址缓存起来</li></ul></li><li><p><strong>建立TCP连接（三次握手）：</strong>获取IP地址后，浏览器知道要转发的对象了，此时需要发送HTTP请求报文，这时要<strong>先通过TCP的三次握手</strong>建立浏览器与服务器间的可靠连接，<strong>保证双方都具有可靠的发送与接收能力</strong></p></li><li><p><strong>浏览器发送HTTP请求：</strong>TCP三次握手后，浏览器与服务器间建立可靠连接，浏览器可以发送HTTP请求报文，由于这些报文较大，<strong>TCP会将HTTP报文按序号分割成若干报文段并加上TCP首部，分别进行传输。接收方在收到报文段后，按序号以原来顺序重组HTTP报文</strong></p><ul><li><strong>负责传输的IP协议：</strong>TCP传输报文段时，通过IP协议进行传输，IP协议在传输时，会给报文段添加IP首部封装成IP数据报然后再传输。IP首部包含源IP地址与目标IP地址。</li></ul></li><li><p><strong>服务器响应请求：</strong>服务器收到报文段后，按序号重组一个HTTP请求报文，然后处理并返回一个HTTP响应，HTTP响应的返回过程和HTTP请求一致。</p></li><li><p><strong>断开TCP连接：</strong>浏览器与服务器不需要发送数据，TCP四次挥手断开连接。</p></li><li><p><strong>浏览器渲染界面：</strong>浏览器接收服务器返回的数据包，根据浏览器的渲染机制对数据渲染。</p></li></ul><h1 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h1><p>Cookie将数据保存在客户端（浏览器），Session将数据保存在服务器。</p><p>Session相对来说安全性更高。Cookie常用于我们网站保存账号密码或一些基本信息，Session常用于购物车，在不同页面间跟踪信息。</p><h1 id="HTTPS（应用层）"><a href="#HTTPS（应用层）" class="headerlink" title="HTTPS（应用层）"></a>HTTPS（应用层）</h1><h2 id="HTTP1-0与HTTP1-1区别"><a href="#HTTP1-0与HTTP1-1区别" class="headerlink" title="HTTP1.0与HTTP1.1区别"></a>HTTP1.0与HTTP1.1区别</h2><p><strong>长连接与短连接</strong>。<strong>HTTP1.0默认使用短连接，HTTP1.1默认使用长连接</strong>。短链接即每次客户端与服务端进行HTTP操作都要建立连接，任务结束就关闭，开销大。长连接则是在响应头中加入Connection:keep-alive的标识，在规定时间内客户端与服务端的连接都不会关闭。</p><p><strong>缓存处理</strong>。HTTP1.0主要使用header里的 If-Modified-Since，Expires 来做缓存判断的标准，<strong>HTTP1.1引入更多的缓存控制策略</strong>如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match 等更多可选择的缓存头来控制缓存策略。</p><p><strong>带宽优化及网络连接使用</strong>。<strong>HTTP1.0存在带宽浪费现象</strong>，如客户端只需要某对象的部分内容，但服务器却送来了整个对象，并且不支持端点续传功能。<strong>HTTP1.1在请求头加入了range头域，它允许只请求某个资源的部分内容</strong>，对应返回码206，这样就方便了开发者进行选择，并充分利用带宽和连接。</p><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><ul><li><p><strong>端口：</strong>HTTP的URL由 “http://“ 起始，其默认端口是80，HTTPS的URL由 “https://“ 起始，其默认端口是443。</p></li><li><p><strong>安全性与资源消耗：</strong>HTTP协议运行在TCP上，<strong>是明文传输，客户端和服务器无法验证对方身份</strong>。HTTPS是运行在<strong>SSL/TLS上的HTTP协议</strong>，SSL/TLS运行在TCP上，所有<strong>传输内容是加密过的，采用的是对称加密</strong>，但对称加密的密钥对服务器方的证书今次行了非对称加密。</p><p>总结就是HTTP的安全性没有HTTPS高，但HTTPS会比HTTP消耗更多的服务器资源。</p></li></ul><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>采用单钥进行加密的方法，同一个密钥可以进行加密与解密。</p><p>优点：算法公开，加密速度快、效率高，适合长数据使用。</p><p>缺点：密钥传输不安全，易破解，且密钥管理麻烦。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>加密与解密时分别使用两个密钥，即加密使用公钥，解密使用私钥。</p><p>优点：密钥分配简单，密钥保存量少，安全，即使传输密文被拦截，若只获取公钥，没有私钥时无法破解密文的。</p><p>缺点：算法复杂，加密效率低，速度慢。</p><p>非对称加密可以保证数据传输过程的安全，因为拦截只能获取部分密钥，无法解密，除非获取一来一回的两个加密密钥。</p><h2 id="常用HTTP请求方法"><a href="#常用HTTP请求方法" class="headerlink" title="常用HTTP请求方法"></a>常用HTTP请求方法</h2><ul><li>GET：从服务器获取请求</li><li>HEAD：从服务器获取请求首部信息</li><li>POST：向服务器发送需要处理的数据</li><li>PUT：将请求的主体存储到服务器上</li><li>DELETE：从服务器上删除数据</li><li>TRACE：对可能经过代理服务器传送到服务器的报文进行追踪</li><li>OPTIONS：决定在服务器上可执行哪些方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计网模型&quot;&gt;&lt;a href=&quot;#计网模型&quot; class=&quot;headerlink&quot; title=&quot;计网模型&quot;&gt;&lt;/a&gt;计网模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;OSI七层&lt;/p&gt;
&lt;p&gt;物理层、数据链路层、网络层、传输层、会话层、表示层、网络层&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="八股" scheme="http://aidianfirst.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java八股文--并发</title>
    <link href="http://aidianfirst.com/2021/09/02/%E5%85%AB%E8%82%A1/Java%E5%85%AB%E8%82%A1%E6%96%87-%E5%B9%B6%E5%8F%91/"/>
    <id>http://aidianfirst.com/2021/09/02/%E5%85%AB%E8%82%A1/Java%E5%85%AB%E8%82%A1%E6%96%87-%E5%B9%B6%E5%8F%91/</id>
    <published>2021-09-02T08:28:38.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li><p><strong>进程（资源管理最小单位）：</strong></p><p>程序的一次执行过程，运行程序的基本单位，进程是动态的。系统执行一个程序即进程从创建，运行到死亡的过程。</p><p>在Java中，启动main函数即启动了一个JVM的进程，main所在的线程是进程中的一个线程。</p></li><li><p><strong>线程（任务调度最小单位）：</strong></p><p>线程是比进程更小的执行单位，一个进程在执行过程中可以产生多个线程，同类线程之间共享进程的<strong>堆和方法区资源</strong>，但每个线程有自己的<strong>程序计数器、虚拟机栈、本地方法栈</strong>。</p><p>系统在产生一个线程，或在多个线程之间切换工作时，其负担比操作进程小得多，因此线程也称为轻量级进程。</p></li></ul><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li><strong>新建（NEW）</strong>：线程创建未启动，此时还未调用start。</li><li><strong>可运行（RUNABLE）</strong>：线程处于运行状态或等待资源调度进入运行状态。</li><li><strong>阻塞（BLOCKED）</strong>：线程等待获取锁。</li><li><strong>无限期等待（WAITING）</strong>：执行Object.wait()或Thread.join()进入，没有主动唤醒则一直等待。</li><li><strong>限期等待（TIMED_WAITING）</strong>：自动唤醒，即等待时设置了时间，sleep() 或 wait() 或 join()设置时间。</li><li><strong>死亡（TERMINATED）</strong>：线程结束或异常结束。</li></ul><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li><strong>并发：</strong>同一时间段，可以多个任务执行，但单位时间不一定同时执行。</li><li><strong>并行：</strong>单位时间内，多个任务同时执行。</li></ul><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><ul><li><strong>NEW：新建</strong>，线程被构建，但还没有调用start()方法</li><li><strong>RUNNABLE：可运行</strong>，一般操作系统细分为READY（就绪）和RUNNING（运行），Java中3统称位运行中</li><li><strong>BLOCKED：阻塞</strong>，线程因为锁被阻塞</li><li><strong>WAITING：等待</strong>，线程进入等待状态，进入该状态的线程需要依靠其他线程的通知才可返回运行状态</li><li><strong>TIME_WAITING：超时等待</strong>，该状态在等待基础上增加了超时限制，超时后线程自行返回运行状态</li><li><strong>TERMINATED：终止</strong>，表示线程已执行完毕</li></ul><h2 id="守护线程Daemon"><a href="#守护线程Daemon" class="headerlink" title="守护线程Daemon"></a>守护线程Daemon</h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p><strong>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</strong></p><p>main() 属于非守护线程。</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>线程执行过程中会有自己的<strong>运行条件和状态（上下文）</strong>，一般出现以下情况，线程会从占用CPU状态中退出：</p><ul><li>主动让出CPU，例如调用sleep()、wait()进入睡眠、等待状态</li><li>时间片用完，操作系统防止一个进程或线程长时间占用CPU，使其他进程后线程无用。</li><li>调用阻塞类型的系统中断，例如请求IO，线程被阻塞</li><li>线程终止/结束运行</li></ul><p>前三种都会发生线程切换，<strong>线程切换时要保存当前线程的上下文。当下次线程占用CPU时恢复现场，并加载下一个将占用CPU的线程上下文。这就是上下文切换</strong>。</p><h2 id="线程调度的方法"><a href="#线程调度的方法" class="headerlink" title="线程调度的方法"></a>线程调度的方法</h2><ul><li>sleep()：线程定时休眠，进入阻塞状态，不会释放锁。</li><li>wait()：线程进入阻塞状态，释放持有的对象的锁。</li><li>join()：在A线程中调用B线程的join()，A线程进入阻塞状态，直到B线程结束。</li><li>yield()：线程让步，当前线程由运行状态进入就绪状态，让出资源，所有线程重新争取资源。</li></ul><h2 id="sleep与wait区别"><a href="#sleep与wait区别" class="headerlink" title="sleep与wait区别"></a>sleep与wait区别</h2><ul><li>wait()是Object方法，sleep()是Thread方法</li><li>sleep不释放锁，wait释放锁</li><li>wait没有设置时间，只能被notify()、notifyAll()主动唤醒。</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>多个线程循环阻塞，循环等待其他线程释放资源，而产生死锁必须具备四个条件：</p><ul><li><strong>互斥条件：</strong>资源任何时刻只有一个线程占用，不能多个线程共用</li><li><strong>请求与保持条件：</strong>一个进程因请求资源阻塞时，对已获取资源保持不放</li><li><strong>不可剥夺条件：</strong>进程已获取的资源在未使用完之前，是不能被其他进程强行剥夺的，只可使用完后自行释放</li><li><strong>循环等待条件：</strong>若干进程之间的循环等待资源关系形成环</li></ul><h2 id="预防与避免线程死锁"><a href="#预防与避免线程死锁" class="headerlink" title="预防与避免线程死锁"></a>预防与避免线程死锁</h2><p><strong>只需破坏任意一个死锁的必要条件即可预防死锁。</strong></p><ul><li><strong>破坏互斥：</strong>硬件资源实现同时访问可破坏，软件资源一般无法打破</li><li><strong>破坏请求与保持：</strong>一次性申请全部的资源</li><li><strong>破坏不可剥夺：</strong>占用部分资源的进程进一步申请其他资源时，若申请不到，可主动释放自己占用的资源</li><li><strong>破坏循环等待：</strong>通过按序申请资源来预防。按规定顺序申请资源，释放时则反序执行。</li></ul><p><strong>避免死锁：</strong>一般可在资源分配时，通过算法（银行家算法等）对资源进行合理分配来避免死锁。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="内存模型JMM"><a href="#内存模型JMM" class="headerlink" title="内存模型JMM"></a>内存模型JMM</h2><p>Java内存模型规定所有变量都存储在<strong>主内存（共享变量）</strong>，每条线程还有自己的<strong>工作内存</strong>，线程在工作内存中保存了被该线程使用的变量的<strong>主内存副本</strong>。</p><h2 id="并发特性"><a href="#并发特性" class="headerlink" title="并发特性"></a>并发特性</h2><ul><li><p><strong>原子性（synchronized、原子类）</strong></p><p>一次或多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。</p></li><li><p><strong>可见性（volatile、synchronized、final）</strong></p><p>当一个线程修改了共享变量的值时，其他线程能立即得知这个修改。</p></li><li><p><strong>有序性（volatile、synchronized）</strong></p><p>本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</p><p>也就是说代码编写顺序和其执行顺序可能不同。可能会通过指令重排进行优化导致乱序执行。</p></li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>synchroized解决多线程间访问资源的同步性，它可以保证被修饰的方法或代码块在任意时刻都只有一个线程执行。</strong></p><p>Java早期版本，syn属于重量级锁，效率低。JDK6后对syn进行了大量优化。</p><ul><li><p>syn修饰<strong>类</strong>，作用对象是这个类的所有对象</p></li><li><p>syn修饰<strong>实例方法</strong>，作用于当前对象实例加锁，进入同步方法前需要<strong>获取当前对象实例的锁</strong>。</p></li><li><p>syn修饰<strong>静态方法</strong>，给当前类加锁，作用于当前类的私所有对象实例，进入同步方法前需要<strong>获取当前class的锁</strong>。</p></li><li><p>syn修饰<strong>代码块</strong>，指定加锁的对象，对指定的 对象/类 加锁，进入同步方法前<strong>获取对应指定对象/class的锁</strong>。</p></li></ul><p>构造方法不能被syn修饰，构造方法本身就是线程安全的。</p><h2 id="锁升级流程"><a href="#锁升级流程" class="headerlink" title="锁升级流程"></a>锁升级流程</h2><p>锁主要存在<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>这四个状态。它们随着竞争逐渐升级。锁可以升级但不可以降级，这种策略是为了提高获得锁和释放锁的效率。</p><p>锁升级其实就是优化，除此之外还有锁消除和锁粗化。</p><ul><li><p><strong>偏向锁（第一个获取锁的线程）</strong></p><p>无竞争情况下把整个同步消除掉，CAS操作都不执行。一旦出现另外的一个线程去尝试获取这个锁的情况，偏向锁马上失效。</p><p>偏向锁是只针对一个线程的，线程获取锁后不会有解锁的操作，因为是单一线程。这样可以减少开销，但如果有两个线程来竞争锁，偏向锁就会失效，并升级为轻量级锁。</p></li><li><p><strong>轻量级锁（CAS）</strong></p><p>无竞争情况下使用CAS操作去消除同步使用的互斥量。</p><p>轻量级锁使用CAS进行操作，实现锁的获取。当锁竞争十分严重的情况下，将轻量级锁升级为重量级锁。</p></li><li><p><strong>自旋锁</strong></p><p>由于轻量级锁是CAS实现，CAS也就涉及到了自旋锁，自旋就是循环等待锁释放。</p><p>轻量级锁竞争失败时，会进行自旋，自旋成功获取锁，依旧是轻量级锁，自旋获取失败，则膨胀为重量级锁。</p></li><li><p><strong>重量级锁（互斥量 mutex）</strong></p><p>重量级锁是直接让线程进入堵塞状态，当持有锁的线程释放锁后，唤醒堵塞的线程，然后线程再次竞争锁。</p></li></ul><h2 id="volatile与synchronized区别"><a href="#volatile与synchronized区别" class="headerlink" title="volatile与synchronized区别"></a>volatile与synchronized区别</h2><ul><li>volatile效率比synchronized效率高，volatile只能修饰变量，synchronized可修饰方法和代码块。</li><li>volatile保证有序性、可见性，但不保证原子性。synchronized有序性、可见性、原子性都可以保证。</li><li>volatile用于解决变量在多线程之间的可见性，synchronized可解决多个线程之间访问资源的同步性。</li><li>volatile防止指令重排。</li></ul><h2 id="ReentrantLock可重入锁"><a href="#ReentrantLock可重入锁" class="headerlink" title="ReentrantLock可重入锁"></a>ReentrantLock可重入锁</h2><p>手动调用lock()、unlock()方法，来获取释放锁，一般配合try-finally，操作内容写在try中，在finally中保证可以释放锁。基于AQS。</p><h2 id="syn和Reen对比"><a href="#syn和Reen对比" class="headerlink" title="syn和Reen对比"></a>syn和Reen对比</h2><ul><li>syn是关键字，属于JVM层面。Reen是属于JDK层面，实现了Lock接口。</li><li>syn无需手动释放锁。Reen需要调用unlock()手动释放锁，一般配合try-finally保证锁被释放。</li><li>syn发生异常时，会自动释放锁，不会导致死锁。Reen如果没有主动配置try-finally去释放锁，可能会导致死锁。</li><li>syn不可中断，除非抛出异常或执行完毕。Reen可中断，使用try Lock()。</li><li>syn是非公平锁，Reen默认是非公平锁，但可以设置成公平锁。Reen构造方法传入boolean参数可指定是否创建公平锁。</li><li>syn只能唤醒一个线程或全部唤醒。Reen可以分组唤醒或精确唤醒，Reen可以绑定多个Condition对象。</li><li>都是可重入锁，自己可以重复获取自己的内部锁，可避免死锁发生。</li></ul><h2 id="ReentrantReadWriteLock（锁降级）"><a href="#ReentrantReadWriteLock（锁降级）" class="headerlink" title="ReentrantReadWriteLock（锁降级）"></a>ReentrantReadWriteLock（锁降级）</h2><p>基于AQS实现。读写锁维护一对锁，一个<strong>读锁（共享锁）</strong>和一个<strong>写锁（独占锁）</strong>。实现了ReadWriteLock接口。</p><ul><li>允许多个读线程同时访问</li><li>在写线程访问时，所有读线程和写线程都会被阻塞</li><li>和ReentrantLock一样，支持非公平锁和公平锁。</li></ul><p><strong>锁降级</strong></p><p><strong>锁降级是一个为了保证数据可见性的操作</strong>。如果线程连续两次对同一个变量进行写操作，然后执行其他逻辑最后输出变量。会发现两次变量输出都是第二次修改的变量值，第一次修改被覆盖了，如果我们使用锁降级，在写锁中加入读锁然后释放写锁，当第二个线程进来时由于第一个线程的读锁未释放会等待，直到第一次修改的逻辑全部执行完后释放读锁。此时变量值展示是第一次修改，然后第二次修改才会进行，最后展示第二次修改的变量值。</p><p>锁降级保证数据的可见性，防止其他线程篡改数据。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><ul><li>需要读写的内存位置 V</li><li>变量进行比较的旧值 A</li><li>变量拟写入的新值 B</li></ul><p>当内存位置V的值等于旧值A，说明未修改过，位置V的值更新为B，否则不进行操作。CAS一般是自旋的，不断的重试。CAS由CPU支持的原子操作，原子性在硬件层面得到保证。</p><p>若是竞争大的场景，不建议使用CAS，会导致频繁自旋。</p><h3 id="版本号控制"><a href="#版本号控制" class="headerlink" title="版本号控制"></a>版本号控制</h3><p>全局定义一个版本号，每次更新前先读取数据，并查看版本号，进行写入操作时会再次查看版本号，两次版本号一致，则说明操作执行过程中没有其他线程干扰，完成更新操作，并使版本号+1。不一致则操作失败。</p><p>版本号一般加在数据库表中，让读写操作无干扰。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>内存位置V的值，前后两次读取值都是A，不能它没有被修改过，因为可以进行二次修改即ABA，最后读取的还是A值。</p><p>解决：</p><ul><li>版本号</li><li>使用boolean变量，表示是否修改过</li><li>原子类</li></ul><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLoacal让每一个线程绑定自己的值，在里面存储每个线程的私有数据。</p><p>每一个访问ThreadLocal变量的线程都会有这个变量的本地副本，通过get、set方法对变量进行操作，从而避免线程安全问题。</p><p>在我的商城项目中，通过ThreadLocal解决了Service层获取session内信息的问题。首先MVC拦截器会检查请求的session是否存在，若存在请求通过并将信息set到ThreadLocal中，然后我们在Service层处理业务逻辑时就可以通过get得到相应的信息。</p><p>ThreadLocal相当于维护了一个Map，KV存储。K是弱引用，V是强引用，可能产生K = null的情况，在ThreadLocal调用完后最好执行 remove() 防止内存泄露。</p><p>使用get、set不会导致V内存泄露，只有线程长时间不被使用才会导致GC将K清理。</p><h1 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h1><h2 id="Runnable接口（推荐）"><a href="#Runnable接口（推荐）" class="headerlink" title="Runnable接口（推荐）"></a>Runnable接口（推荐）</h2><p>实现Runnable接口，重写run方法，在执行类中声明一个Thread对象，并传入自定义的Runnable对象，然后Thread对象执行start方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Callable接口（有返回值，使用FutureTask封装）"><a href="#Callable接口（有返回值，使用FutureTask封装）" class="headerlink" title="Callable接口（有返回值，使用FutureTask封装）"></a>Callable接口（有返回值，使用FutureTask封装）</h2><p>实现Callable接口，重写call方法，和Runnable不同，<strong>可以有返回值</strong>，执行线程需要先<strong>通过FutureTask封装</strong>，然后声明Thread对象传入FutureTask对象，执行start方法启动线程。</p><p>注意Thread对象参数是Runnable型，而FutureTask是继承Runnable的，所以通过Callable实现线程，需要FutureTask封装。</p><p>FutureTask的get方法可以取出Callable的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">250</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Thread类（实现Runnable接口）"><a href="#Thread类（实现Runnable接口）" class="headerlink" title="Thread类（实现Runnable接口）"></a>Thread类（实现Runnable接口）</h2><p>Thread类实现了Runnable接口，我们也是通过重写run方法。然后直接声明自定义的Thread对象，执行它的start方法就可以启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现与继承区别"><a href="#实现与继承区别" class="headerlink" title="实现与继承区别"></a>实现与继承区别</h2><p>Java特性多实现，单继承，肯定是实现接口更好，且继承整个Thread类开销过大。</p><h2 id="run和start区别"><a href="#run和start区别" class="headerlink" title="run和start区别"></a>run和start区别</h2><p>run是线程默认执行的方法，start是启动线程，线程进行异步执行，如果没有start，直接执行run就是在当前线程调用了一个普通方法而已。</p><h1 id="线程池（ThreadPoolExecutor）"><a href="#线程池（ThreadPoolExecutor）" class="headerlink" title="线程池（ThreadPoolExecutor）"></a>线程池（ThreadPoolExecutor）</h1><h2 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(</span><br><span class="line">    <span class="keyword">int</span> corePoolSize,</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">    TimeUnit unit,</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">    ThreadFactory threadFactory,</span><br><span class="line">    RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ul><li><p><strong>corePoolSize</strong></p><p>核心线程数，线程池维护的一个最小线程数量，只要线程池不销毁就一直存在，除非设置allowCoreThreadTimeOut</p></li><li><p><strong>maximumPoolSize</strong></p><p>最大线程数，不会无限创建线程，如果阻塞队列无限大，这个参数就没意义了。</p></li><li><p><strong>keepAliveTime</strong></p><p>空闲线程存活时间，当前线程数大于核心线程数时，在keepAliveTime时间后，超过核心线程数的空闲线程被销毁</p></li><li><p><strong>unit</strong></p><p>keepAliveTime的时间单位</p></li><li><p><strong>workQueue</strong></p><p>阻塞队列用来储存等待执行任务的队列，新任务到来时会先判断线程数是否达到核心线程数，若达到则先在队列中进行等待，队列满了则判断最大线程数是否饱和，未饱和则FIFO执行任务，饱和执行拒绝策略。</p></li><li><p><strong>threadFactory</strong></p><p>线程创建工厂，可自定义</p></li><li><p><strong>handler</strong></p><p>饱和策略，任务达到上限，可拒绝执行任务，有多种拒绝策略</p><ul><li>AbortPolicy：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理</li><li>CallerRunsPolicy：由调用线程池execute()方法的线程 执行被拒绝的任务，强行保证信息不丢失，但效率低。</li><li>DiscardPolicy：直接丢弃新任务</li><li>DiscardOldestPolicy：丢弃最早未被处理的任务</li></ul></li></ul><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><ul><li><p><strong>FixedThreadPool</strong></p><p>固定大小的线程池，core和max都是我们传入的数值，也就是最大线程数就是核心线程数，没有非核心线程，线程不可回收。</p></li><li><p><strong>SingleThreadExecutor</strong></p><p>core=max=1，只有一个线程的线程池，单线程线程池逐个执行任务，可保证任务的执行顺序，先进先出。</p></li><li><p><strong>CaheedThreadPool</strong></p><p>core = 0，max = int的最大值，没有核心线程，非核心线程是 int_max值。所有都是空闲线程都可回收。</p></li><li><p><strong>ScheduledThreadPool</strong></p><p>执行周期性或定时任务的线程池。</p></li></ul><h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/45.png" alt="45.png"></p><ul><li>poolSize &lt; core，直接创建核心线程执行任务。</li><li>poolSize &gt; core，将任务放到阻塞队列FIFO。</li><li>阻塞队列满了 &amp;&amp; poolSize  &lt; max，创建非核心线程执行任务。</li><li>poolSize &gt; max，执行拒绝策略。</li></ul><h2 id="为什么推荐自定义线程池"><a href="#为什么推荐自定义线程池" class="headerlink" title="为什么推荐自定义线程池"></a>为什么推荐自定义线程池</h2><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>，官方设置其阻塞队列时，直接使用 LinkedBlockingQueue()，会走无参构造器，无参构造将容量设置为 Integer.MAX_VALUE，会导致大量请求堆积，最终导致OOM内存溢出。</li><li><code>CaheedThreadPool</code> 和 <code>ScheduledThreadPool</code>，官方设置它们的最大线程数都是 Integer.MAX_VALUE，也就是说可以大量创建线程，可能导致OOM内存溢出。</li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>AbstractQueuedSynchronizer 是一个构建锁和同步器的框架，例如ReentrantLock、Semaphore都是基于AQS实现的。</p><ul><li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即 将暂时获取不到锁的线程加入到队列中。</li></ul><p>其中CLH是一个FIFO双向队列，AQS将请求共享资源的线程封装成CLH的一个Node来实现锁的分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>AQS定义了一个成员变量state表示同步状态，AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。我们后续一些基于AQS实现的类，其操作的限制数就是这里的state。</p><h2 id="AQS对资源共享的方式"><a href="#AQS对资源共享的方式" class="headerlink" title="AQS对资源共享的方式"></a>AQS对资源共享的方式</h2><ul><li>独占：只有一个线程执行，ReentrantLock</li><li>共享：多线程同时执行，CountDownLatch、CyclicBarrier、Semaphore、</li></ul><h2 id="CountDownLatch（倒计时器）"><a href="#CountDownLatch（倒计时器）" class="headerlink" title="CountDownLatch（倒计时器）"></a>CountDownLatch（倒计时器）</h2><p>基于AQS实现，CountDownLatch 允许数个线程阻塞在一个地方，直到所有线程的任务执行完毕。</p><p>CountDownLatch 会维护一个计数器 cnt，每当一个等待线程完成任务就是执行 countDown() 方法，使计数器值-1，只有当 cnt 减至0时，那些调用 await() 进入等待的线程会被唤醒。</p><p>一般 await() 配合任务调用使用，每个线程完成任务后就 countDown()，然后执行 await() 等待其他线程完成任务。</p><h2 id="CyclicBarrier（循环栅栏）"><a href="#CyclicBarrier（循环栅栏）" class="headerlink" title="CyclicBarrier（循环栅栏）"></a>CyclicBarrier（循环栅栏）</h2><p>基于ReentrantLock实现，而ReentrantLock是基于AQS实现的。用来控制多个线程互相等待。</p><p>CyclicBarrier 让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障，屏障才会被打开，这一组线程才可以继续执行。</p><p>CyclicBarrier 内部也是使用计数器实现，线程执行 await() 方法之后计数器会-1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountDownLatch 类似，但 CyclicBarrier 可以调用 reset() 方法进行循环使用。而 CountDownLatch  只能被调用一次。</p><h2 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h2><p>基于AQS实现，Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>acquire() 阻塞线程，从信号量获取许可</p><p>release() 增加许可，可释放一个被阻塞的 acquire()。</p><p>Semaphore用来维护许可的数量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发基础&quot;&gt;&lt;a href=&quot;#并发基础&quot; class=&quot;headerlink&quot; title=&quot;并发基础&quot;&gt;&lt;/a&gt;并发基础&lt;/h1&gt;&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;</summary>
      
    
    
    
    <category term="八股" scheme="http://aidianfirst.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Java八股文</title>
    <link href="http://aidianfirst.com/2021/08/25/%E5%85%AB%E8%82%A1/Java%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://aidianfirst.com/2021/08/25/%E5%85%AB%E8%82%A1/Java%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2021-08-25T02:01:10.000Z</published>
    <updated>2023-07-30T11:20:17.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="8种基本数据类型及包装类"><a href="#8种基本数据类型及包装类" class="headerlink" title="8种基本数据类型及包装类"></a>8种基本数据类型及包装类</h2><ul><li>byte（8位、1字节）Byte</li><li>char(16位、2字节）Character</li><li>short（16位、2字节）Short</li><li>int（32位、4字节）Integer</li><li>long（64位、8字节）Long</li><li>float（32位、4字节）Float</li><li>double（64位、8字节）Double</li><li>boolean（true、false）Boolean</li></ul><h2 id="包装类的装箱与拆箱"><a href="#包装类的装箱与拆箱" class="headerlink" title="包装类的装箱与拆箱"></a>包装类的装箱与拆箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱 Integer a = Integer.valueOf(10);</span></span><br><span class="line">Integer a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 拆箱 int b = a.intValue();</span></span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>Integer装箱源码，如果缓存池已存在数值，那么就直接返回该对象，不用创建一个新对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以以下结果是true，j是从缓存池中取的相同对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i.equals(j));</span><br></pre></td></tr></table></figure><p>缓存池是有范围的，如Integer是-128~127，范围外创建就是两个对象，不会从常量池拿取。<strong>注意float和double型是没有缓存池的</strong>。</p><h1 id="引用数据类型的浅拷贝与深拷贝"><a href="#引用数据类型的浅拷贝与深拷贝" class="headerlink" title="引用数据类型的浅拷贝与深拷贝"></a>引用数据类型的浅拷贝与深拷贝</h1><p>今天做唯品会笔试时，发现set复制出了问题，兜兜转转找到了问题的根源，引用数据类型以及深浅拷贝的问题。于是便补上了这一块的笔记。</p><p>首先Java分为基础数据类型和引用数据类型，这个我们都知道。对于八大基础数据类型，没有深浅拷贝的说法。我们主要是讨论引用数据类型。</p><ul><li><p>浅拷贝</p><p>简单来说，浅拷贝就是将两个引用指向同一个对象。也就是使用 “=” 进行引用传递，引用数据类型存储的是一指向对象的地址。</p><p>我们这里set和temp就是使用 “=” 进行浅拷贝，由temp对集合进行清空操作，set和temp指向的是同一对象，所以二者都为空。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;Character&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">temp = set;</span><br><span class="line">System.out.println(temp == set);<span class="comment">//true</span></span><br><span class="line">temp.clear();</span><br><span class="line">System.out.println(temp.isEmpty()); <span class="comment">//true</span></span><br><span class="line">System.out.println(set.isEmpty());<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>深拷贝</p><p>和浅拷贝相反，深拷贝就是创建一个新的对象，将原内容进行复制，仅仅是内容相同，但是是两个对象。对于容器来说可以使用 addAll() 或 putAll() 来进行深拷贝。</p><p>这里set和temp是两个不同的对象，只是内容一致，也就是说这两个引用指向了两个不同的地址，但地址的内容一样。我们通常使用深拷贝对容器进行复制操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;Character&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">temp.addAll(set);</span><br><span class="line">System.out.println(temp == set);<span class="comment">//false</span></span><br><span class="line">temp.clear();</span><br><span class="line">System.out.println(temp.isEmpty()); <span class="comment">//true</span></span><br><span class="line">System.out.println(set.isEmpty());<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a>==与equals的区别</h1><ul><li><p>==</p><ul><li>基本数据类型：比较值是否相等</li><li>引用类型：比较变量是否引用同一个对象，也就是比较引用变量的值，因为变量存储的是对象的地址</li></ul></li><li><p>equals()</p><ul><li>基本数据类型：没有equals()方法</li><li>引用类型：根据当前类是否重写equals()方法<ul><li>类没有重写equals()方法：此时使用equals()相当于使用 == ，比较两个变量引用的对象地址，此时使用的equals()是Object类的方法</li><li>类重写了equals()方法：此时equasl()按其重写方法的具体内容执行操作，一般重写都是为了比较引用对象的值是否相等，Integer、String等类都对equals()进行过重写，所以它们的equals()可比较值相等</li></ul></li></ul></li></ul><p>a、b是直接创建一个abc的新对象，==不等、equals相等。</p><p>aa创建一个新对象，且放到了字符串的常量池（类似包装类的缓存池），所以bb创建时直接从常量池拿对象，也就是aa和bb是完全相同的对象，==、equals都相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String aa = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String bb = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//flase</span></span><br><span class="line">System.out.println(a == aa);<span class="comment">//flase</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(aa));<span class="comment">//true</span></span><br><span class="line">System.out.println(aa.equals(bb));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h1 id="hashCode-与equals"><a href="#hashCode-与equals" class="headerlink" title="hashCode()与equals()"></a>hashCode()与equals()</h1><p>hashCode()即获得散列值，其定义在Object类中，这代表Java中所有类都包含hashCode()。两个对象等价，其hashcode一定相等，而hashcode相等的两个对象不一定等价，这是因为散列值会发生哈希冲突，使得两个不同的对象有相同的散列值。</p><p>而我们重写equals()方法，其hashCode()也要重写，因为两个对象等价，其散列值一定相等。例如我们使用HashSet存储对象时，会先通过散列值判断，若没有相同的散列值则加入对象，有相等的值则用equals再次判断，确定是否是相同的对象。</p><p>所以<strong>HashSet是先通过hashcode判断对象，再用equals判断对象</strong>，如果我们<strong>重写equals()时不重写hashCode()，则可能将两个相同的对象存放到HashSet中</strong>。而在HashSet存储中使用hashCode()还可以减少equals的判断次数，提高了执行效率，为此我们重写equals()时hashCode()也要重写，为了保证相同的对象有相同的散列值。</p><h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><p>Java只在编译阶段检测非法类型，实际执行时不检测，也就是在编译阶段就将泛型的类型擦除了。如下面的例子，list是存储Integer型的，test被list赋值也应该存储Integer的，但test添加字符串却没有问题，因为他虽然是存储Integer，但在运行时，list和test都会进行泛型擦除，视为ArrayList。可以说泛型只是表面进行限制，实际执行的时候没有用。</p><p>list添加字符串是一定不行的，因为表面上它就是用来存储Integer型的，但test虽然等于list，逻辑上是用来存储Integer的，但看上去它没有受泛型限制，所以它可以添加字符串。泛型只是在编译阶段进行限制，也就是表面限制，在实际执行阶段list、test都会被视为ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List test = list;</span><br><span class="line">test.add(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载发生在同一个类中，多个方法名相同的方法，但参数数量、参数顺序、参数类型至少有一个不同。多用于构造器重载。</p><p>注意方法返回值类型可以不同，但它不是判断重载的标准，也就是说参数没有改变时，只有返回值类型不同则不是重载。</p><p>由于子类继承父类，其父类方法在子类中全部实现，此时我们在对方法重载相当于在子类中重载。也就是同一个类，并没有子类对父类重载。</p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>重写是子类对父类进行操作，方法名、参数必须完全相同，访问权限&gt;=父类，返回值类型和抛出异常可以是父类返回类型或其子类型。</p><p>父类是private/final/static修饰，其子类不能重写。子类同名方法相当于定义了一个新方法。</p><p>构造方法也不能被子类重写。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String的特点"><a href="#String的特点" class="headerlink" title="String的特点"></a>String的特点</h2><p>String被声明为final，String对象不可变、不可继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p>String不可变性，使其天生具有线程安全性。</p><h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><ul><li>String不可变，线程安全，每次发生改变都会新生成一个对象。<strong>操作少量数据可用。</strong></li><li>StringBuffer可变，其内部方法加了同步锁，是线程安全的，改变对象是对该对象本身操作。<strong>多线程操作字符串可用。</strong></li><li>StringBuilder可变，不是线程安全。<strong>单线程操作字符串可用。</strong></li></ul><h2 id="字符串常量池（String-Pool）"><a href="#字符串常量池（String-Pool）" class="headerlink" title="字符串常量池（String Pool）"></a>字符串常量池（String Pool）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a != b，这是两个对象</span></span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="comment">//c == d，</span></span><br><span class="line">String c = a.intern();</span><br><span class="line">String d = b.intern();</span><br><span class="line"><span class="comment">// c == d == e == f</span></span><br><span class="line">String e = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">String f = <span class="string">&quot;aaa&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里new String是直接创建一个新对象，即a、b是两个不同对象，但值相等。</p><p>使用<strong>intern()方法</strong>会将对应字符串的值存入常量池，然后当常量池存在值相等的字符串时，直接返回常量池中的引用，所以c、d都是aaa字符串在常量池中的引用，所以是相同对象。</p><p>e、f就不用说了，会直接引用常量池，没有则新建对象，并放入常量池。</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li>final修饰的类不可继承，final类中所有成员方法被隐式指定为final方法</li><li>final修饰方法不可重写</li><li>final修饰的变量是常量<ul><li>基础数据类型，数值在初始化后不可更改</li><li>引用类型，初始化后不可指向另一个对象</li></ul></li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li><p>静态变量（类变量），静态方法</p><p>被static修饰的成员属于类，不单属于类的某个对象，被类中所有对象共享。可通过类名直接调用。</p></li><li><p>静态代码块：在类初始化时运行一次。该类无论创建多少次，静态代码块只执行一次。</p></li><li><p>静态内部类</p></li><li><p>静态导包：import static，可导入某个类的指定静态资源。</p></li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>用于引用类的当前实例，指向本类对象。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>子类访问父类的变量和方法，指向父类对象。</p><h1 id="方法初始化顺序"><a href="#方法初始化顺序" class="headerlink" title="方法初始化顺序"></a>方法初始化顺序</h1><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>main方法</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><p>父 &gt; 子，静态最优先</p><p>这里看一个特殊例子，我们声明一个全局静态对象，它在调用构造方法时会先执行普通方法块，但静态变量以及静态方法块相互不影响，只有按序走到对应静态变量或静态方法块时，这些静态才会执行，且只执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> A a1 = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">static</span> A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;222222222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">    11111111</span></span><br><span class="line"><span class="comment">    11111111</span></span><br><span class="line"><span class="comment">    222222222</span></span><br><span class="line"><span class="comment">    11111111</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><ul><li><p>面向过程：过程最重要，需要顺序执行按部就班，当性能是主要考量因素时使用，一般都是编译成机械码后运行，所以效率高。主要是后期不好维护，难以重复利用。</p></li><li><p>面向对象：有封装、继承、多态的特性，易维护、易复用、易扩展，能降低耦合性，但性能相对于面向过程可能低一些。</p></li></ul><h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><ul><li>成员变量（类）：可以被public、private、static、final等修饰，没有赋初值会自动以默认值赋值。</li><li>局部变量（方法、代码块）：一般不可被修饰符修饰，但final可以。没有赋初值会报错，局部变量不会以默认值自动赋值。</li></ul><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ul><li><p>封装</p><p>实体类的封装，例如项目中封装数据库表的字段成一个对象，然后对它进行赋值、取值操作。</p></li><li><p>继承</p><p>子类继承父类，提高代码的复用性，子类可以包括父类所有属性和方法（包括私有），但<strong>私有属性和方法是不能访问的，只是拥有</strong>。</p></li><li><p>多态（向上转型）</p><p>简单说一个对象有多种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列表可以是数组或链表两种实现</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br></pre></td></tr></table></figure><p>要有继承或实现的关系，子类对父类方法进行了重写，以实现多态。</p></li></ul><h1 id="反射（框架中大量使用反射机制）"><a href="#反射（框架中大量使用反射机制）" class="headerlink" title="反射（框架中大量使用反射机制）"></a>反射（框架中大量使用反射机制）</h1><p>通过forName、.class等方式获取类，然后再通过操作Field、Method、Constructor对类的元素、方法等进行操作。</p><h1 id="异常（Throwable）"><a href="#异常（Throwable）" class="headerlink" title="异常（Throwable）"></a>异常（Throwable）</h1><p>Throwable类是所有异常的共同祖先，其有两个重要子类Exception（异常）和Error（错误）。其中异常可以被try-catch捕获，错误无法处理。</p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/21.png" alt="21.png"></p><ul><li><p>Exception：程序可处理的异常，通过catch进行捕获</p><ul><li><p>check可查异常：在源码中必须显性进行捕获处理，会在编译器进行检查。</p><p>例：ClassNotFoundException、SQLException等</p></li><li><p>uncheck不可查异常：运行时异常（RuntimeException），通常是代码的逻辑错误，根据需求进行捕获，并不在编译期强制要求。</p><p>例：NullPointerException、ArrayIndexOutOfBoundsException等</p></li></ul></li><li><p>Error：程序无法处理的错误，如JVM运行错误、JVM内存不够等错误，该异常发生时，JVM会将线程终止。</p></li></ul><h1 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h1><h2 id="序列化（serialization）"><a href="#序列化（serialization）" class="headerlink" title="序列化（serialization）"></a>序列化（serialization）</h2><ul><li>序列化：将Java对象转换为二进制字节流的过程。</li><li>反序列化：将序列化生成的二进制字节流转换成Java对象的过程。</li></ul><p>在Java中序列化，是对class对象进行操作，而在C++中，结构体定义的数据结构和class对应的对象都可以序列化。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>使用<strong>transient</strong>关键字，阻止被修饰的变量进行序列化，对象被反序列化时，被修饰的变量不会被持久化和恢复。</p><ul><li>transient只能修饰变量，不能修饰方法、类。</li><li>transient修饰的变量，反序列化后其变量值置为类型默认值。</li><li>static变量不会序列化。因为static不属于任何对象，只属于类本身。</li></ul><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><ul><li><p>Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></li><li><p>BufferedReader（更快）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure></li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul><li>输入流、输出流</li><li>字节流、字符流（有字符流更加方便我们对一些文件字符的操作，并非使用字节处理是最好的，分情况）</li><li>节点流、处理流</li></ul><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/22.png" alt="22.png"></p><p><img src="https://cdn.jsdelivr.net/gh/aidianfirst/image/23.png" alt="23.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h1&gt;&lt;h2 id=&quot;8种基本数据类型及包装类&quot;&gt;&lt;a href=&quot;#8种基本数据类型及包装类&quot; class=&quot;head</summary>
      
    
    
    
    <category term="八股" scheme="http://aidianfirst.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
  </entry>
  
</feed>
