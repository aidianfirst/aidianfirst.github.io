<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis简单学习 | 哀殿firstの空间</title><meta name="author" content="aidianfirst"><meta name="copyright" content="aidianfirst"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis（NoSQL）安装我们redis是在linux环境下安装的，前置准备需要VM虚拟机、Xshell进行终端操作、Xftp文件传输  压缩包放置 &amp;#x2F;opt 目录下，并解压  进入解压后的redis目录，依次执行命令 这里没有自定义文件夹，会默认安装到 &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;bin 123yum"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/aidianfirst/image/icon.png"><link rel="canonical" href="http://aidianfirst.com/2021/08/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis简单学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-30 19:20:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="哀殿firstの空间" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/aidian.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/aidianfirst/image/yuanchuang2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="哀殿firstの空间"><span class="site-name">哀殿firstの空间</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis简单学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-14T03:07:28.000Z" title="发表于 2021-08-14 11:07:28">2021-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-30T11:20:17.727Z" title="更新于 2023-07-30 19:20:17">2023-07-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis简单学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis（NoSQL）"><a href="#Redis（NoSQL）" class="headerlink" title="Redis（NoSQL）"></a>Redis（NoSQL）</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们redis是在linux环境下安装的，前置准备需要VM虚拟机、Xshell进行终端操作、Xftp文件传输</p>
<ul>
<li><p>压缩包放置 /opt 目录下，并解压</p>
</li>
<li><p>进入解压后的redis目录，依次执行命令</p>
<p>这里没有自定义文件夹，会默认安装到 /usr/local/bin</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yum</span> <span class="string">install</span> <span class="string">gcc-c++</span> <span class="comment"># 安装C语言的编译环境</span></span><br><span class="line"><span class="string">make</span> <span class="comment"># 源码编译文件</span></span><br><span class="line"><span class="string">make</span> <span class="string">install</span> <span class="comment"># 执行安装</span></span><br></pre></td></tr></table></figure></li>
<li><p>我们从解压后的redis目录中，将配置文件提取出来，我就放到 /etc 目录下</p>
</li>
<li><p>编辑配置文件 redis.conf，配置守护进程模式，以便后台运行redis</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将no改为yes</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动和停止命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-server</span> <span class="string">/etc/redis.conf</span> <span class="comment"># 启动，加载配置文件后台运行</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span> <span class="comment"># 进入命令行操作redis，默认端口6379</span></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line"><span class="comment"># 在redis命令行中直接执行shutdown停止redis，然后exit退出命令行</span></span><br><span class="line"><span class="comment"># 或在bin目录下执行redis-cli shutdown</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>默认存在<strong>16个数据库</strong>，编号0~15，默认选择0号库，在命令行界面使用select  15即可切换到15号库。 </p>
<p>Redis是单线程，但通过IO多路复用可支撑高并发，<strong>单线程+IO多路复用</strong>。</p>
<p>五大数据类型：String、List、Set、Hash、Zset（有序集合）</p>
<hr>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><h2 id="Redis-键命令（key）"><a href="#Redis-键命令（key）" class="headerlink" title="Redis 键命令（key）"></a>Redis 键命令（key）</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">keys</span> <span class="string">*</span> <span class="comment"># 查询所有的键</span></span><br><span class="line"><span class="string">exists</span> <span class="string">key</span> <span class="comment"># 判断当前key是否存在</span></span><br><span class="line"><span class="string">type</span> <span class="string">key</span> <span class="comment"># 查看键的类型</span></span><br><span class="line"><span class="string">del</span> <span class="string">key</span> <span class="comment"># 删除键</span></span><br><span class="line"><span class="string">unlink</span> <span class="string">key</span> <span class="comment"># 异步删除，将键从数据空间删除，但真正的删除在后续执行</span></span><br><span class="line"><span class="string">expire</span> <span class="string">key</span> <span class="string">time</span> <span class="comment"># 设置键过期时间，过期则删除</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">key</span> <span class="comment"># 查看当前键的过期时间，-1代表永不过期，-2代表已过期</span></span><br><span class="line"><span class="string">select</span> <span class="comment"># 切换redis数据库，0~15</span></span><br><span class="line"><span class="string">dbsize</span> <span class="comment"># 键的数量</span></span><br><span class="line"><span class="string">flushdb</span> <span class="comment"># 清空当前库</span></span><br><span class="line"><span class="string">dlushall</span> <span class="comment"># 清空全部库</span></span><br></pre></td></tr></table></figure>

<h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><ul>
<li><p>简述</p>
<p>String类型是二进制安全的，Redis中字符串<strong>最大长度是512M</strong>。</p>
</li>
<li><p>相关命令（Redis单线程，操作具有原子性）</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span> <span class="comment"># 设置键值对，重复设置会进行值覆盖</span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span> <span class="comment"># 输入键获取值</span></span><br><span class="line"><span class="string">append</span> <span class="string">key</span> <span class="string">value</span> <span class="comment"># 在键对应值后面添加内容，返回添加后的长度</span></span><br><span class="line"><span class="string">strlen</span> <span class="string">key</span> <span class="comment"># 获取键对应值的长度</span></span><br><span class="line"><span class="string">setnx</span> <span class="string">key</span> <span class="string">value</span> <span class="comment"># 设置键值对，但不能覆盖，键已存在则设置失败</span></span><br><span class="line"><span class="string">incr/decr</span> <span class="string">key</span> <span class="comment"># 键的值是integer类型，则数值+1/-1</span></span><br><span class="line"><span class="string">incrby/decrby</span> <span class="string">key</span> <span class="string">n</span> <span class="comment"># 键的值是integer类型，则数值+n/-n</span></span><br><span class="line"><span class="string">mset/mget</span> <span class="comment"># 对多个键执行set、get操作</span></span><br><span class="line"><span class="string">msetnx</span> <span class="comment"># 多个键执行setnx，但只要有一个键重复，就执行失败</span></span><br><span class="line"><span class="string">getrange</span> <span class="string">key</span> <span class="string">&lt;起始位&gt;</span> <span class="string">&lt;终止位&gt;</span> <span class="comment"># 字符串截取起始位数据返回，左闭右闭</span></span><br><span class="line"><span class="string">setrange</span> <span class="string">key</span> <span class="string">&lt;起始位&gt;</span> <span class="string">value</span> <span class="comment"># 字符串对应位置插入值</span></span><br><span class="line"><span class="string">setex</span> <span class="string">key</span> <span class="string">time</span> <span class="string">value</span> <span class="comment"># 设置键值对，但有过期时间</span></span><br><span class="line"><span class="string">getset</span> <span class="string">key</span> <span class="string">value</span> <span class="comment">#  先取旧值，然后赋新值，key没有旧值返回nil</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据结构（sds）</p>
<p>String数据结构是<strong>简单动态字符串（sds）</strong>，是可修改的字符串，会自行扩容，但长度不能超过512M。</p>
</li>
</ul>
<h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><ul>
<li><p>简述</p>
<p>单键多值，Redis列表按插入顺序排序，是一个<strong>双向链表</strong>，可以添加元素到头尾，两头操作效率很高，中间节点操作效率低。</p>
</li>
<li><p>相关命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lpush/rpush</span> <span class="string">key</span> <span class="string">value</span> <span class="string">···</span> <span class="comment"># 从左右插入多个元素</span></span><br><span class="line"><span class="string">lpop/rpop</span> <span class="string">key</span> <span class="comment"># 从左右将数据出列，注意列表为空直接删除</span></span><br><span class="line"><span class="string">rpoplpush</span> <span class="string">key1</span> <span class="string">key2</span> <span class="comment"># 列表1右端元素出列然后插入到列表2左端</span></span><br><span class="line"><span class="string">lrange</span> <span class="string">key</span> <span class="string">&lt;起始位&gt;</span> <span class="string">&lt;终止位&gt;</span> <span class="comment"># 左端按索引位置输出列表元素，0 -1则输出全部</span></span><br><span class="line"><span class="string">lindex</span> <span class="string">key</span> <span class="string">index</span> <span class="comment"># 左端按索引取元素</span></span><br><span class="line"><span class="string">llen</span> <span class="string">key</span> <span class="comment"># 对应列表长度</span></span><br><span class="line"><span class="string">linsert</span> <span class="string">key</span> <span class="string">before/after</span> <span class="string">value</span> <span class="string">newvalue</span> <span class="comment"># 列表左端的某个值之前/之后插入新值</span></span><br><span class="line"><span class="string">lrem</span> <span class="string">key</span> <span class="string">n</span> <span class="string">value</span> <span class="comment"># 列表左端删除n个值为value的值，相当于去重</span></span><br><span class="line"><span class="string">lset</span> <span class="string">key</span> <span class="string">index</span> <span class="string">value</span> <span class="comment"># 列表左端索引位的元素替换为新值</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据结构（quicklist快速表）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53395115/article/details/118961864">https://blog.csdn.net/qq_53395115/article/details/118961864</a></p>
<p>快速表quicklist，一般数据量少就是单纯的<strong>ZipList压缩列表</strong>，当数据较多时，我们使用<strong>ZipList+LinkedList组合成quicklist快速链表</strong>。</p>
</li>
</ul>
<h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><ul>
<li><p>简述</p>
<p>类似List，但Set无重复。是String类型的无序集合，底层是哈希表。</p>
</li>
<li><p>相关命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sadd</span> <span class="string">key</span> <span class="string">value</span> <span class="string">···</span> <span class="comment"># 集合加入多个元素</span></span><br><span class="line"><span class="string">smembers</span> <span class="string">key</span> <span class="comment"># 查询集合所有值</span></span><br><span class="line"><span class="string">sismember</span> <span class="string">key</span> <span class="string">value</span> <span class="comment"># 集合中是否有对应值</span></span><br><span class="line"><span class="string">scard</span> <span class="string">key</span> <span class="comment"># 返回集合元素个数</span></span><br><span class="line"><span class="string">srem</span> <span class="string">key</span> <span class="string">value</span> <span class="string">···</span> <span class="comment"># 集合删除元素</span></span><br><span class="line"><span class="string">spop</span> <span class="string">key</span> <span class="comment"># 随机元素出集合，集合为空就删除</span></span><br><span class="line"><span class="string">smembers</span> <span class="string">key</span> <span class="string">n</span> <span class="comment"># 随机从集合取n个值，不删除</span></span><br><span class="line"><span class="string">smove</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">value</span> <span class="comment"># 将集合1的值移动到集合2</span></span><br><span class="line"><span class="string">sinter</span> <span class="string">key1</span> <span class="string">key2</span> <span class="comment"># 返回两个集合的交集</span></span><br><span class="line"><span class="string">sunion</span> <span class="string">key1</span> <span class="string">key2</span> <span class="comment"># 返回两个集合的并集</span></span><br><span class="line"><span class="string">sdiff</span> <span class="string">key1</span> <span class="string">key2</span> <span class="comment"># 返回集合1相对于集合2的差集，也就是1中2没有的部分</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据结构（dict字典）</p>
<p>Set数据结构是dict字典，字典是由哈希表实现的。类似于Java的HashSet。</p>
</li>
</ul>
<h2 id="Redis哈希（Hash-field-value）"><a href="#Redis哈希（Hash-field-value）" class="headerlink" title="Redis哈希（Hash field-value）"></a>Redis哈希（Hash field-value）</h2><ul>
<li><p>简述</p>
<p>Hash：键值对集合，也就是我们存放的 key-value，这个value是<strong>哈希类型</strong>，value也是一个键值对 <strong>field-value</strong>。Hash类型特别适合存储对象。</p>
</li>
<li><p>相关命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">key</span> <span class="string">field</span> <span class="string">value</span> <span class="comment"># 给哈希进行键值对赋值，可操作多个键值对</span></span><br><span class="line"><span class="string">hget</span> <span class="string">key</span> <span class="string">field</span> <span class="comment"># 取出哈希field对应的值</span></span><br><span class="line"><span class="string">hexists</span> <span class="string">key</span> <span class="string">field</span> <span class="comment"># 查看是否有哈希键</span></span><br><span class="line"><span class="string">hkeys</span> <span class="string">key</span> <span class="comment"># 取出哈希的所有键</span></span><br><span class="line"><span class="string">hvals</span> <span class="string">key</span> <span class="comment"># 取出哈希的所有值</span></span><br><span class="line"><span class="string">hincrby</span> <span class="string">key</span> <span class="string">field</span> <span class="string">n</span> <span class="comment"># 哈希field对应值进行增量变化，正负数均可</span></span><br><span class="line"><span class="string">hsetnx</span> <span class="string">key</span> <span class="string">field</span> <span class="string">value</span> <span class="comment"># 哈希键值对赋值，若当前哈希field已存在，则不能赋值</span></span><br><span class="line"></span><br><span class="line"><span class="string">hmset</span> <span class="string">key</span> <span class="string">&lt;field</span> <span class="string">value&gt;</span> <span class="string">···</span> <span class="comment"># 存放多个键值对，也可以使用hset进行多个键值对存储</span></span><br><span class="line"><span class="string">hmget</span> <span class="string">key</span> <span class="string">field</span> <span class="string">···</span> <span class="comment"># 取出哈希多个field的值</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据结构</p>
<ul>
<li>长度少：ZipList压缩列表</li>
<li>长度短：HashTable哈希表</li>
</ul>
</li>
</ul>
<h2 id="Redis有序集合（Zset）"><a href="#Redis有序集合（Zset）" class="headerlink" title="Redis有序集合（Zset）"></a>Redis有序集合（Zset）</h2><ul>
<li><p>简述</p>
<p>Zset和Set相当类似，都是没有重复元素的集合。但Zset的每一个元素都关联了一个<strong>分数Score</strong>，通过这个分数的值来对元素排序，<strong>集合的元素是唯一的，但其分数可以是重复的</strong>。</p>
</li>
<li><p>相关命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zadd</span> <span class="string">key</span> <span class="string">&lt;score</span> <span class="string">value&gt;</span> <span class="string">···</span> <span class="comment"># 将多个元素及其分数存放到集合中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引返回集合元素，0 -1返回全部，加上withscores还会返回元素的分数</span></span><br><span class="line"><span class="string">zrange</span> <span class="string">key</span> <span class="string">&lt;起始位&gt;</span> <span class="string">&lt;终止位&gt;</span> [<span class="string">withscores</span>]</span><br><span class="line"><span class="comment"># 集合返回分数在区间之内的元素</span></span><br><span class="line"><span class="string">zrangebyscore</span> <span class="string">key</span> <span class="string">&lt;min&gt;</span> <span class="string">&lt;max&gt;</span> [<span class="string">withscores</span>]</span><br><span class="line"><span class="comment"># 将集合中分数处于范围内的元素从大到小排序</span></span><br><span class="line"><span class="string">zrevrangebyscore</span> <span class="string">key</span> <span class="string">&lt;max&gt;</span> <span class="string">&lt;min&gt;</span> [<span class="string">withscores</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">zincrby</span> <span class="string">key</span> <span class="string">n</span> <span class="string">value</span> <span class="comment"># 将集合对应元素的分数加上n</span></span><br><span class="line"><span class="string">zrem</span> <span class="string">key</span> <span class="string">value</span> <span class="comment"># 删除对应的元素</span></span><br><span class="line"><span class="string">zcount</span> <span class="string">key</span> <span class="string">&lt;min&gt;</span> <span class="string">&lt;max&gt;</span> <span class="comment"># 返回集合处于范围的元素个数</span></span><br><span class="line"><span class="string">zrank</span> <span class="string">key</span> <span class="string">value</span> <span class="comment"># 返回元素排名</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据结构（Hash/跳跃表）</p>
<p>抽象点就等价于Java的Map &lt;String,Double&gt;</p>
<ul>
<li><p>Hash，对于field-value，Zset就相对于value-score的存储结构</p>
</li>
<li><p>跳跃表</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B7%B3%E8%A1%A8/22819833?fr=aladdin">https://baike.baidu.com/item/%E8%B7%B3%E8%A1%A8/22819833?fr=aladdin</a></p>
<p>可以和二分法比较，挺类似的。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三大特殊数据类型"><a href="#三大特殊数据类型" class="headerlink" title="三大特殊数据类型"></a>三大特殊数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><ul>
<li><p>简述</p>
<p>BItmaps本身不是一种数据类型，实际上是一个字符串，但它可以对字符串进行位操作。</p>
<p>我们可以把Bitmaps看作一个以位为单位的数组，数组每一位只能存储0/1，数组下标在Bitmaps称为偏移量。</p>
</li>
<li><p>相关命令</p>
 <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置偏移量的值，也就是将数组中某一位改为1</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">key</span> <span class="string">offset</span> <span class="string">value</span></span><br><span class="line"><span class="comment"># 获取偏移量的值</span></span><br><span class="line"><span class="string">getbit</span> <span class="string">key</span> <span class="string">offset</span></span><br><span class="line"><span class="comment"># 返回值为1的偏移量的个数，若有范围，则只获取二进制数范围中值为1的偏移量个数</span></span><br><span class="line"><span class="comment"># 二进制数索引从左到右，且end可取负数，-1即末位，-2倒数第二位，依此类推</span></span><br><span class="line"><span class="string">bitcount</span> <span class="string">key</span> [<span class="string">start</span> <span class="string">end</span>]</span><br><span class="line"><span class="comment"># 将多个Bitmaps(key···)进行 and(交集)、or(并集)、not(非)、xor(异或)</span></span><br><span class="line"><span class="comment"># 运算符操作后的结果保存到一个Bitmaps(destkey)</span></span><br><span class="line"><span class="string">bitop</span> <span class="string">and(or/not/xor)</span> <span class="string">destkey</span> <span class="string">&lt;key···&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>BItmaps与Set比较</p>
<p>Bitmaps空间效率更高，多用于存储活跃用户，可明显节约空间，但没有活跃用户时，使用Bitmaps反而效率低下，此时使用Set</p>
</li>
</ul>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><ul>
<li><p>简述</p>
<p>先解释一下基数，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。<strong>说白了就是数集中不重复数的个数</strong>。</p>
<p>Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
</li>
<li><p>相关命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pfadd</span> <span class="string">key</span> <span class="string">value···</span> <span class="comment"># 加入元素</span></span><br><span class="line"><span class="string">pfcount</span> <span class="string">key</span> <span class="comment"># 返回键的基数</span></span><br><span class="line"><span class="string">pfmerge</span> <span class="string">destkey</span> <span class="string">&lt;key···&gt;</span> <span class="comment"># 多个数集合并</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Geospatial（GEO）"><a href="#Geospatial（GEO）" class="headerlink" title="Geospatial（GEO）"></a>Geospatial（GEO）</h2><ul>
<li><p>简述</p>
<p>Redis提供对GEO类型的支持，即地理信息。该类型就是元素的二维坐标，在地图上的经纬度。</p>
</li>
<li><p>相关命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加键的信息，经度、纬度、名称</span></span><br><span class="line"><span class="comment"># 经度范围 -180~180，纬度范围 -85.05112878~85.05112878</span></span><br><span class="line"><span class="string">geoadd</span> <span class="string">key</span> [<span class="string">longitude</span> <span class="string">latitude</span> <span class="string">member</span>]<span class="string">···</span></span><br><span class="line"><span class="comment"># 根据键、名称取经纬度</span></span><br><span class="line"><span class="string">geopos</span> <span class="string">key</span> <span class="string">member</span> </span><br><span class="line"><span class="comment"># 取两个名称地区间直线距离，可选单位：米、千米、英尺、英里</span></span><br><span class="line"><span class="string">geodist</span> <span class="string">key</span> <span class="string">member1</span> <span class="string">member2</span> <span class="string">m/km/ft/mi</span></span><br><span class="line"><span class="comment"># 以经纬度为圆心，radius为半径的范围中的地区</span></span><br><span class="line"><span class="comment"># 比如经纬度xxx方圆1000英尺的城市</span></span><br><span class="line"><span class="string">georadius</span> <span class="string">key</span> <span class="string">longitude</span> <span class="string">latitude</span> <span class="string">radius</span> <span class="string">m/km/ft/mi</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Redis小知识"><a href="#Redis小知识" class="headerlink" title="Redis小知识"></a>Redis小知识</h1><h2 id="Redis发布订阅（pub-sub）"><a href="#Redis发布订阅（pub-sub）" class="headerlink" title="Redis发布订阅（pub/sub）"></a>Redis发布订阅（pub/sub）</h2><p>Redis发布订阅是一种消息通信模式，订阅者接收，发布者发送。也就是说当ABC三个Redis客户端都订阅了channel123进入订阅模式，那么Redis客户端X向channel123发送信息，客户端ABC都会接收X发送的信息。相当于我们在视频网站上接收关注的UP的视频信息，以及朋友圈都是类似这种情况。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅频道1</span></span><br><span class="line"><span class="string">subsribe</span> <span class="string">channel1</span></span><br><span class="line"><span class="comment"># 向频道1发送信息</span></span><br><span class="line"><span class="string">publish</span> <span class="string">channel1</span> <span class="string">&lt;message&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><ul>
<li><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Jedis</p>
<p>我们通过Jedis连接redis，<strong>首先要把本机地址的bing注释掉，然后将保护模式设置为no</strong>，若还不能连接就关闭linux的防火墙。这里连接是调用Jedis构造器，有多种方法，我们视情况使用，然后Jedis的方法调用和我们redis的命令行一模一样，方法名和命令都是一一对应的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.158.129&quot;</span>,<span class="number">6379</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Redis与SpringBoot整合"><a href="#Redis与SpringBoot整合" class="headerlink" title="Redis与SpringBoot整合"></a>Redis与SpringBoot整合</h2><ul>
<li><p>yml配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.129</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 超时设置，单位ms</span></span><br><span class="line">    <span class="attr">connect-timeout:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="comment"># 连接池</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="comment"># 最大阻塞等待时间</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 连接池最大空闲连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># 最小空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Redis-事务与锁"><a href="#Redis-事务与锁" class="headerlink" title="Redis 事务与锁"></a>Redis 事务与锁</h1><h2 id="multi、exec、discard"><a href="#multi、exec、discard" class="headerlink" title="multi、exec、discard"></a>multi、exec、discard</h2><ul>
<li>multi：使用命令后，之后的所有命令都会进入一个队列，等待执行。</li>
<li>exec：把队列的命令执行，是与multi对应使用的。</li>
<li>discard：队列命令放弃执行，与multi对应使用。</li>
</ul>
<p>可以说这三个命令就是Redis里面的事务了，一个事务的所有操作都是一致的，</p>
<h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><ul>
<li><p>exec执行前出现错误：</p>
<p>也就是说multi入队时语法发生错误，此时我们执行exec时不允许的，所有命令都失败。</p>
</li>
<li><p>exec执行后出现错误：</p>
<p>multi命令入队没有发生语法错误，但可能有逻辑错误，此时exec可以执行命令，但只有错误命令会失败。</p>
</li>
</ul>
<h2 id="事务中的冲突（锁）"><a href="#事务中的冲突（锁）" class="headerlink" title="事务中的冲突（锁）"></a>事务中的冲突（锁）</h2><p>多个操作同时触发，例如3个人的公共钱包，3个人同时在消费。</p>
<ul>
<li><p>悲观锁</p>
<p>每次操作前上锁，完成操作后解锁。一个人操作时，不允许其他人操作。</p>
</li>
<li><p>乐观锁（抢票）</p>
<p>给数据加上一个辅助版本，可多人进行操作，但每次操作时比较版本，如果版本改变我们就需要变更数据到最新版本然后再执行操作。</p>
</li>
</ul>
<h2 id="watch、unwatch（监视，乐观锁）"><a href="#watch、unwatch（监视，乐观锁）" class="headerlink" title="watch、unwatch（监视，乐观锁）"></a>watch、unwatch（监视，乐观锁）</h2><p>在使用multi命令执行事务前，我们使用watch命令先监视要操作的key，如果在事务执行前key被其他命令改变，那么事务就执行失败。也就是乐观锁。</p>
<p>乐观锁可以解决秒杀的超卖现象。</p>
<p>unwatch也就是取消监视。</p>
<h2 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h2><ul>
<li><p>单独的隔离操作</p>
<p>事务命令序列化执行，不受其他客户端命令影响。</p>
</li>
<li><p>没有隔离级别</p>
<p>事务在执行前存放于队列中，在执行前任何命令都不会执行。</p>
</li>
<li><p>不保证原子性</p>
<p>事务中有部分命令执行失败，其他命令仍会执行，不会实现回滚。</p>
</li>
</ul>
<h1 id="Redis持久化操作"><a href="#Redis持久化操作" class="headerlink" title="Redis持久化操作"></a>Redis持久化操作</h1><p>官方文档：<a target="_blank" rel="noopener" href="http://www.redis.cn/topics/persistence.html">http://www.redis.cn/topics/persistence.html</a></p>
<h2 id="RDB（默认开启）"><a href="#RDB（默认开启）" class="headerlink" title="RDB（默认开启）"></a>RDB（默认开启）</h2><ul>
<li><p>简述</p>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。也就是每隔一段设定好的时间就保存一次。</p>
</li>
<li><p>RDB优点</p>
<p>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能。</p>
<p><strong>在进行大规模数据恢复时，且数据恢复的完整性不太敏感，使用RDB比AOF更高效</strong>。</p>
</li>
<li><p>RDB缺点</p>
<p><strong>最后一次持久化的数据可能会丢失</strong>。也就是在保存时间段之间Redis宕机，这段时间的数据只持久化了一部分，剩余的数据就会丢失。</p>
</li>
</ul>
<h2 id="AOF（默认不开启）"><a href="#AOF（默认不开启）" class="headerlink" title="AOF（默认不开启）"></a>AOF（默认不开启）</h2><ul>
<li><p>简述</p>
<p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。相当于记录命令，需要恢复时就重新执行。</p>
</li>
<li><p>开启AOF</p>
<p>在redis.conf配置文件中设置appendonly yes就开启了AOF，默认路径和RDB一样。</p>
<p><strong>当AOF和RDB都开启时，Redis会默认使用AOF的数据，通常AOF保存数据集比RDB更完整</strong>。</p>
</li>
<li><p>AOF同步频率设置</p>
<p>使用AOF会让你的Redis更加耐久，你可以使用不同的fsync策略：<strong>无fsync</strong>、<strong>每秒fsync</strong>、<strong>每次写的时候fsync</strong>。使用默认的每秒fsync策略，Redis的性能依然很好一旦出现故障，你最多丢失1秒的数据。</p>
<p>在redis.conf中修改，参数与上文对应<strong>appendfsync no</strong>、<strong>appendfsync everysec</strong>、<strong>appendfsync always</strong>。</p>
</li>
<li><p>AOF优点</p>
<p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 </p>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作。</p>
</li>
<li><p>AOF缺点</p>
<p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p>
<p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 </p>
</li>
</ul>
<h1 id="Redis主从复制（读写分离）"><a href="#Redis主从复制（读写分离）" class="headerlink" title="Redis主从复制（读写分离）"></a>Redis主从复制（读写分离）</h1><h2 id="配置一主二进行实验"><a href="#配置一主二进行实验" class="headerlink" title="配置一主二进行实验"></a>配置一主二进行实验</h2><ul>
<li><p>创建myredis文件夹</p>
</li>
<li><p>复制redis.conf配置文件</p>
</li>
<li><p>创建一主二从，共三个配置文件</p>
<p>三个文件分别是redis6379、redis9380、redis6381，文件内容如下，不同文件需要修改端口，然后分别以配置文件运行三个redis-server。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include &#x2F;myredis&#x2F;redis.conf</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/17.png" alt="17.png"></p>
</li>
<li><p>查看三个主机运行情况</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 端口号 进入不同主机</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span></span><br><span class="line"><span class="comment"># 使用该命令查看主从情况</span></span><br><span class="line"><span class="string">info</span> <span class="string">replication</span></span><br></pre></td></tr></table></figure></li>
<li><p>给从机设置主机，实现一主两从</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slaveof ip port</span></span><br><span class="line"><span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/18.png" alt="18.png"></p>
</li>
<li><p>效果</p>
<p>我们在主机中执行些写操作，从机会进行数据同步，我们可用在从机中读取主机中写入的数据。</p>
<p>但在从机中进行写操作会报错，我们从机只允许执行读操作。</p>
</li>
</ul>
<h2 id="主机-从机宕机"><a href="#主机-从机宕机" class="headerlink" title="主机/从机宕机"></a>主机/从机宕机</h2><p>从机挂掉后，其主从关系就消失了。</p>
<p>当我们重新该服务器设置从机时，它会从头复制主机的所有数据。</p>
<p>主机挂掉后，其主从关系不会消失。从机仍会保存主从关系，主机重启后，其主从关系和数据都没有变化。</p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ul>
<li>slave连接master，slave向master发送数据同步消息</li>
<li>master收到slave发送的同步消息，把master数据进行持久化，生成rdb文件，然后将rdb文件发送给slave，slave最后进行rdb文件读取，获取数据。</li>
<li>每次master进行写操作后，主动将数据同步到slave</li>
<li>前两点就是<strong>全量复制，由slave主动发起</strong>，最后一点即<strong>增量复制，由master发起</strong>。</li>
</ul>
<h2 id="薪火相传（二叉树、分封制）"><a href="#薪火相传（二叉树、分封制）" class="headerlink" title="薪火相传（二叉树、分封制）"></a>薪火相传（二叉树、分封制）</h2><p>也就是给主机——从机——从从机，主机下只有一台从机，第二台从机是位于第一台从机下的。和一主二从差不多，但此时从机挂掉，主机和从从机就没有连接了。</p>
<h2 id="反客为主（手动）"><a href="#反客为主（手动）" class="headerlink" title="反客为主（手动）"></a>反客为主（手动）</h2><p>当主机挂掉后，使用命令使从机变为主机，该从机后的slave不会修改主从关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<p>主机——从机——从从机，主机挂了在从机执行命令：</p>
<p>主机——从从机。</p>
<p>主机——从机，主机——从机。现在是一主二从，在主机挂掉后使用命令：</p>
<p>主机，主机——从机，使用了命令的从机变为主机，但不影响另一个从机的主从关系。</p>
<h2 id="哨兵模式（自动反客为主）"><a href="#哨兵模式（自动反客为主）" class="headerlink" title="哨兵模式（自动反客为主）"></a>哨兵模式（自动反客为主）</h2><ul>
<li><p>编写哨兵配置文件sentinel.conf</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mymaster即给监控服务器起的名字</span></span><br><span class="line"><span class="comment"># 1代表至少要有1个哨兵同意时，才可以数据迁移</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379 </span><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动哨兵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel &#x2F;myredis&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/19.png" alt="19.png"></p>
<p>很明显哨兵端口默认是26379，下面显示了监视的主机6379，和它的两个从机6380、6381，我们主机宕机后，哨兵就会从两个从机中选取一个进行自动反客为主。</p>
</li>
<li><p>反客为主</p>
<p>主机宕机后，哨兵选择一个从机变为主机，其他从机不变，而主机重启后则变为了从机。</p>
</li>
<li><p>哨兵从机选择机制，按序</p>
<ul>
<li><p>优先级数值越低越优先</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优先级，在配置文件668左右</span></span><br><span class="line"><span class="string">replica-priority</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li>
<li><p>从机与主机偏移量越大越优先</p>
<p>也就是从机与主机数据同步量越高越优先</p>
</li>
<li><p>runid越小越优先</p>
<p>runid是redis启动后会随机产生一个40位的runid</p>
</li>
</ul>
</li>
</ul>
<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h2><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。集群通过分区来提供一定程度的可用性，即使集群的部分节点失效或无法通讯，集群仍可以继续处理命令请求。</p>
<p>集群可解决Redis扩容问题，可以分摊压力，且一般采用无中心化集群配置。</p>
<h2 id="模拟搭建集群"><a href="#模拟搭建集群" class="headerlink" title="模拟搭建集群"></a>模拟搭建集群</h2><ul>
<li><p>设置六个节点79、80、81、89、90、91的配置文件，如果已经创建过，需要清空之前的rdb、aof文件。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">include</span> <span class="string">/myredis/redis.conf</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis_6379.pid</span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump6379.rdb</span></span><br><span class="line"><span class="comment"># 开启集群</span></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 设置节点配置文件名称</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-6379.conf</span></span><br><span class="line"><span class="comment"># 节点超时时效，超时集群则自动进行主从切换</span></span><br><span class="line"><span class="string">cluster-node-timeout</span> <span class="number">15000</span></span><br></pre></td></tr></table></figure></li>
<li><p>将六个节点合成集群</p>
<p>进入<strong>redis最初的安装路径的src目录</strong>，我的是在/opt/redis-6.2.5/src。</p>
<p>执行命令</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --cluster-replicas 1 表示集群中每个主机需要一个从机</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">--cluster</span> <span class="string">create</span> <span class="string">--cluster-replicas</span> <span class="number">1</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.131</span><span class="string">:6379</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.131</span><span class="string">:6380</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.131</span><span class="string">:6381</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.131</span><span class="string">:6389</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.131</span><span class="string">:6390</span> <span class="number">192.168</span><span class="number">.158</span><span class="number">.131</span><span class="string">:6391</span></span><br></pre></td></tr></table></figure></li>
<li><p>执行命令后会自动分配主从，即79、80、81为主机，89、90、91为从机。</p>
</li>
<li><p>连接操作</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为集群去中心化，我们任选一个主机当入口都是可行的</span></span><br><span class="line"><span class="comment"># 和一般的连接不同，这里加上-c表示集群</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-c</span> <span class="string">-p</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li><p>节点查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集群是如何分配的？"><a href="#集群是如何分配的？" class="headerlink" title="集群是如何分配的？"></a>集群是如何分配的？</h2><p><strong>一个集群至少需要三个主节点</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该配置指每个主机需要配置1个从机</span></span><br><span class="line"><span class="string">--cluster-replicas</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在我们分配时，主主、主从、从从之间都应处于不同IP，也就是所有节点ip都不相同，如果机器挂了，处于相同ip的节点都会挂掉，设置主从就没意义了。</p>
<h2 id="slots（哈希槽）"><a href="#slots（哈希槽）" class="headerlink" title="slots（哈希槽）"></a>slots（哈希槽）</h2><p>执行集群合成命令后，会出现这么一个反馈语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>slots代表哈希槽，这给语句说明一个Redis集群包含16384个哈希槽，数据库中每个键都属于16384个哈希槽的其中一个，插槽是0~16383，共16384个。</p>
<p>集群在创建时，会把哈希槽分割成多个区间，并分配给各个主机。集群在存放key时，会使用CRC16算法来计算key属于哪一个槽的区间，然后就由该主机节点处理相关命令。 </p>
<p>我们在集群中添加数据时，会根据计算的哈希槽值来切换主机执行命令，但添加多个值时会出现问题，因为每个值哈希槽值不一样，分配的主机又不一样。</p>
<p>解决多个值添加问题，我们可与将数据合并到一个组内，然后对组进行哈希槽计算并切换对应主机执行。但多建操作仍不方便。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里都是属于num组，看同时添加</span></span><br><span class="line"><span class="string">mset</span> <span class="string">k1&#123;num&#125;</span> <span class="number">1</span> <span class="string">k2&#123;num&#125;</span> <span class="number">2</span> <span class="string">k3&#123;num&#125;</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="哈希槽计算"><a href="#哈希槽计算" class="headerlink" title="哈希槽计算"></a>哈希槽计算</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取哈希槽对应值</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">keyslot</span> <span class="string">slots</span></span><br><span class="line"><span class="comment"># 通过哈希槽值，查看该哈希槽是都存在</span></span><br><span class="line"><span class="comment"># 注意，只能查看自己主机的哈希槽</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">countkeysinslot</span> <span class="string">number</span></span><br></pre></td></tr></table></figure>

<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>集群中主机挂掉后，其从机马上替代成为主机，主机恢复后变为从机。</p>
<p>在集群中，如果一个主机和其从机都挂掉了，我们会根据集群配置来分情况处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-require-full-coverage</span><br></pre></td></tr></table></figure>

<p>如果该配置是yes，那么整个集群都会挂掉。</p>
<p>如果配置是no，那么只有该主从哈希槽无法使用，其他主机照常运行。</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>应用服务器压力突然变大</strong>，带来大量访问，一般是先在缓存中查找，再去数据库查找，然后将数据库信息放到缓存中。</p>
<p>而此时大部分数据缓存中都没有，也就是<strong>redis命中率低</strong>，然后所有访问都会去查询数据库，此时缓存一直查不到数据，<strong>redis命中率持续降低</strong>，数据库一直承受压力，最后导致<strong>数据库崩溃</strong>。</p>
<p>简单说是<strong>大量请求的 key 不存在于缓存中</strong>，导致请求直接来到数据库，缓存失效，最后数据库崩溃，常见是因为非正常url访问导致缓存穿透。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>对空值缓存</li>
<li>设置白名单（bitmaps）</li>
<li>布隆过滤器（类似bitmaps，有优化）</li>
<li>进行实时监控， 设置黑名单</li>
</ul>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>redis某个key过期，但<strong>大量访问要使用了某个key</strong>，此时redis已经没有这个key了，所以访问都去查询数据库，导致数据库崩溃。</p>
<h2 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>预先设置热门数据：在访问高峰来临前，预先存放热门key，并增加热门key的时长。</li>
<li>实时调整key的时长，防止过期</li>
<li>加锁，逐个操作（降低效率）</li>
</ul>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>在极短时间段内，出现<strong>大量key集中过期</strong>的情况，全部访问都去访问数据库，导致数据库崩溃。</p>
<h2 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p>构建多级缓存架构（结构复杂）</p>
</li>
<li><p>使用锁或队列（不适用于高并发）</p>
</li>
<li><p>设置过期标志更新缓存：</p>
<p>设置过期提前量，在key快要过期时更新缓存</p>
</li>
<li><p>将缓存失效时间分散：</p>
<p>在key原本失效时间上加上一个随机值，使得缓存中key过期时间重复率降低，难以引发集体失效事件。</p>
</li>
</ul>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>简单来说分布式锁就是在集群中，给一台机器上锁，其他所有机器都可以识别，对整个集群的机器都有用。</p>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>setnx命令就就是分布式锁，我们知道setnx命令是添加不重复的键，其实就是第一次执行后给key上锁，只有释放锁才能继续进行添加操作，也就是删除key才能再次添加。</p>
<p>setnx上锁、del释放锁（手动）。锁一直没有释放，可以给key设置过期时间（自动）。</p>
<p>还可以在上锁时提示设置过期时间：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nx代表上锁，ex time代表过期时间</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span> <span class="string">nx</span> <span class="string">ex</span> <span class="string">time</span></span><br></pre></td></tr></table></figure>

<p>我们优化一下，上锁时使用uuid</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">lock</span> <span class="string">uuid</span> <span class="string">nx</span> <span class="string">ex</span> <span class="string">time</span></span><br></pre></td></tr></table></figure>

<p>每一个锁都有对应的uuid，每个锁只能释放对应uuid的锁，以防其他节点误删。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>接下来看docker、了解vue，准备搞一个前后端分离项目。八股还没背。。。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://aidianfirst.com">aidianfirst</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aidianfirst.com/2021/08/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/">http://aidianfirst.com/2021/08/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://aidianfirst.com" target="_blank">哀殿firstの空间</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/aidianfirst/image/yuanchuang2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/21/%E5%89%8D%E7%AB%AF/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BVue/" title="了解一下Vue"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/yuanchuang2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">了解一下Vue</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/31/%E7%94%9F%E6%B4%BB/%E9%80%86%E8%BD%AC%E8%A3%81%E5%88%A4/" title="逆转裁判"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">逆转裁判</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/aidian.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">aidianfirst</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/29529786"><i></i><span>BiliBili空间</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/aidianfirst" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1262306856&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%EF%BC%88NoSQL%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">Redis（NoSQL）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.</span> <span class="toc-text">基本信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E9%94%AE%E5%91%BD%E4%BB%A4%EF%BC%88key%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">Redis 键命令（key）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">Redis字符串（String）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">Redis列表（List）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">Redis集合（Set）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%93%88%E5%B8%8C%EF%BC%88Hash-field-value%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">Redis哈希（Hash field-value）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88Zset%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">Redis有序集合（Zset）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">三大特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmaps"><span class="toc-number">3.1.</span> <span class="toc-text">Bitmaps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">3.2.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geospatial%EF%BC%88GEO%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">Geospatial（GEO）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">4.</span> <span class="toc-text">Redis小知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%EF%BC%88pub-sub%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">Redis发布订阅（pub&#x2F;sub）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis"><span class="toc-number">4.2.</span> <span class="toc-text">Jedis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%8ESpringBoot%E6%95%B4%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">Redis与SpringBoot整合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">Redis 事务与锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#multi%E3%80%81exec%E3%80%81discard"><span class="toc-number">5.1.</span> <span class="toc-text">multi、exec、discard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">5.2.</span> <span class="toc-text">事务中的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%EF%BC%88%E9%94%81%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">事务中的冲突（锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%E3%80%81unwatch%EF%BC%88%E7%9B%91%E8%A7%86%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">watch、unwatch（监视，乐观锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">5.5.</span> <span class="toc-text">Redis事务三特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text">Redis持久化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%EF%BC%88%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">RDB（默认开启）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%EF%BC%88%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%BC%80%E5%90%AF%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">AOF（默认不开启）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%88%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">Redis主从复制（读写分离）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%BB%E4%BA%8C%E8%BF%9B%E8%A1%8C%E5%AE%9E%E9%AA%8C"><span class="toc-number">7.1.</span> <span class="toc-text">配置一主二进行实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA-%E4%BB%8E%E6%9C%BA%E5%AE%95%E6%9C%BA"><span class="toc-number">7.2.</span> <span class="toc-text">主机&#x2F;从机宕机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%88%86%E5%B0%81%E5%88%B6%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">薪火相传（二叉树、分封制）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB%EF%BC%88%E6%89%8B%E5%8A%A8%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">反客为主（手动）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%87%AA%E5%8A%A8%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">哨兵模式（自动反客为主）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">8.</span> <span class="toc-text">Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">集群简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="toc-number">8.2.</span> <span class="toc-text">模拟搭建集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%9A%84%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">集群是如何分配的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slots%EF%BC%88%E5%93%88%E5%B8%8C%E6%A7%BD%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">slots（哈希槽）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E8%AE%A1%E7%AE%97"><span class="toc-number">8.4.1.</span> <span class="toc-text">哈希槽计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">8.5.</span> <span class="toc-text">故障恢复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">9.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">解决办法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">10.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">10.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-1"><span class="toc-number">10.2.</span> <span class="toc-text">解决办法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">11.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">11.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-2"><span class="toc-number">11.2.</span> <span class="toc-text">解决办法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">12.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">12.1.</span> <span class="toc-text">简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">12.2.</span> <span class="toc-text">Redis实现分布式锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/08/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spring/" title="Spring"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/miku4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2023/12/08/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spring/" title="Spring">Spring</a><time datetime="2023-12-08T09:33:35.781Z" title="发表于 2023-12-08 17:33:35">2023-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E6%95%A3%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9/" title="散装知识点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/miku4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="散装知识点"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E6%95%A3%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9/" title="散装知识点">散装知识点</a><time datetime="2023-07-30T11:20:17.737Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Controller%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%B5%85%E6%9E%90/" title="Controller接口调用链路浅析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/miku4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Controller接口调用链路浅析"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Controller%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%B5%85%E6%9E%90/" title="Controller接口调用链路浅析">Controller接口调用链路浅析</a><time datetime="2023-07-30T11:20:17.736Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spel%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81/" title="Spel字段解析功能源码浅析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/yuanchuang2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spel字段解析功能源码浅析"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spel%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81/" title="Spel字段解析功能源码浅析">Spel字段解析功能源码浅析</a><time datetime="2023-07-30T11:20:17.736Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/" title="并发编程实战阅读学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/aidian6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程实战阅读学习"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/" title="并发编程实战阅读学习">并发编程实战阅读学习</a><time datetime="2023-07-30T11:20:17.736Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/aidianfirst/image/yuanchuang2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By aidianfirst</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://aidianfirst-blog.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div class="aplayer no-destroy" data-id="2532053828" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted> </div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","hOffset":50,"vOffset":-50,"width":150,"height":350},"mobile":{"show":false},"log":false});</script></body></html>