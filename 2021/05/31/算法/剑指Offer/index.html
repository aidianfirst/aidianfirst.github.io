<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>剑指Offer | 哀殿firstの空间</title><meta name="author" content="aidianfirst"><meta name="copyright" content="aidianfirst"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组中重复的数题目：https:&amp;#x2F;&amp;#x2F;leetcode-cn.com&amp;#x2F;problems&amp;#x2F;shu-zu-zhong-zhong-fu-de-shu-zi-lcof&amp;#x2F;submissions&amp;#x2F; 首先肯定不能暴力（不想动脑，结果直接死了），直接超时，相对简单点是先排序，然后检查前后两个数是否相同。 方法1：排"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/aidianfirst/image/icon.png"><link rel="canonical" href="http://aidianfirst.com/2021/05/31/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指Offer',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-30 19:20:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="哀殿firstの空间" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/aidian.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="哀殿firstの空间"><span class="site-name">哀殿firstの空间</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指Offer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-31T14:27:18.000Z" title="发表于 2021-05-31 22:27:18">2021-05-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-30T11:20:17.738Z" title="更新于 2023-07-30 19:20:17">2023-07-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指Offer"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数组中重复的数"><a href="#数组中重复的数" class="headerlink" title="数组中重复的数"></a>数组中重复的数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/submissions/">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/submissions/</a></p>
<p>首先肯定不能暴力（不想动脑，结果直接死了），直接超时，相对简单点是先排序，然后检查前后两个数是否相同。</p>
<p>方法1：排序+遍历判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">           <span class="keyword">if</span>(nums[i-<span class="number">1</span>]==nums[i])</span><br><span class="line">               <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：利用Set无重复特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num)) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3：原地交换，书上的解法，可以说是最优解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            nums[i] ^= nums[nums[i]];</span><br><span class="line">            nums[nums[i]] ^= nums[i];</span><br><span class="line">            nums[i] ^= nums[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p>
<p>暴力不考虑啊，看了下书上提示就懂了大概方法，但一些特殊输入就没考虑到，故报错了好几次。本题从右上角和左下角开始查找都是OK的，因为有一大一小的两个相邻值可以判断位置，缩小查找范围。而使用左上或右下，则会全大或全小，查找不会缩小范围，无法解决问题。</p>
<p>方法1：右上角开始查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//选用右上角开始，但是从左下角开始更好，右上角开始则要对数组判断是否空</span></span><br><span class="line">        <span class="comment">//因为当输入空数组时，matrix[0]不存在，故m初始化会报错</span></span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>,m=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;matrix.length &amp;&amp; m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[n][m] &gt; target) m--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[n][m] &lt; target) n++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：左下角开始查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length-<span class="number">1</span>,m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">0</span> &amp;&amp; m&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[n][m] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[n][m] &gt; target) n--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[n][m] &lt; target) m++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a></p>
<p>比较简单啊，我们遍历一遍String转化后的数组，每次遇到字符=’ ‘就往StringBuilder添加”%20”并跳出，其他情况直接添加字符。最后转String输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>
<p>这里用栈就很好想，先进后出吗，先压入栈，在打印栈就是倒叙输出了，用数组也一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//链表不为空时操作</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(head.val);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">            arr[i] = s.pop();</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p>
<p>前序和中序结合推树很好想，但递归不好写，注意右子树的根结点位置是怎么生成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;<span class="comment">//res也要用，就定义一下</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//中序遍历存入哈希表，这里将中序的数存入键，其位置存入值，这是为了方便后续使用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++) map.put(inorder[i],i);</span><br><span class="line">        <span class="comment">//第一次自行输入根节点位置，然后递归得到结果</span></span><br><span class="line">        <span class="keyword">return</span> res(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//root即当前根节点在前序的位置，left、righ结点在中序中的最左和最右，区分左右子树</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">res</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界无子结点</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[root]);</span><br><span class="line">        <span class="comment">//根节点在中序遍历中的位置，根据键返回值，所以前面键要存中序的数而不是位置</span></span><br><span class="line">        <span class="keyword">int</span> i = map.get(preorder[root]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *写出左孩子的根节点和其左右子树边界</span></span><br><span class="line"><span class="comment">         *根节点在前序中的位置是root+1，其左边界还是中序的左边界</span></span><br><span class="line"><span class="comment">         *而右边界是中序根节点的左边第一个，因为中序从其根节点处判断左为左子树，右为右子树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        node.left = res(root+<span class="number">1</span>,left,i-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//前序根节点+左子树长度后的后一位，因为在前序遍历后按根节点|左子树|右子树来排序</span></span><br><span class="line">        node.right = res(root + i-left + <span class="number">1</span>,i+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a></p>
<p>A栈主栈，B栈辅助栈，入队时直接压入A栈，出队时A出B入，由于两次先进后出，此时B出栈便会实现元素先进先出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; a,b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个主栈a，一个辅助栈b，实现队列</span></span><br><span class="line">        a = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        a.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队首出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为先进先出，若辅助栈b已有上次的数据，先把这些数据出队</span></span><br><span class="line">        <span class="keyword">if</span>(!b.empty()) <span class="keyword">return</span> b.pop();</span><br><span class="line">        <span class="comment">//a栈无数据</span></span><br><span class="line">        <span class="keyword">if</span>(a.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//经过前两个验证，b栈空，a栈有数据，则将a出栈，后b入栈</span></span><br><span class="line">        <span class="keyword">while</span>(!a.empty())</span><br><span class="line">            b.push(a.pop());</span><br><span class="line">        <span class="comment">//使用辅助栈，两个栈的先进后出转变为队列的先进先出</span></span><br><span class="line">        <span class="keyword">return</span> b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/%E3%80%81">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/、</a></p>
<p>递归从上到下，会多次重复计算，效率低。</p>
<p>这里使用循环，每次将fn=f0+f1，并更新f0和f1，注意int上限是2^31，一般运算会越界，所以使用取余计算fn=(f0+f1)%1000000007</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f0=<span class="number">0</span>,f1=<span class="number">1</span>,fn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            fn=(f0+f1)%<span class="number">1000000007</span>;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1=fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="青蛙跳台（斐波那契变种）"><a href="#青蛙跳台（斐波那契变种）" class="headerlink" title="青蛙跳台（斐波那契变种）"></a>青蛙跳台（斐波那契变种）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/</a></p>
<p>这题首先要通过题目联想到跳上第n层只有上1/2层两种方法，推出f(n)=f(n-1)+f(n-2)，然后得到f(2)=f(1)+f(0)并结合事实推出f(0)=1，这里便是和斐波那契最大的区别，其他的就一样了，当然不能使用递归，毕竟重复计算太多了会超时，使用循环O(n)遍历即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *和斐波那契数列有细微不同，跳台问题f(0)=1,斐波那契f(0)=0</span></span><br><span class="line"><span class="comment">         *因为跳台倒退跳上第n层有两种方法，跳1或跳2，即f(n)=f(n-1)+f(n-2)</span></span><br><span class="line"><span class="comment">         *所以有f(2)=f(1)+f(0)，而跳上两层和跳上一层分别是2、1，这是结合事实的推断</span></span><br><span class="line"><span class="comment">         *所以f(0)只能是2-1=1，尽管它不太对逻辑，其他的都和斐波那契一样</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f0=<span class="number">1</span>,f1=<span class="number">1</span>,fn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            fn = (f0 + f1)%<span class="number">1000000007</span>;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</a></p>
<p>遍历就不说了啊，这题目考的就是二分找旋转点，注释写的比较清除，还要注意，mid=j不能判断左右递增，因为[0,1,1,1,1,1]这种全是重复值的数组存在。还有为什么mid与j比较，而不是与i比较，因为有[1,2,3,4,5]这种数组，只有右递增，旋转点是num[0]，这个问题要考虑清楚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i&lt;j时二分查找</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *旋转数组会分割成左递增和右递增，实质是找旋转点</span></span><br><span class="line"><span class="comment">             *其中左递增是原本数组的后部部分，旋转到前面来的，故左递增&gt;右递增</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//mid&gt;j，则mid一定位于左递增，旋转点位于右递增，左递增全舍弃故+1</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&gt;numbers[j]) i = mid+<span class="number">1</span>;          </span><br><span class="line">            <span class="comment">//mid&lt;j，mid一定位于右递增，而右递增包含旋转点，故不舍弃 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&lt;numbers[j]) j = mid;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *最后剩下的情况只有mid=j，而这种情况是无法确认mid在左还是右的</span></span><br><span class="line"><span class="comment">             *具体论证可看力扣评论区或剑指Offer，主要是因为可以有重复元素导致的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/</a></p>
<p>这题的思想好想，但写起来就不容易了，且要注意细节，就是回溯的时候要把改变的空字符重置回初值，这是回溯法的关键，我理解是当前错误的路径上标记过的值（空字符）全作废，因为这条路是错的，一直回到正确的岔路口来走另一条路。感觉这题没有吃透。。。</p>
<p>评论区看到的分析：一个比较难理解的点，递归搜索匹配字符串过程中，需要 board[i] [j] = ‘0/‘ 来防止 ”走回头路“ 。当匹配字符串不成功时，会回溯返回，此时需要board[i] [j] = word[k] 来”取消对此单元格的标记”。 <strong>在DFS过程中，每个单元格会多次被访问的， board[i] [j] = ‘0/‘只是要保证在当前匹配方案中不要走回头路，不复原，在下一个匹配方案中会影响最终结果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)</span><br><span class="line">                <span class="comment">//先遍历查找匹配第一个字符的元素</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] words,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//矩阵索引越界，或当前访问的矩阵元素和目标不符</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=board.length || i&lt;<span class="number">0</span> || j&gt;=board[<span class="number">0</span>].length || j&lt;<span class="number">0</span> || board[i][j]!=words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//成功访问到字符串最后一个字符且和最后一个也相等，说明匹配存在（第一个if可检验相等）</span></span><br><span class="line">        <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//若经过前两个if，说明字符串匹配仍在进行，为了不重复访问，将这次符合的矩阵元素变为空字符</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//判断其上下左右是否有符合下一个字符的元素，这里有就会一直递归，直到退出</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board,words,i+<span class="number">1</span>,j,k+<span class="number">1</span>) || dfs(board,words,i-<span class="number">1</span>,j,k+<span class="number">1</span>) || dfs(board,words,i,j+<span class="number">1</span>,k+<span class="number">1</span>) || dfs(board,words,i,j-<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *这里是关键，只有当前递归终止时会来到这一步，如果结果是false也就是没有匹配的字符串，会一步步</span></span><br><span class="line"><span class="comment">     *回溯到之前匹配的情况，并判断当时是否还有其他路径，也就是说，现在的路径不正确，那刚刚走过的路</span></span><br><span class="line"><span class="comment">     *相当于没有用，我们需要回到初始状态。但可能之后走的另一条路径会经过曾经匹配的元素，如果我们没</span></span><br><span class="line"><span class="comment">     *有回溯则让会未经过的点变成空字符，这肯定是有问题的。而对返回结果true没啥影响。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        board[i][j] = words[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意其实回溯是针对错误路径的，对正确路径无影响，但为了方便，我们就不分情况回溯了。将代码中加上判断条件只在错误时回溯，发现结果仍然是对的，这也验证了我的想法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以，但没必要</span></span><br><span class="line"><span class="keyword">if</span>(res == <span class="keyword">false</span>) board[i][j] = words[k];</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</a></p>
<p>深度优先遍历，每走一个新方格便记录该方格的数位和，并与判断条件比较，直到走到头往回退，给出结果。注意dfs返回值是其右和下的遍历情况+1，因为直接这一格可以走到，所以+1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只通过向右和向下就能查找到所有的可行的方格，向上和向左一般都遇到重复的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//变量提升作用域，visited是记录访问情况的辅助数组</span></span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m; <span class="keyword">this</span>.n = n; <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">//矩阵起始点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算当前方格（行/列）坐标的数位和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *注意是m行n列，所以m-1、n-1就是上限了，所以i、j&gt;=m、n时结束查询</span></span><br><span class="line"><span class="comment">     *每次访问过的方格都会visited标记为true，下次再来到这个方格直接结束</span></span><br><span class="line"><span class="comment">     *k的判断要是和m、n一样，由于到m、n会结束，相对的数位和就是sum(m)、sum(n)</span></span><br><span class="line"><span class="comment">     *k是一定要小于sum(m)+sum(n)的，因为是先计算值后判断是否符合情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> sumi, <span class="keyword">int</span> sumj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; sumi + sumj || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//1即当前方格本身 + dfs（i+1）是右边方格的全部结果 + dfs（j+1）即下方方格全部结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, sum(i + <span class="number">1</span>), sumj) + dfs(i, j + <span class="number">1</span>, sumi, sum(j + <span class="number">1</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="剪绳子（n-lt-58，不考虑大数据）"><a href="#剪绳子（n-lt-58，不考虑大数据）" class="headerlink" title="剪绳子（n&lt;=58，不考虑大数据）"></a>剪绳子（n&lt;=58，不考虑大数据）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</a></p>
<p>最优子段的推导：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/</a></p>
<p>这里使用贪心算法是最优解，而找出最优字段是关键，就是每个&gt;5的数均可继续分割成2&amp;3，2、3的搭配才是最小最优的乘积（整个具体分析得看大佬，例如5&lt;2*3等等），而2&amp;3的优先级怎么判断呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6&#x3D;2+2+2&#x3D;3+3，f(6)&#x3D;2*2*2&lt;3*3</span><br><span class="line">所以3的优先级大于2</span><br><span class="line">故我们使用3来作为倍数，剩下的分析看注释即可</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最优解是分割成2、3，但绳子最少切一段，所以n=2、3时特殊讨论</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = n/<span class="number">3</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *Math.pow即3^i，幂运算</span></span><br><span class="line"><span class="comment">         *因为分割成3的子段是最优解，所以/3算倍数与余数，余数只有0，1，2三种情况</span></span><br><span class="line"><span class="comment">         *余数=0时，说明被3整除可全部被分割成3的小段，f(n)=3^n</span></span><br><span class="line"><span class="comment">         *余数=1时，f(n)=3^n*1，但1+3=4，4可以分割成2+2，显然2+2更优，故优化f(n)=3^(n-1)*4</span></span><br><span class="line"><span class="comment">         *余数=2时，f(n)=3^n*2，2是最优子段直接返回即可</span></span><br><span class="line"><span class="comment">         *又因为只有这三种讨论，可直接把返回值设为余数为2的情况</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,i-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,i)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="剪绳子（大数据情况，考虑越界）"><a href="#剪绳子（大数据情况，考虑越界）" class="headerlink" title="剪绳子（大数据情况，考虑越界）"></a>剪绳子（大数据情况，考虑越界）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</a></p>
<p>注意要逐位取余，不然连乘中途可能已经越界了，所以老办法不行，同一个思路要换一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最优解是分割成2、3，但绳子最少切一段，所以n=2、3时特殊讨论</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = n/<span class="number">3</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *Math.pow即3^i，幂运算</span></span><br><span class="line"><span class="comment">         *因为分割成3的子段是最优解，所以/3算倍数与余数，余数只有0，1，2三种情况</span></span><br><span class="line"><span class="comment">         *余数=0时，说明被3整除可全部被分割成3的小段，f(n)=3^n</span></span><br><span class="line"><span class="comment">         *余数=1时，f(n)=3^n*1，但1+3=4，4可以分割成2+2，显然2+2更优，故优化f(n)=3^(n-1)*4</span></span><br><span class="line"><span class="comment">         *余数=2时，f(n)=3^n*2，2是最优子段直接返回即可</span></span><br><span class="line"><span class="comment">         *又因为只有这三种讨论，可直接把返回值设为余数为2的情况</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,i-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,i)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&gt;&gt;&quot;无符号右移</span><br><span class="line">操作规则：无论正负数，前面补零。</span><br><span class="line"></span><br><span class="line">&quot;&gt;&gt;&quot;右移</span><br><span class="line">操作规则：正数前面补零，负数前面补1</span><br><span class="line"></span><br><span class="line">&quot;&lt;&lt;&quot;左移</span><br><span class="line">操作规则：无论正负数，后面补零。</span><br></pre></td></tr></table></figure>

<p>末位按位与1 + 逐位右移：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * n&amp;1直接+即可，可以省去if判断，因为n&amp;1为T=1，F=0，等价了</span></span><br><span class="line"><span class="comment">         * java要使用无符号右移，也就是&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">         * 因为负数右移左补1，然后会无限循环1，出不来了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            res += n&amp;<span class="number">1</span>;</span><br><span class="line">            n = n&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新思路：</p>
<ul>
<li>数-1：即二进制最右的1变为0，该位后面的0全变为1</li>
<li>将-1的数&amp;原数：可得到只有最右的1变为0的数，其余不变</li>
<li>重复该操作，直到全部变为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/jian-zhi-offer-16-shu-zhi-de-zheng-shu-c-rgqy/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/jian-zhi-offer-16-shu-zhi-de-zheng-shu-c-rgqy/</a></p>
<p>可类比斐波那契数列，均有递归关系，一般只在偶数情况下递归，奇数情况则提一个a，转变次数为偶数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">偶数情况</span><br><span class="line">    a^n &#x3D; a^(n&#x2F;2) * a^(n&#x2F;2)</span><br><span class="line">    a^n &#x3D; a^[2*(n&#x2F;2)]</span><br><span class="line">    a^n &#x3D; (a^2)^(n&#x2F;2) (效率更高，递归得用这个，不然超时)</span><br><span class="line">奇数情况</span><br><span class="line">    a^n &#x3D; a^[(n-1)&#x2F;2] * a^[(n-1)&#x2F;2] * a</span><br><span class="line">    a^n &#x3D; a * a^(2*[(n-1)&#x2F;2])</span><br><span class="line">    a^n &#x3D; a * (a^2)^[(n-1)&#x2F;2]</span><br></pre></td></tr></table></figure>

<p>迭代（以二进制来思考）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * int32位，第一位符号位，所以正数最大是0+31个1，即2^31-1</span></span><br><span class="line"><span class="comment"> * 负数最小是-0，也就是规定的1+31个0，规定为-2^31 </span></span><br><span class="line"><span class="comment"> * 所以迭代要转换负数要将int提升到long，不然-2^31反转后会越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> m = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            m = -m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 现在已经转换为正数了，以二进制来思考，1101即x^8 * x^4 * x^1</span></span><br><span class="line"><span class="comment">            * 我们会与1做按位与，查看当前位是否为1，若为1则将res * 当前位的对应数值</span></span><br><span class="line"><span class="comment">            * 这个数值就是上述例子的x^8、x^4这样，即每次右移都会把下一位和1比较</span></span><br><span class="line"><span class="comment">            * 而当前位的数值是逐渐叠加的，所以每次 x自乘 也就是在计算相应位置的数值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>((m&amp;<span class="number">1</span>) == <span class="number">1</span>) res *= x;<span class="comment">//比较当前二进制位数是否存在，存在就乘以对应位置的数值</span></span><br><span class="line">            x *= x;<span class="comment">//每一位的数值都在叠加，从1位开始</span></span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;<span class="comment">//右移，比较下一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//0次方返回1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//转换负数，这里为了防止转换越界，取了一个x出来</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/(x * myPow(x,-n-<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//若为奇数，提一个x，将次数转换为偶数</span></span><br><span class="line">             <span class="keyword">return</span> x * myPow(x,n-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * a^n = a^(n/2) * a^(n/2)</span></span><br><span class="line"><span class="comment">             * a^n = a^[2*(n/2)]</span></span><br><span class="line"><span class="comment">             * a^n = (a^2)^(n/2) </span></span><br><span class="line"><span class="comment">             * 这里要多转换一步</span></span><br><span class="line"><span class="comment">             * 如果是myPow(x,n/2)*myPow(x,n/2)则超时，因为多了一次递归</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="打印从1到最大的n位数（大数情况得重新看）"><a href="#打印从1到最大的n位数（大数情况得重新看）" class="headerlink" title="打印从1到最大的n位数（大数情况得重新看）"></a>打印从1到最大的n位数（大数情况得重新看）</h1><p>难，大数情况不好想</p>
<p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/</a></p>
<p>int不越界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> end = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,n)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[end];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=end;i++)</span><br><span class="line">            res[i-<span class="number">1</span>]=i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大数情况！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res;</span><br><span class="line">    <span class="keyword">int</span> nine=<span class="number">0</span>,count=<span class="number">0</span>,start,n;</span><br><span class="line">    <span class="keyword">char</span>[] num,loop=&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,n)-<span class="number">1</span>];<span class="comment">//返回结果上限(10^n)-1</span></span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">char</span>[n];<span class="comment">//每一个数的长度</span></span><br><span class="line">        start = n-<span class="number">1</span>;<span class="comment">//字符串左边界，左边0的个数</span></span><br><span class="line">        dfs(<span class="number">0</span>);<span class="comment">//全排列</span></span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//符合当前位数，返回当前的数</span></span><br><span class="line">        <span class="keyword">if</span>(x==n)&#123;</span><br><span class="line">            String s = String.valueOf(num).substring(start);<span class="comment">//截取子串，舍去前面的0</span></span><br><span class="line">            <span class="comment">//不为0，添加进结果，逗号隔开。因为有10，所以必须考虑0，但0、00、000就不要了</span></span><br><span class="line">            <span class="keyword">if</span>(!s.equals(<span class="string">&quot;0&quot;</span>)) res[count++] = Integer.parseInt(s);</span><br><span class="line">            <span class="keyword">if</span>(n-start == nine) start--;<span class="comment">//进位了，更新左起0的个数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : loop)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;9&#x27;</span>) nine++;<span class="comment">//9的数量</span></span><br><span class="line">            num[x] = i;</span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nine--;<span class="comment">//开始一次新的计算，9计数倒退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/</a></p>
<p>就是删除链表的节点，注意头结点为空的特殊情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;<span class="comment">//val相等，跳过当前结点</span></span><br><span class="line">        ListNode pre = head, cur = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">                pre.next = cur.next;<span class="comment">//val相等，跳过cur，并退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="正则表达式匹配-难！"><a href="#正则表达式匹配-难！" class="headerlink" title="正则表达式匹配(难！)"></a>正则表达式匹配(难！)</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/jian-zhi-offer-19-zheng-ze-biao-da-shi-pi-pei-dong/">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/jian-zhi-offer-19-zheng-ze-biao-da-shi-pi-pei-dong/</a></p>
<ul>
<li>初始化时，要给两个字符串添加一个首空字符</li>
<li>正则表达式判断，匹配串当前字符是’ * ‘时<ul>
<li>‘ * ‘修饰字符重复0次情况</li>
<li>‘ * ‘ 与上一个主串字符匹配，看当前主串字符是否仍能与 ‘ * ‘修饰字符匹配，即重复一次’ * ‘修饰字符</li>
<li>‘ * ‘ 与上一个主串字符匹配，但’ * ‘修饰’ . ‘，主串当前字符一定匹配</li>
</ul>
</li>
<li>正则表达式判断，匹配串当前字符不是’ * ‘时，且前部分主串与匹配串相匹配<ul>
<li>当前主串与匹配串字符相等</li>
<li>当前匹配串字符是’ . ‘，一定匹配</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们现在s串为主串，p串为匹配串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123; </span><br><span class="line">        <span class="comment">/* 初始化布尔数组，默认值为false，所以我们只需要标出true即可</span></span><br><span class="line"><span class="comment">         * 本来矩阵长度等于字符串的长度，但为了方便操作，在每一个字符串前引进了一个空字符</span></span><br><span class="line"><span class="comment">         * 因为两个空字符串本身是匹配的，会带来一个true，方便后续判断</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">int</span> m = s.length()+<span class="number">1</span>,n = p.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* dp[i][0]、[0][j]一般都是默认值false，而dp[i][0]则会有特殊情况</span></span><br><span class="line"><span class="comment">         * 就是两个字符串以空值匹配的特殊情况，此处s串确定为空，p串是有*的特殊情况</span></span><br><span class="line"><span class="comment">         * 只有*修饰的字符才会因为重复0次变成空字符，因为*都是和一个字符配套使用的</span></span><br><span class="line"><span class="comment">         * 所以只有偶数串，且每一个字符都有*修饰时才会和空串匹配，而*必处于偶数位</span></span><br><span class="line"><span class="comment">         * 而奇数串必有无*修饰的字符，肯定不会是空字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;n;j += <span class="number">2</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>] &amp;&amp; p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 行列第0位的初始化及特殊情况均已讨论完，现在讨论字符串本身</span></span><br><span class="line">        <span class="comment">// [j] = (j-1)，一个是处于矩阵中的位置，一个是处于字符串本身的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">// 当前p串来匹配的字符是*</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// 情况1：*修饰的字符重复0次，即当前字符和*都被跳过后字符串能否匹配</span></span><br><span class="line">                    <span class="comment">// [j-2]其实是p.charAt(j-3)，当前*是p.charAt(j-1)，所以是前2位</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j-<span class="number">2</span>]) dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 情况2：若s串上一个字符和*匹配成功，则判断s串当前字符和*修饰的字符是否匹配</span></span><br><span class="line">                    <span class="comment">// 也就是说延续上一个字符与*的匹配，即*修饰的字符再出现一次，看能否匹配</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j] &amp;&amp; s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>)) </span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 情况3：这是2的特殊情况，*修饰的字符是&#x27;.&#x27;，所以当前字符在此情况下一定匹配</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j] &amp;&amp; p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// p串当前匹配字符不是*</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//s、p串前面每一位都匹配，且当前字符s、p串也匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>)) </span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//s、p串前面字符均匹配，而p串当前字符为&#x27;.&#x27;，这是特殊情况一定匹配</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//矩阵长度m、n，0~m-1，0~n-1。m-1、n-1就是最后一位</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="表示数值的字符串（优化了不用状态机的作法）"><a href="#表示数值的字符串（优化了不用状态机的作法）" class="headerlink" title="表示数值的字符串（优化了不用状态机的作法）"></a>表示数值的字符串（优化了不用状态机的作法）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/</a></p>
<p>k神的解法太妙了，看懂后就觉得理解起来很容易，用Map数组规定8种状态，然后从初值0开始，依当前情况进入对应的状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/3.png" alt="3.png"></p>
<p>8种状态的个人理解我也写在注解里了，原谅我是个菜鸡，看半天才看懂，还没法举一反三😭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小数表示可省去0，-0.4 = -.4，0.4 = .4；2.、3. = 2、3，小数点前有数，后面可以不跟数代表原数</span></span><br><span class="line"><span class="comment">//注意e8即10的8次幂（8次方），也可以是e-7，但题目要求必须跟整数</span></span><br><span class="line"><span class="comment">//题目规定是数值前后可有空格，中间不能有，这个情况要考虑清楚。s：符号、d：数字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map[] states = &#123;</span><br><span class="line">            <span class="comment">//0：规定0是初值，字符串表示数值，有4种起始状态，开头空格、符号、数字、前面没有数的小数点</span></span><br><span class="line">            <span class="comment">//其中 开头空格 还是指向states[0]，上一位是 开头空格，下一位可以是 空格、符号、数字、前面没有数的小数点</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;, </span><br><span class="line">            <span class="comment">//1：上一位是符号，符号位后面可以是 数字、前面没有数的小数点</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;,</span><br><span class="line">            <span class="comment">//2：上一位是数字，数字的下一位可以是 数字、前面有数的小数点、e、结尾空格</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;, </span><br><span class="line">            <span class="comment">//3：上一位是前面有数的小数点，下一位可以是 数字、e（8.e2 = 8e2，和2的情况一样）、结尾空格</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,</span><br><span class="line">            <span class="comment">//4：上一位是前面没有数的小数点，下一位只能是 数字（符号肯定不行，e得前面有数才行）</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); &#125;&#125;,</span><br><span class="line">            <span class="comment">//5：上一位是e，下一位可以是 符号、数字</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,</span><br><span class="line">            <span class="comment">//6：：上一位是e后面的符号，下一位只能是 数字</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,</span><br><span class="line">            <span class="comment">//7：上一位是e后面的数字，下一位可以是 数字、结尾空格</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,</span><br><span class="line">            <span class="comment">//8：上一位是结尾空格，下一位只能是 结尾空格</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="comment">//遍历字符串，每个字符匹配对应属性并用t标记，非法字符标记？</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>) t = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>) t = c;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="comment">//当前字符标记和任何一种当前规定格式都不匹配，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!states[p].containsKey(t)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//更新当前字符的规定格式，进入下一个规定的Map数组</span></span><br><span class="line">            p = (<span class="keyword">int</span>)states[p].get(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2（正、负整数）、3（正、负小数）、7（科学计数法）、8（前三种形式的结尾加上空格）</span></span><br><span class="line">        <span class="comment">//只有这四种才是正确的结尾</span></span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2021.12.24 二刷剑指，yysy状态机一般人写不出来，只能背，然后发现剑指官方没有使用状态机，而且状态机也不是时间复杂度最优解，看了看评论区发现了简易写法，简单易懂good！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">boolean</span> numFlag = <span class="keyword">false</span>; <span class="comment">//数字</span></span><br><span class="line">        <span class="keyword">boolean</span> dotFlag = <span class="keyword">false</span>; <span class="comment">//小数点</span></span><br><span class="line">        <span class="keyword">boolean</span> eFlag = <span class="keyword">false</span>;   <span class="comment">//e </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//判定为数字，则标记numFlag</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) numFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判定为&#x27;.&#x27;需要没出现过&#x27;.&#x27;并且没出现过&#x27;e&#x27;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag) dotFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判定为&#x27;e&#x27;，需要没出现过&#x27;e&#x27;，并且出过数字了，小数点无影响</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;e&#x27;</span> || s.charAt(i) == <span class="string">&#x27;E&#x27;</span>) &amp;&amp; !eFlag &amp;&amp; numFlag)&#123;</span><br><span class="line">                eFlag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//为了避免12e这种情况，e后面必须跟数字，出现e之后就数字标识为false</span></span><br><span class="line">                numFlag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判定为+-符号，只能出现在第一位或者紧接e后面，标识一种符合情况，以免+-直接false</span></span><br><span class="line">            <span class="comment">//多次+-不满足的情况自然会走最后的false，所以方法体不需要内容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;+&#x27;</span> || s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;e&#x27;</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;E&#x27;</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其他情况，都是非法的</span></span><br><span class="line">            <span class="comment">//如多个小数点，e后小数点，这些都在if判断中规避了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后结果一定要有数字输出，数字位即答案</span></span><br><span class="line">        <span class="comment">// 主要注意e后面必须跟数字，所以判断有e后要把数字位重置</span></span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="调整数组顺序是奇数位于偶数前"><a href="#调整数组顺序是奇数位于偶数前" class="headerlink" title="调整数组顺序是奇数位于偶数前"></a>调整数组顺序是奇数位于偶数前</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</a></p>
<p>采用左右双指针，前提left小于right，left循环匹到偶数停止，然后right循环匹配到奇数停止，随后二者交换数值，多次循环后最后完成奇数排列于偶数前，但没有顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//循环与1按位与，判断奇偶，直到出现偶数</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right &amp;&amp; (nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                left++;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环判断奇偶，直到出现奇数</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right &amp;&amp; (nums[right] &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//异或交换数据</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                nums[left] = nums[left] ^ nums[right];</span><br><span class="line">                nums[right] = nums[left] ^ nums[right];</span><br><span class="line">                nums[left] = nums[left] ^ nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>
<p>左右指针遍历一次链表即可，先右指针空出k个位置给倒数节点，随后左右同时前进直到越界，因为遍历到表尾时，左指针在倒数节点的前一个节点，右指针在表尾节点，随后越界左指针就指向了倒数节点。注意空k个位置时要考虑越界的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//左右（前后）两指针遍历链表一次即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode left=head,right=head;</span><br><span class="line">        <span class="comment">//右指针先跑k个位置，这样左右指针就空出了倒数节点的空间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">//右指针越界说明链表不符合题意</span></span><br><span class="line">            <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右指针同时前进，右指针越界时退出，此时右指针刚刚越界，</span></span><br><span class="line">        <span class="comment">//而左指针刚好在倒数指针第k个节点</span></span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            left = left.next;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/</a></p>
<p>双指针，前缀指针pre、当前指针cur，next用来保存预更新值，首先保存下一结点的值给next，然后反转cur指向，最后更新pre、cur直到cur指向null，此时pre便是原表尾结点，返回pre即反转链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//双指针，先把当前结点的后一位保存。然后将该结点指向前一位，最后在更新当前结点和前缀结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>,cur = head,next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当当前结点为空时，前缀结点走到表尾结点，并且所有的指向已经反转，直接返回前缀结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</a></p>
<p>最近都在搞期末，没怎么写题，今天看题很简单，简单写完就发现是局域烂代码，太啰嗦了。。。感觉没啥进步。还是对着题解改进一下，md思路都一样别人的简洁很多。。。主要是最后的一个链表为空时，另一个链表直接连接的写法，我这很啰嗦，题解就很简明。</p>
<p>烂代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode cur = <span class="keyword">null</span>,head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                head = l1;</span><br><span class="line">                cur = head;  </span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head = l2;</span><br><span class="line">                cur = head;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;    </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化头指针，使用光标连接链表，最后返回head.next，即舍去头指针</span></span><br><span class="line">        <span class="comment">//注意头指针需一个初值，不能空指针，否则循环一开始便会空指针异常，反正最后头指针会舍弃</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>),cur = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当一个链表为空时，使用一句话就能直接连接另一个链表</span></span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p>
<p>需要多写一个子树判断，也就是当前结点判断函数。我们先在a树中查找符合b子树根结点的点，查找到后再执行左右子树的判断。注意子树中b树为空说明子树查找完毕，a中有b子树，而b未空，a先空时说明查找失败，毕竟a已经无法继续了。这题相对于前序遍历，先判断当前结点是否有子树，然后看其左右结点是否有子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode a, TreeNode b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空树不是任意一个树的子结构</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当前根结点匹配，且左右子树均匹配，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(a.val == b.val &amp;&amp; ( cur(a.left,b.left) &amp;&amp; cur(a.right,b.right) )) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//递归，更新a的当前匹配根结点，分别走左右子树</span></span><br><span class="line">        <span class="keyword">return</span> isSubStructure(a.left,b) || isSubStructure(a.right,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前a为根结点的子树是否包含b</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cur</span><span class="params">(TreeNode a,TreeNode b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//b树匹配完了，说明成功匹配</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//而b树没匹配完，a树却走完了，没有结点可以匹配，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当前结点相匹配在，则继续匹配左右子树，不匹配返回false</span></span><br><span class="line">        <span class="keyword">if</span>(a.val == b.val)</span><br><span class="line">            <span class="keyword">return</span> cur(a.left,b.left) &amp;&amp; cur(a.right,b.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解改进版，超精简</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode a, TreeNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a != <span class="keyword">null</span> &amp;&amp; b != <span class="keyword">null</span>) &amp;&amp; (cur(a,b) || isSubStructure(a.left,b) || isSubStructure(a.right,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前a为根结点的子树是否包含b</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cur</span><span class="params">(TreeNode a,TreeNode b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.val != b.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//能返回递归，说明没有当前a，b没有走完，且当前a，b结构符合，然后同时返回左右子树</span></span><br><span class="line">        <span class="keyword">return</span> cur(a.left,b.left) &amp;&amp; cur(a.right,b.right);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p>
<p>说实话，简单题思路很容易想到，但就是写完有点啰嗦，大佬的解法是真简洁。</p>
<p>简单的前序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preorder(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 不能这样判断，虽然写法一样，但这种写法单子树的另一半空结点不会打印</span></span><br><span class="line">        <span class="comment">// if(root.left != null &amp;&amp; root.right != null)&#123;</span></span><br><span class="line">        <span class="comment">//     temp = root.left;</span></span><br><span class="line">        <span class="comment">//     root.left = root.right;</span></span><br><span class="line">        <span class="comment">//     root.right = temp;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        preorder(root.left);  </span><br><span class="line">        preorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大佬简洁易懂写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right = mirrorTree(root.left);</span><br><span class="line">        root.left = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/</a></p>
<p>思路很简单，就是想不出来，我一开始做了一个镜像树与原树比较，属实笨比。然后看了下书发现想复杂了，直接树的左右结点对称比较即可。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">mirror</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> mirror(root1.left,root2.right) &amp;&amp; mirror(root1.right,root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/</a></p>
<p>很好想，但我自己写的时候对边界的判断很模糊，没有进行明确规定，写着写着就卡住了。看了下题解发现思路很清晰，特别是每次判断的时候使用 ++i 的格式，使得if语句很简洁，而且还更新了边界，所以下个循环的开始结点就更新好了，我一开始就是不知道怎么写这个结点更新导致卡壳了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">//注意矩阵为空，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//初始化上下左右四个边界，以及数组计数</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>,b=matrix.length-<span class="number">1</span>,l=<span class="number">0</span>,r=matrix[<span class="number">0</span>].length-<span class="number">1</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[(b+<span class="number">1</span>) * (r+<span class="number">1</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们要注意退出循环的条件，即l&gt;r，t&gt;b按情况变形</span></span><br><span class="line">        <span class="comment">//++t、--r很重要即进行了条件判断，而且还更新了边界方便后续操作</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//上边界从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) ans[num++] = matrix[t][i];</span><br><span class="line">            <span class="comment">//更新上边界并判断是否打印完</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//右边界从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;=b;i++) ans[num++] = matrix[i][r];</span><br><span class="line">            <span class="comment">//更新右边界更新并判断</span></span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//下边界从右到左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=l;i--) ans[num++] = matrix[b][i];</span><br><span class="line">            <span class="comment">//更新下边界并判断</span></span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//左边界从下到上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b;i&gt;=t;i--) ans[num++] = matrix[i][l];</span><br><span class="line">            <span class="comment">//更新左边界并判断</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p>
<p>使用辅助栈存储最小值即可，其他和普通栈无区别，注意出栈时栈顶元素匹配用equals，因为这里是两个栈顶元素在比较，也就是是对象在比较。</p>
<ul>
<li>==<ul>
<li>基本数据类型，比较值</li>
<li>引用数据类型（对象、数组），比较内存地址</li>
</ul>
</li>
</ul>
<p>所以这里肯定不能用==。</p>
<ul>
<li>equals<ul>
<li>不可用于基本数据类型的判断</li>
<li>当前类没有覆盖equals()方法，则使用equals()会相对于使用==，即比较两个对象的内存地址</li>
<li>若当前类覆盖equals()方法，则按照覆盖的方法来判断，如String的方法就是直接判断值（Integer、String、Date、File这四个覆写了）</li>
</ul>
</li>
</ul>
<p>所以我们使用equals()，因为这里是Integer包装类是覆盖过的equals()，可以比较值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; a,b;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        a.push(x);</span><br><span class="line">        <span class="keyword">if</span>(b.empty() || b.peek() &gt;= x) b.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( a.peek().equals(b.peek()) ) b.pop();</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</a></p>
<p>使用辅助栈同步操作，不能完全出栈的出栈序列就是错误的，故最后返回ans.empty()判断即可。我自己写的时候还想着O(n)做出来，结果就卡壳了，看见题解双循环就懂了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; ans = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            ans.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!ans.empty() &amp;&amp; ans.peek().equals(popped[i]) )&#123;</span><br><span class="line">                ans.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.empty();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从上到下打印二叉树（层序遍历）"><a href="#从上到下打印二叉树（层序遍历）" class="headerlink" title="从上到下打印二叉树（层序遍历）"></a>从上到下打印二叉树（层序遍历）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p>
<p>就是层序遍历，使用队列辅助，由于队列先进先出，每次循环都是把下一层的结点从左到右加入队列，然后先进先出完成层序。队列要初始化加入根结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从上到下打印二叉树（二）"><a href="#从上到下打印二叉树（二）" class="headerlink" title="从上到下打印二叉树（二）"></a>从上到下打印二叉树（二）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p>
<p>我自己的做法就是普通的层序遍历，然后每层使用一个辅助队列保存当层应该打印的结点，然后打印并统计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; exm = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">            Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">                q.add(queue.poll());</span><br><span class="line">            <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                exm.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(exm); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看了下k神的题解，进行了代码优化，循环里面使用初始队列长度来规定每层应该打印的次数，写法太强了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; exm = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">			<span class="comment">//循环初始化为当前队列的元素个数然后i--，根据这个次数来循环，避免后续加入的新元素干扰判断</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size();i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                exm.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(exm); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从上到下打印二叉树（三）"><a href="#从上到下打印二叉树（三）" class="headerlink" title="从上到下打印二叉树（三）"></a>从上到下打印二叉树（三）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a></p>
<p>和前两天的没有大差别，无非是奇偶数层要正序/倒序打印，但组件一开始写的时候犯难了，一开始想着加入一个辅助栈，结果后续元素入队列的顺序越写越乱。看了下题解发现直接用链表控制每层要打印的数据，对应奇偶层进行正倒序排列。还是LinkedList用少了，完全没想到它自带添加首尾的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;<span class="comment">//当前的层数，从1开始</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="comment">//奇数层正序，偶数层倒序</span></span><br><span class="line">                <span class="comment">//addLast每次都加到链表尾部，最后就是正序</span></span><br><span class="line">                <span class="comment">//addFirst每次加到链表头部，最后就是倒叙</span></span><br><span class="line">                <span class="keyword">if</span>((j &amp; <span class="number">1</span>) == <span class="number">1</span>) temp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span> temp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;<span class="comment">//层数递增</span></span><br><span class="line">            ans.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树的后续遍历序列"><a href="#二叉搜索树的后续遍历序列" class="headerlink" title="二叉搜索树的后续遍历序列"></a>二叉搜索树的后续遍历序列</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p>
<p>注意二叉搜索树左小右大，查找左右子树的分割点再进行递归判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化0 ~ root(postorder.length-1)</span></span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据后序遍历左右根，将postorder分割成 左0~mid-1, 右mid~root-1, 根root</span></span><br><span class="line">    <span class="comment">//其中mid是数组中第一个大于根结点的位置，也就是左右子树的分割位置</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> left,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左子树结点序号 &gt;= 根结点序号，说明当前树结点&lt;=1，说明后序判断成功</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= root) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//数组从左到右，第一个左子树结点初始化结点</span></span><br><span class="line">        <span class="keyword">int</span> cur = left;</span><br><span class="line">        <span class="comment">//遍历数组，小于根结点的都属于左子树</span></span><br><span class="line">        <span class="keyword">while</span>(postorder[cur] &lt; postorder[root]) cur++;</span><br><span class="line">        <span class="comment">//退出循环，说明当前结点大于根结点，已经属于右子树的范围了</span></span><br><span class="line">        <span class="keyword">int</span> mid = cur;</span><br><span class="line">        <span class="comment">//继续遍历数组，但cur已经是右子树了，变更条件为大于根结点</span></span><br><span class="line">        <span class="keyword">while</span>(postorder[cur] &gt; postorder[root]) cur++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//cur == root说明遍历到了最后，当前左右根无问题，可继续递归</span></span><br><span class="line">        <span class="comment">//递归分为左右子树 左子树在left ~ mid-1中继续判断是否符合二叉搜索树的后序</span></span><br><span class="line">        <span class="comment">//同理 右子树在mid ~ root-1中判断其是否符合二叉搜索树的后序</span></span><br><span class="line">        <span class="keyword">return</span> cur == root&amp;&amp;recur(postorder,left,mid-<span class="number">1</span>)&amp;&amp;recur(postorder,mid,root-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p>
<p>我们使用先序遍历递归查找路径，保存路径值以便判断符合题目的路径。注意添加符合结果的路径需要新建一个对象，否则直接添加的path是同一个对象，后续会被覆盖。最后退出该层递归时，我们应删除当前结点，方便更新后续的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();<span class="comment">//使用链表，方便删尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        preorder(root,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用前序遍历，然后保存路径值判断是否符合条件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新当前的目标值，方便后续判断，因为使用递归，上一层的值不受影响</span></span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="comment">//如果当前路径值符合条件，且它是一个叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//添加的当前路径到结果集中，这里注意需要新建一个对象添加</span></span><br><span class="line">            <span class="comment">//若一直使用path，是使用同一个对象，后续会被直接覆盖</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">        preorder(root.left,target);</span><br><span class="line">        preorder(root.right,target);</span><br><span class="line">        <span class="comment">//当前结点递归完毕，返回上一层时要被删除，因为path存放的是一个路径，而不是树</span></span><br><span class="line">        path.removeLast(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</a></p>
<p>先是拼接新旧链表，然后巧妙的使用链表的指向特性给新链表的结点赋值，最后再将原链表和新链表拆分开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">//新旧链表的拼接复制，也就是在原链表每个结点后复制一个值相等的新链表结点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node temp = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            temp.next = cur.next;</span><br><span class="line">            cur.next = temp;</span><br><span class="line">            cur = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = head;<span class="comment">//重置光标</span></span><br><span class="line">        <span class="comment">//给每一个复制结点的random赋值</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//注意例子中的7，其新链表复制结点的random不赋值，默认为null</span></span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 复制结点的random = 原结点的random的后一位</span></span><br><span class="line"><span class="comment">             * 当不为空时，由于拼接复制，原结点random的后一位就是它本身</span></span><br><span class="line"><span class="comment">             * 而random为空时，不会走这个赋值，因为null没有复制结点</span></span><br><span class="line"><span class="comment">             * 且不赋值会自动初始化为null，就像例子里的7一样</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head.next;<span class="comment">//新链表</span></span><br><span class="line">        Node ori = head, ans = head.next;<span class="comment">//原链表和新链表的头</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//两个联表都是隔一个，直接连接next.next即可</span></span><br><span class="line">            ori.next = ori.next.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            ori = ori.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ori.next = <span class="keyword">null</span>;<span class="comment">//将原链表的结尾指向null</span></span><br><span class="line">        <span class="keyword">return</span> ans;<span class="comment">//返回新链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</a></p>
<p>注意是要构造双向循环链表，最后首尾指向也要更新。</p>
<p>然后使用中序遍历做即可，注意pre、head结点的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre,head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="comment">//结点的前驱与后继更新成功，还要头尾相连循环</span></span><br><span class="line">        pre.right = head;</span><br><span class="line">        head.left = pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        inorder(cur.left);</span><br><span class="line">        <span class="comment">//前驱结点不为空时，更新其后继指向当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.right = cur;</span><br><span class="line">        <span class="comment">//前驱结点为空，也就是第一个结点，此时应初始化头结点</span></span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        <span class="comment">//更新当前结点的前驱结点</span></span><br><span class="line">        cur.left = pre;</span><br><span class="line">        <span class="comment">//更新前驱结点</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        inorder(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/</a></p>
<p>本题类似层序遍历的使用，先将二叉树转层序遍历的字符串形式，后使用层序遍历的字符串重新转变成二叉树。我们需要数以拼接时末尾的逗号应该去掉，转变二叉树时字符串的首尾是中括号，不能要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//先序列化成一个字符串，后使用字符串反序列化得到二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);<span class="comment">//单线程使用StringBuilder拼接字符串</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;<span class="comment">//队列初始化加入头结点</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();<span class="comment">//出队列</span></span><br><span class="line">            <span class="comment">//结点不为空则拼接结点的值并让其左右孩子入队列，为空直接拼接null</span></span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ans.append(node.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.deleteCharAt(ans.length() - <span class="number">1</span>);<span class="comment">//删除末尾逗号</span></span><br><span class="line">        ans.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//字符串转字符串数组</span></span><br><span class="line">        <span class="comment">//0~1和length-1 ~ length是拼接字符串的[]，所以范围是1 ~ length-1</span></span><br><span class="line">        String[] vals = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//构造方法赋值，用parseInt字符串转十进制，初始化根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;()&#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();<span class="comment">//根结点是第一个</span></span><br><span class="line">            <span class="comment">//从第二个结点开始，也就是根结点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//左孩子赋值，然后入队列</span></span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;<span class="comment">//索引++</span></span><br><span class="line">            <span class="comment">//轮到根结点的右孩子，重复上述操作入队列</span></span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串的排列（回溯法）"><a href="#字符串的排列（回溯法）" class="headerlink" title="字符串的排列（回溯法）"></a>字符串的排列（回溯法）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p>
<p>其实思想就是传统的回溯，奈何之前算法了解片面，没用看相关书籍，回溯的原理似懂非懂，今天就mark一下，准备记录算法基础的了解与学习。</p>
<p>也就是每当我们递归前改变了”字符串”的状态，在结束当前递归后需撤销该状态改变，因为后续还要基于该层的最初基础也就是上一层的状态来改变，所以要回溯，这里仅限个人理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 导出为String类型数组</span></span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//已遍历到当前数组末位，转字符串存储</span></span><br><span class="line">            ans.add(String.valueOf(c));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i &lt; c.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果字符重复就跳过，使用set进行剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//开始对字符两两换位改变字符串，并保持当前更换的状态递归</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//退出递归后，将状态回溯到上一层，也就是该层递归前的状态改变要撤销</span></span><br><span class="line">            <span class="comment">//因为我们进行下一个循环是和现在这一层平行的，要保持该层最初状态</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评论区精简版，还可剪枝优化，但比交换看起来好理解一点，递归推到最外层时继续循环，然后就把第二个先标记了，随后的递归第二个就先添加了，然后依此类推。就是在依次固定首尾，其实思想都一样，就是有个交换看起来更复杂了。所以说剑指Offer书上为什么要交换？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        Set&lt;String&gt; list = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">        dfs(arr, <span class="string">&quot;&quot;</span>, visited, list);</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] arr, String s,  <span class="keyword">boolean</span>[] visited, Set&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == arr.length)&#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(arr, s+String.valueOf(arr[i]), visited, list);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</a></p>
<p>基础做法就是使用哈希表，遍历数组，键就是数组元素，值是该元素出现的次数，统计好后再遍历一次哈希表找到值最大的键输出即可。</p>
<p>取巧点就排序数组（ Arrays.sort() ），然后输出中间值，因为题目说该数字出现次数超过了数组的一半，排序后的中间值一定就是答案。</p>
<p>然后更巧妙的算法可以看大佬题解，例如摩尔投票法等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//统计键重复的次数，更新值</span></span><br><span class="line">            map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//遍历取出最大值的键</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue() &gt; max)&#123;</span><br><span class="line">                max = entry.getValue();</span><br><span class="line">                ans = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>摩尔投票法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化投票数与众数</span></span><br><span class="line">        <span class="keyword">int</span> vote = <span class="number">0</span>, mode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历一次数组，若投票和为0，说明上一个数不是当前的众数</span></span><br><span class="line">        <span class="comment">// 因为众数就会有多个连续相等，投票和不会归0</span></span><br><span class="line">        <span class="comment">// 随后就是判断当前众数是不是整个数组的众数</span></span><br><span class="line">        <span class="comment">// 若遍历完数组，当前众数的投票和不为0，说明它就是数组的众数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vote == <span class="number">0</span>) mode = num;</span><br><span class="line">            <span class="keyword">if</span>(mode == num) vote += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> vote -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回众数，没有众数则是初始值0</span></span><br><span class="line">        <span class="keyword">return</span> mode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/</a></p>
<p>弱智写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;k;i++)&#123;</span><br><span class="line">            ans[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快排：</p>
<p>基础算法要从头过一遍了，都忘了😂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//就是寻找中间值，每次都把数组分成左小右大，然后递归左右数组继续</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> i = l,j = r;<span class="comment">//i、j是现在操作的索引，l、r是当前的左右边界</span></span><br><span class="line">        <span class="comment">//l充当中间值，寻找比它小和大的数</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//从右边界开始，&gt;=中间值l就通过</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">            <span class="comment">//右边界索引遇到小于l，所以暂停了</span></span><br><span class="line">            <span class="comment">//然后从左边界开始，&lt;=中间值l就通过</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            <span class="comment">//i对应一个左边&gt;=中间值的数，j对应一个右边&lt;=中间值的数</span></span><br><span class="line">            <span class="comment">//因为需要调整数组为左小右大，二者换位</span></span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*在完成一次次大小交换后，i，j会指向同一个元素，因为i&lt;j以及i++的特性</span></span><br><span class="line"><span class="comment">         *且每次都是先判断j，也就是说i=j这个元素是根据j的暂停位置定下的，这个值小于中间值</span></span><br><span class="line"><span class="comment">         *然后我们可以把中间值真正的换到中间来，形成左小右大，然后根据左右数组继续递归</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        swap(arr,l,j);</span><br><span class="line">        <span class="comment">//现在i、j指向同一个即中间值，舍去中间值来划分左右区间即可</span></span><br><span class="line">        quickSort(arr,l,i-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr,j+<span class="number">1</span>,r);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实完全遍历一遍排序后时间都差不多，来看看大佬的优化，限制了返回的长度，只需要找出前k个元素来排序即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, k, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, l);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> quickSort(arr, k, l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> quickSort(arr, k, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据流中的中位数（堆排序）"><a href="#数据流中的中位数（堆排序）" class="headerlink" title="数据流中的中位数（堆排序）"></a>数据流中的中位数（堆排序）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p>
<p>使用优先队列实现大小堆，可以让查找中间值变为O1，因为中间值只会和大小堆顶元素产生关系。做这题前可以先去了解一下优先队列的规则，然后就明白为什么用它初始化大小堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; max,min;</span><br><span class="line">    <span class="comment">/* 123大顶堆，队首出队顺序为321。456小顶堆，队首出队顺序为456</span></span><br><span class="line"><span class="comment">     * 可以发现123456这个数据流存放两个堆后，大顶堆保存小的部分，小顶堆保存大的部分</span></span><br><span class="line"><span class="comment">     * 这样维护的两个堆的堆顶就和中间值产生了联系，数据是从小到大排序，会先在大顶堆存放</span></span><br><span class="line"><span class="comment">     * 所以当数据个数为奇数时，大顶堆比小顶堆多一个，也就是说中间值就是大顶堆的堆顶</span></span><br><span class="line"><span class="comment">     * 而个数为偶数时，中间值就是中间两个数的平均值，也就是大小堆顶元素的平均值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用优先队列，默认为升序排列，队首一定是最小的，符合小顶堆</span></span><br><span class="line">        max = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//优先队列使用降序排列，队首一定是最大值，符合最大堆</span></span><br><span class="line">        min = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 现在数据存放个数为奇数，也就是大顶堆比小顶堆多一个，往小顶堆存放</span></span><br><span class="line"><span class="comment">         * 否则两个堆都是偶数，该往大顶堆存放</span></span><br><span class="line"><span class="comment">         * 注意存放大小堆前一定要先存到对面然后再取，因为我们大顶堆要小的，小顶堆要大的</span></span><br><span class="line"><span class="comment">         * 但新进来的数据元素是无法分辨大小的，比方说要存入小顶堆，先存入大顶堆，然后取其队首</span></span><br><span class="line"><span class="comment">         * 保证入队的元素一定是除了小顶堆中最大的，存入大顶堆也同理，保证是除了大顶堆中最小的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(max.size() != min.size())&#123;</span><br><span class="line">            max.add(num);</span><br><span class="line">            min.add(max.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            min.add(num);</span><br><span class="line">            max.add(min.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max.size() != min.size() ? max.peek() : (max.peek() + min.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="连续子数组的最大值"><a href="#连续子数组的最大值" class="headerlink" title="连续子数组的最大值"></a>连续子数组的最大值</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</a></p>
<p>没有使用dp，直接分析数组，当前和为正数时，直接比较取最大值，若当前和为负数且小于待加的数就舍弃。（因为有全是负数的情况，所以和为负数不能直接舍弃）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//正数相加取最大值，负数的sum和下一个加的元素比较，若该值比待加元素还小就舍弃</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//如果当前sum小于0，且小于当前正处理的数，则这个sum无效并舍弃</span></span><br><span class="line">            <span class="keyword">if</span>(sum&lt;num &amp;&amp; sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += num;</span><br><span class="line">            max = Math.max(max,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a>1~n整数中1出现的次数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</a></p>
<p>我们将整个数分成3部分，高位、当前位、低位，然后逐位进行1数量的累加</p>
<ul>
<li>当前位=0，说明当前位无1，低位的改变不影响当前位1的数量，数量是high * 该位的幂因子</li>
<li>当前位=1，当前位可与低位配合增加1出现的数量（1000~1XXX），一共有XXX+1个，也就是low+1，然后加上高位的组合，数量是high * 幂因子+low+1</li>
<li>当前位=2<del>9，当前位可与低位配合增加1出现的数量（X000</del>XXXX），X&gt;1所以1000<del>1999这个区间被包含，也只有该区间有1出现，所以2</del>9都是一个情况，而此时低位组合后1出现次数为 该位的幂因子（10<del>19 = 10，100</del>199 = 100，1000~1999 = 1000 ·····），所以数量是high * 幂因子 + 幂因子，即(high+1) * 幂因子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化幂因数，也就是10的0次方，高位数、当前位、低位数</span></span><br><span class="line">        <span class="keyword">int</span> factor=<span class="number">1</span>,ans=<span class="number">0</span>,high = n/<span class="number">10</span>,cur = n%<span class="number">10</span>,low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从个位开始循环，直到最高位</span></span><br><span class="line">        <span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*分三种情况，当前位为0时，该位出现1的次数只与高位相关，high * factor</span></span><br><span class="line"><span class="comment">         *当前位为1时，该位出现1的次数除高位外，还要加低位即1000~1XXX(low)，也就是加low+1</span></span><br><span class="line"><span class="comment">         *当前位2~9时，只有一种情况即10~19的1，20~99当前位均不出现1，(high+1) * factor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) ans += high * factor;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) ans += high * factor + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans += (high + <span class="number">1</span>) * factor;</span><br><span class="line">            </span><br><span class="line">            low += cur * factor;<span class="comment">//低位更新为当前位*幂因子，当前位要前移，记录它现在的值归并到低位</span></span><br><span class="line">            cur = high % <span class="number">10</span>;<span class="comment">//当前位更新为高位取余，也就是顺移下一位</span></span><br><span class="line">            high = high / <span class="number">10</span>;<span class="comment">//高位更新为高位除去末位，也就是舍弃末位给当前位</span></span><br><span class="line">            factor *= <span class="number">10</span>;<span class="comment">//根据当前位数改变相应幂因子，也就是10的n次方</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/8.png" alt="8.png"></p>
<p>用了K神题解的图，先分析数字位数区间，起始位，数的数量（数字），数字数量（数位），得出关系式，然后用n减去低位数的数字数量直到&lt;0，此时说明现在的位数就是n的位数，然后再找n处于哪一个数的某个位置上，最后转换成int输出。<strong>注意start是第0个数，所以后续使用n-1计算，而不是n</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>; <span class="comment">//数位，也就是几位数</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>; <span class="comment">//每位数的起始位，1、10、100····</span></span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>; <span class="comment">//该位数有多少个数字，一位数1~9有9个，三位数100~999有900个</span></span><br><span class="line">        <span class="comment">//n&lt;0退出循环</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; count)&#123;</span><br><span class="line">            n -= count; <span class="comment">//减去低位数的数量</span></span><br><span class="line">            digit++; <span class="comment">//位数递增</span></span><br><span class="line">            start *= <span class="number">10</span>; <span class="comment">//更新起始位</span></span><br><span class="line">            count = <span class="number">9</span> * start * digit;<span class="comment">//9*start计算有多少个数，*digit计算有多少个数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跳出循环，说明低位数字的数量减完了，现在的位数就是当前n的</span></span><br><span class="line">        <span class="comment">//(n-1)/digit说明处于哪一个数中</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n-<span class="number">1</span>)/digit;</span><br><span class="line">        <span class="comment">//(n-1) % dight查看n是数的哪一个数字，-&#x27;0&#x27;是为了字符转换int型</span></span><br><span class="line">        <span class="comment">//&#x27;9&#x27;-&#x27;0&#x27;=9两个ascll码差值为int</span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n-<span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</a></p>
<p> 这题本质就是快排，只不过判断条件的书写需要注意一下。排序其实还是有点生疏，得抽空把排序练熟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="comment">//数组转字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        quickSort(strs,<span class="number">0</span>,strs.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//排好序后，拼接字符串数组，并返回String</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            ans.append(s);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(String[] strs,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l,j = r;</span><br><span class="line">        String temp = strs[i];</span><br><span class="line">        <span class="comment">//快排和哨兵做比较，哨兵左小右大</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="comment">//字符串比较， &gt;=0说明ji的排序比lj的大，j大于哨兵,j&gt;l，符合题意，j--查找下一位</span></span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="comment">//&lt;=0说明il比li的排序值小，i是小于哨兵，i&lt;l，符合题意，j++查找下一位</span></span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            <span class="comment">//前两个循环退出，说明此时的i&gt;l，j&lt;l，得出i&gt;j，打印最小数要从小到大，所以交换i、j</span></span><br><span class="line">            temp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时循环退出，i=j处于数组的中间部分，哨兵和i(j)交换，实现数组左小右大</span></span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = temp;</span><br><span class="line">        <span class="comment">//开启递归</span></span><br><span class="line">        quickSort(strs,l,i-<span class="number">1</span>);</span><br><span class="line">        quickSort(strs,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</a></p>
<p>本质就是一个动态规划的题目，需要找到dp的规律。这里借用一下k神的图来理解。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/9.png" alt="9.png"></p>
<p>1<del>i-1也就是前i-1个数的方案记为f(i-1)，推断出单独翻译第i个数时，有f(i-1)个方案，因为单独翻译i只有1种，其方案数由前i-1来决定。而题目种有26个字母，也就是两个数组合在[10,25]这个区间时，我们组合出新的方案，例：i-1</del>i两个组合成一个可被翻译的数，其方案数为f(i-2)，由前i-2来决定。</p>
<p>所以计算f(i)，分两种情况，i-1<del>i可以组合，f(i) = f(i-2) + f(i-1)；i-1</del>i不可组合，f(i) = f(i-1)。通过字符串的分割和比较来实现区间判断。substring(i-2,i)是i-2、i-1的组合字符串。</p>
<p>假设dp[2]也就是前两个数可组合，得到dp[2]=dp[0]+dp[1]，明确知道dp[2]=2，dp[1]=1，倒推出dp[0]=1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];<span class="comment">//多了一种空串的情况dp[0]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//空串</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//只有一个字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ;i &lt; s.length()+<span class="number">1</span> ;i++)&#123;</span><br><span class="line">            String temp = s.substring(i-<span class="number">2</span>,i);<span class="comment">//左闭右开</span></span><br><span class="line">            <span class="comment">//判断是否能两两组合，[10,25]才能被翻译</span></span><br><span class="line">            <span class="keyword">if</span>(temp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; temp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;=<span class="number">0</span>)</span><br><span class="line">                dp[i] = dp[i-<span class="number">2</span>] + dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/</a></p>
<p>标准的动态规划题目，找到转义方程就很好做了，注意我们可以直接在原来的二维数组上覆盖值变成答案，最后直接返回最后一个元素即可。直接覆盖比较节省空间，然后分四种处理情况，左上角初始值不变，上和左靠边的值只受单方向影响，其余值则累加左和上的最大值。左和上对应 只能右和下移动。</p>
<p>有两种方法，一种是直接遍历数组，分情况判断，但多执行多次边情况的判断语句，所以另一种方案是先初始化边上值，然后遍历其余元素即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// for(int i=0;i &lt; m;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j &lt; n;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(i==0 &amp;&amp; j==0) continue;</span></span><br><span class="line">        <span class="comment">//         if(i==0) grid[i][j] += grid[i][j-1];</span></span><br><span class="line">        <span class="comment">//         else if(j==0) grid[i][j] += grid[i-1][j];</span></span><br><span class="line">        <span class="comment">//         else grid[i][j] += Math.max(grid[i-1][j],grid[i][j-1]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j &lt; n;j++) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];<span class="comment">//上边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; m;i++) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];<span class="comment">//左边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                grid[i][j] += Math.max(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</a></p>
<p>这题书上用的是动态规划，但我一开始想到的思路就是滑动窗口的，所以就没有选择动态规划的做法，用哈希表来进行滑动窗口，我一开始还在那捣鼓数组和字符串，根本没想到用Map容器比较好。</p>
<p>基本思路就是遍历一次字符串，无重复右边界++，记录长度最大值，有重复则修改左边界然后记录最大值，这里关键就是这个左边界的更新。使用的是下面这个语句，一开始不知道为什么要取max，然后发现了一个特殊情况**”abba”**，max就是为了应对这种情况，详细看下面分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(r);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cur))&#123;</span><br><span class="line">            <span class="comment">/* 右边界值cur重复，所以更新左边界，但map存放的cur是第一次的位置还没有更新</span></span><br><span class="line"><span class="comment">             * 所以我们现在是获取cur上次位置+1，在&quot;abca&quot;中a重复，l指向b，就没有重复的值</span></span><br><span class="line"><span class="comment">             * 但是为什么与l取最大值呢，在&quot;abba&quot;中a重复，l应指向第二个b，因为b之前已经重复了</span></span><br><span class="line"><span class="comment">             * 若指向a重复的初始位置+1，则bba还包含一个重复，所以我们是取一个最大值 </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                l = Math.max(l, map.get(cur) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(r),r);</span><br><span class="line">            <span class="comment">//我边界初始化l=0，而不是l=-1，所以重复计算是r-i+1</span></span><br><span class="line">            ans = Math.max(ans,r-l+<span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">https://leetcode-cn.com/problems/chou-shu-lcof/</a></p>
<p>按照2、3、5的倍数，从1开始，模拟构造整个丑数序列，返回第n个数，其中每次返回乘积最小值作为这一个序列的值，给每一个倍数都标记一个索引值，即代表处于数组的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们直接求出丑数序列，返回第n个即为答案</span></span><br><span class="line"><span class="comment">//因为丑数只与2、3、5有关，序列初始化第一个是1，随后序列中的数分别乘以2、3、5</span></span><br><span class="line"><span class="comment">//取最小值为第二个，然后该最小值的倍数的索引++，这样从1开始就是一个完整的丑数序列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">0</span>,i3=<span class="number">0</span>,i5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans2 = res[i2] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> ans3 = res[i3] * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> ans5 = res[i5] * <span class="number">5</span>;</span><br><span class="line">            res[i] = Math.min(ans2,Math.min(ans3,ans5));</span><br><span class="line">            <span class="keyword">if</span>(ans2 == res[i]) i2++;</span><br><span class="line">            <span class="keyword">if</span>(ans3 == res[i]) i3++;</span><br><span class="line">            <span class="keyword">if</span>(ans5 == res[i]) i5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p>
<p>注意这里键值对使用的是布尔值，方便后续判断返回，如果记数统计，后续还要加一个判断语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希表按字符、布尔值的键值对存储</span></span><br><span class="line">        Map&lt;Character,Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="comment">//将当前字符存入哈希表，有重复字符则记为false，无重复true</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str)</span><br><span class="line">            map.put(c, !map.containsKey(c));</span><br><span class="line">        <span class="comment">//因为要按序返回结构，遍历字符串，若当前字符无重复就返回字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str)</span><br><span class="line">            <span class="keyword">if</span>(map.get(c)) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="comment">//所有其他情况返回空格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有序哈希表，使用LinkedHashMap这个特殊结构，保证哈希表的存储是有序的，最后我们直接遍历哈希表的即可，因为哈希表去重，我们不用重复访问同一字符，比遍历字符串可能快一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Boolean&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str)</span><br><span class="line">            map.put(c, !map.containsKey(c));</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Boolean&gt; entry : map.entrySet())</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue()) <span class="keyword">return</span> entry.getKey();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p>
<p>归并排序题目，下面写了K神的注释版，这个看明白后可以再看一下另外一个版本，我感觉看起来思路会更加清晰。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/20.png" alt="20.png"></p>
<p>K神：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums, temp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> mergeSort(<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = mergeSort(l,m) + mergeSort(m+<span class="number">1</span>,r);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nums是原数组，我们要通过归并排序来排序</span></span><br><span class="line">        <span class="comment">//先把值赋予临时数组，临时数组通过排序再来更新nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">            temp[k] = nums[k];</span><br><span class="line">        <span class="comment">//i、j分别指向左右子数组的初始位，l~m，m+1~r</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class="line">            <span class="comment">//i==m+1，说明左子数组合并完毕，直接把剩下的右子数组合并即可</span></span><br><span class="line">            <span class="comment">//因为左右子数组是已经排好序的，所以左边合并完，右边可以直接进来</span></span><br><span class="line">            <span class="keyword">if</span>(i == m + <span class="number">1</span>)</span><br><span class="line">                nums[k] = temp[j++];</span><br><span class="line">            <span class="comment">//右子数组边界r，r+1代表有子数组合并完毕，后把剩下的左子数组合并</span></span><br><span class="line">            <span class="comment">//当左值小于右值，就把左值存放到nums，此时没有逆序对</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == r + <span class="number">1</span> || temp[i] &lt;= temp[j])</span><br><span class="line">                nums[k] = temp[i++];</span><br><span class="line">            <span class="comment">//else即左值大于右指，出现逆序对，需要存入右指并计算逆序对数量</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[k] = temp[j++];</span><br><span class="line">                <span class="comment">//我们计算逆序对数量通过左子数组判断，当前出现逆序对</span></span><br><span class="line">                <span class="comment">//左子数组索引是i，i之后的值都是大于右值的，因为子数组有序</span></span><br><span class="line">                <span class="comment">//而i之前的值都是小于右值，然后才i++通过的</span></span><br><span class="line">                <span class="comment">//所以计算左子数组当前位到末位的数量，即当前位逆序对数量</span></span><br><span class="line">                ans += m - i + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评论区版本，理解归并排序后，我感觉这个写的更清晰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并排序，在其过程中统计逆序数量，右边每次放上去都要加上：left.length - i</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//统计归并过程中的逆序对数情况</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不构成任何一对</span></span><br><span class="line">        mergesort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] mergesort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == h) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[l]&#125;;<span class="comment">//单个数据直接返回</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left = mergesort(nums, l, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = mergesort(nums, mid + <span class="number">1</span>, h);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[h - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] &lt;= right[j])&#123;</span><br><span class="line">                res[m++] = left[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[m++] = right[j++];</span><br><span class="line">                count += left.length - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length)</span><br><span class="line">            res[m++] = left[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right.length)</span><br><span class="line">            res[m++] = right[j++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
<p>通过数学思维来简化代码，很巧妙，语句也很简便易懂。可以看看题解的动图详解：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//通过数学思维简化，将两个链表相交转换为</span></span><br><span class="line"> <span class="comment">//走完a.length + B相交前的length = b.length + A相交前的length</span></span><br><span class="line"> <span class="comment">//设公共结点same个，A总结点a个，B总结点b个</span></span><br><span class="line"> <span class="comment">//a + (b-same) = b + (a-same)，可以直接画个图看看</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode A = headA,B = headB;</span><br><span class="line">        <span class="comment">//!=null的判断就是为了走完原链表后，继续走另一个链表的未相交部分</span></span><br><span class="line">        <span class="comment">//这里用三元运算符就很简便</span></span><br><span class="line">        <span class="keyword">while</span>(A != B)&#123;</span><br><span class="line">            A = A!=<span class="keyword">null</span> ? A.next : headB;</span><br><span class="line">            B = B!=<span class="keyword">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p>
<p>这里使用二分法加快时间效率，需要注意中间值与目标值相等时，后续的边界该如何判断，查找重复目标数的右边界就归于小于情况，查找左边界归于大于情况，然后退出循环的边界复制可以去看K神题解的动图，边界好理解退出循环时l、r的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中间值mid小于target和大于的情况与以前二分一样</span></span><br><span class="line"><span class="comment"> * 小于说明目标值在右边，左边界=mid+1</span></span><br><span class="line"><span class="comment"> * 大于说明目标值在左边，右边界=mid-1</span></span><br><span class="line"><span class="comment"> * 而mid==target时，我们根据情况分类：</span></span><br><span class="line"><span class="comment"> * 查询重复目标数的右边界，就归于小于的情况，向右查找</span></span><br><span class="line"><span class="comment"> * 查询重复目标数左边界时，归于大于情况，向左查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查找重复目标数的右边界</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* 此时数组边界l&gt;r，也就是当l=r的数大于target，执行了r=mid-1</span></span><br><span class="line"><span class="comment">     * 可以看题解的动图很直观，处理后r处于重复目标数的右边界，l在右边界后一位</span></span><br><span class="line"><span class="comment">     * r应该是最后一个重复目标数，而它不等于target则说明数组无目标数，返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">int</span> right = r;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; nums[r] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找重复目标数的左边界</span></span><br><span class="line">        l=<span class="number">0</span>;r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//l是第一个重复目标数</span></span><br><span class="line">        <span class="keyword">int</span> left = l;</span><br><span class="line">        <span class="comment">//重复目标数的首尾索引相减后+1，就是重复的次数</span></span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隔了好久回来刷题，发现下面简写版本更易理解，说实话这题二分想的挺多的，不如遍历😂，但是思想要到位。遍历也可以剪枝的，当值大于目标就可以直接退出了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> local(nums, target) - local(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分查询目标值，返回最终两索引碰头位置，也就是目标值区间后第一个数</span></span><br><span class="line">    <span class="comment">// 通过两次相邻目标值返回的终结索引，可以得到目标值的区间，计算差值可得出现次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">local</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/</a></p>
<p>K神：排序数组的搜索问题，优先二分法、双指针。要注意退出循环后的两个指针的位置，然后判断返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果中间值不相等，那么一定是已经缺失了数字，向左查找</span></span><br><span class="line">        <span class="comment">//而相等缺失数字还不存在，向右查找</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//退出循环，r&lt;l,此时nums[r]与nums[l]间即为缺值</span></span><br><span class="line">        <span class="comment">//l、r分别指向&quot;右子数组的首位元素&quot;和&quot;左子数组的末位元素&quot;</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树的第k大结点"><a href="#二叉搜索树的第k大结点" class="headerlink" title="二叉搜索树的第k大结点"></a>二叉搜索树的第k大结点</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p>
<p>因为是二叉搜索树，左小右大，我们使用右根左的中序遍历，递归二叉树后，数组记录从大到小的根结点值，返回第k-1个结点即可。但还可以优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        inorder(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归时实时更新k值，当k==0时就纪录当前根节点，随后的递归全部直接退出，这样可以不用遍历完二叉树。走到第k个就返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans,k;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历到第k个值后就记录值并退出</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">        <span class="comment">//如果当前k==0，说明值已找到，可以停止递归了</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* if(k == 0) return;</span></span><br><span class="line"><span class="comment">         * k--;</span></span><br><span class="line"><span class="comment">         * if(k == 0) ans = root.val;</span></span><br><span class="line"><span class="comment">         * 当前k!=0，--k即走过一个结点，若==0就记录值</span></span><br><span class="line"><span class="comment">         * 这里是把走过一个结点改变k值和第二次判断k写一起了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>) ans = root.val;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</a></p>
<p>easy题，记录深度状态，每次叶子结点就更新深度，最后返回深度即可。（也就是所有路径长度的最大值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 遍历二叉树，往下走一层，深度++，然后走左右子树</span></span><br><span class="line"><span class="comment"> * 左右子树都返回后退回上一层，深度--</span></span><br><span class="line"><span class="comment"> * 每次走到叶子结点就返回并更新深度值</span></span><br><span class="line"><span class="comment"> * 最后返回深度的值即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化深度为0，每往下走一层就+1</span></span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>,ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        tree(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ans = Math.max(depth,ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;<span class="comment">//往下走一层</span></span><br><span class="line">        tree(root.right);<span class="comment">//走右子树</span></span><br><span class="line">        tree(root.left);<span class="comment">//走左子树</span></span><br><span class="line">        depth--;<span class="comment">//返回上一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></p>
<p>自底向上，我们先走到叶子结点，然后返回上一层，并记录左右子树的深度，然后每走到一个子树根结点就判断其子树是否为AVL，如果是就继续返回上层进行判断，如果不是就返回-1来标记不是AVL，且每次计算子树深度后都判断该值是否为-1，如果是-1则说明这棵树不是AVL，然后就可以直接返回进行剪枝操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等于-1则不是AVL树，这里true要判断是AVL，所以要不等于-1</span></span><br><span class="line">        <span class="keyword">return</span> balance(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">balance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//走到叶子结点就终止</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = balance(root.left);</span><br><span class="line">        <span class="comment">//如果左子树为-1说明已判断不是AVL，直接返回-1进行剪枝处理</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> right = balance(root.right);</span><br><span class="line">        <span class="comment">//右子树不是AVL，直接返回进行剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//abc绝对值取当前左右子树差值，若深度差小于1，说明当前结点左右子树符合AVL</span></span><br><span class="line">        <span class="comment">//返回当前结点的深度，深度差大于1，说明该结点子树已不是AVL返回-1</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt;= <span class="number">1</span> ? Math.max(left,right)+<span class="number">1</span> : -<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组中数字出现的次数（一）"><a href="#数组中数字出现的次数（一）" class="headerlink" title="数组中数字出现的次数（一）"></a>数组中数字出现的次数（一）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</a></p>
<p>规定O(n)的时间复杂度，我们不可以使用Map键值对，这里很巧妙使用了异或以及按位与的位运算。先通过异或找到两个不相等数的异或和；然后按位与找到异或和中的差异位，这就是两个不相等数的不同位，只有其中一个数有这个位数；接着我们就把数组以该位数分成两部分，一部分有这一位，另一部分没有这一位，并异或计算；由于其他数都是成对出现，异或后都会变为0不影响结果，我们通过差异位分组异或就得到了两个不相等的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>,a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 异或，两个相等的数计算后等于0，0与任意数计算等于该数本身</span></span><br><span class="line"><span class="comment">         * 根据题意数组异或后得到两个不相等数的异或和</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            a ^= num;</span><br><span class="line">        <span class="comment">/* 由于a是两个不相等数的异或和，那么a一定有为1的位数</span></span><br><span class="line"><span class="comment">         * 这一位就代表两个不相等数的差异位，我们从1位开始查找异或和的差异位</span></span><br><span class="line"><span class="comment">         * 只要当前位不为1，说明还没找到差异位，就左移参数b，继续查找</span></span><br><span class="line"><span class="comment">         * 最后退出循环时，b就是差异位的位数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>( (a &amp; b) == <span class="number">0</span> )</span><br><span class="line">            b &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* b代表差异位，我们通过按位与操作来查找存在差异位的数</span></span><br><span class="line"><span class="comment">         * 将存在差异位的数和不存在的数分成两个部分分别异或计算，也就是按位与b判断</span></span><br><span class="line"><span class="comment">         * 除了两个不相等的数，其余数都是成对出现，我们相当于在分开两个不相等的数</span></span><br><span class="line"><span class="comment">         * 由于其余数的都是成对的，异或和为0，则分开异或得到的结果就是两个不相等的数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (num &amp; b) == <span class="number">0</span> ) ans1 ^= num;</span><br><span class="line">            <span class="keyword">else</span> ans2 ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;ans1,ans2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组中数字出现的次数（二）"><a href="#数组中数字出现的次数（二）" class="headerlink" title="数组中数字出现的次数（二）"></a>数组中数字出现的次数（二）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</a></p>
<p>思路就是把数组每一个数逐位判断，统计该位==1的次数，然后和3取余，由于其他数都是3个一对，只有一个数是单独的，所以当我们取余后与1判断，如果等于1说明这一位是单独数所包含的，然后就按位 或运算 给结果的这一位数赋值。逐位判断后即可得到这个单独的数。</p>
<p>其他的简答方法，哈希表存储后查找值==1的键；使用排序算法将数组排序，然后有三种情况：ABBBCCC、BBBACCC、BBBCCCA，我们就分三种情况讨论，若第一个!=第二个，最后一个不等于倒数第二个，遍历数组的中间值不等于前后两个数，那么第一个、最后一个、中间值就是三种情况下的单独数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结果初始化全0</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记结果的位数，逐位赋值，int上限32位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//把全部数组的值右移要标记的位数，计算数组这一位有多少个1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++)</span><br><span class="line">                count += (nums[j] &gt;&gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有余2的情况，都是3个一对，多出了1个，只会余1</span></span><br><span class="line">            <span class="comment">//所以余1代表，这一位出现了单独的数字，要记入结果</span></span><br><span class="line">            <span class="keyword">if</span>(count % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//&lt;&lt;优先级高于|=，我们先左移i位1，然后将结果的这一位标记为1</span></span><br><span class="line">                res |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/</a></p>
<p>简单题，左右双指针解决。还有哈希表存值匹配的做法，就是两数之和那题的解法，不过这里数据更多O(n)很慢了，我们可以借助排序特性，使用左右双指针只遍历一次数组实现O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右边界双指针判断值所在区间，然后更新左右边界</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] + nums[r] &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[l] + nums[r] &lt; target) l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[l],nums[r]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</a></p>
<p>题目思路很简单，滑动窗口。但最后list转数组让我犯了愁，可以看看下面这个文章，写的比较清楚：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904145753735176">https://juejin.cn/post/6844904145753735176</a></p>
<p>也就是说我们使用toArray方法，不带参数返回Object类型，带参数就返回参数类型，由于Object是不能直接强转其他类型的，所以我们使用**toArray(T[] a)**这个重载方法参数就是我们需要返回的类型，而这个参数数组一般大小设为0，Java为这一块进行过优化，如果设置大小偏大或偏小都要重新分配，还不如一开始设为0，且大小设置相等时，遇见高并发情况也会出现问题，所以我们直接设大小为0是性能最优的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//滑动窗口，思路比较简单，因为最少两个数，左右边界初始化为1、2</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>,sum=<span class="number">3</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//注意判断完一组符合target的数组并添加后，我们要让循环继续</span></span><br><span class="line">            <span class="comment">//所以要改变边界，左右均可</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)</span><br><span class="line">                    res[i-l] = i;</span><br><span class="line">                ans.add(res);</span><br><span class="line">                sum += ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target) sum += ++r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) sum -= l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里返回值要集合list转数组，使用toArray重载方法</span></span><br><span class="line">        <span class="comment">//也就是toArray(T[] a)带参数的，不带参数是Object，带参数就是指定类型</span></span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/</a></p>
<p>双指针的思路很简单，而且K神还想到了分割字符串后倒叙拼接，我一开始是倒叙+栈😂，慢哭了。看到双指针就明白优化的方法了，一开始还没想到，而且分割+倒叙拼接也很巧妙。有思路后马上就懂了，就是需要注意的空格的处理，自己写的时候没考虑周全，为了满足空格的处理情况加了很多不必要判断。</p>
<p>我的脑抽写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(temp[temp.length-<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) stack.push(temp[temp.length-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=temp.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">                    sb.append(stack.pop());</span><br><span class="line">                sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去首尾空格，并初始化左右边界，从后往前</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">int</span> r = s.length()-<span class="number">1</span>,l = r;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//查找单词左边界，也就是单词前的第一个空格</span></span><br><span class="line">            <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; s.charAt(l) != <span class="string">&#x27; &#x27;</span>) l--;</span><br><span class="line">            <span class="comment">//截取字符串左闭右开，现在l处于单词前一个空格处，r处于单词末位</span></span><br><span class="line">            <span class="comment">//故根据左闭右开，截取范围是l+1~r+1</span></span><br><span class="line">            ans.append(s.substring(l+<span class="number">1</span>,r+<span class="number">1</span>) + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="comment">//单词之间的多个空格直接省略</span></span><br><span class="line">            <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; s.charAt(l) == <span class="string">&#x27; &#x27;</span>) l--;</span><br><span class="line">            <span class="comment">//多个空格省略后，左边界的位置就是下一个单词的右边界</span></span><br><span class="line">            r = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值还要取出每次拼接的空格，因为最后一次会多一个</span></span><br><span class="line">        <span class="keyword">return</span> ans.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分割+倒叙拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串去首尾空格后，按照空格分割单词</span></span><br><span class="line">        <span class="comment">//但是要注意有X个空格相连时(X&gt;1)，分割后会形成X-1个空字符串&quot;&quot;</span></span><br><span class="line">        String[] strs = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strs.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//把分割时形成的空字符串跳过</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            ans.append(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a></p>
<p>简单题，左右截取，反转拼接即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不允许使用substring，则可以遍历字符串</span></span><br><span class="line"><span class="comment">//使用StringBuilder拼接第n+1~末位，然后是第0到第n，是一个意思</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String left = s.substring(<span class="number">0</span>,n);</span><br><span class="line">        String right = s.substring(n,s.length());</span><br><span class="line">        right += left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p>
<p>滑动窗口的思路其实很好想，我一开始也想到了先找一次max，然后每次与新的右边界比较依照结果更新max，如果max是左边界则要重新找max，因为max已不存在更新后的滑动窗口。但在数据存放上没有找到一个好都容器。这里K神使用双端队列就很巧妙解决问题，写的也很好懂，特别是左边界情况的判断这一步写的很巧妙。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//最大值结果输出的次数，也就是滑动了几次</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口还未形成，0~k-1，没有滑动</span></span><br><span class="line">        <span class="comment">//队列存放从大到小，队首是最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成遍历后，此时形成第一个滑动窗口，右边界k-1，最大值就是队首</span></span><br><span class="line">        ans[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已形成窗口，i表示为当前滑动窗口的右边界</span></span><br><span class="line">        <span class="comment">//但此时右边界为k，说明初始化为第二个滑动窗口</span></span><br><span class="line">        <span class="comment">//滑动时，如果最大值是未滑动前的左边界，那么之后就不在考虑它，因为它不在窗口内了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//队列最大值与未滑动前窗口左边界比较</span></span><br><span class="line">            <span class="comment">//若二者相等，说明最大值马上和现在的新窗口无关，让最大值出队</span></span><br><span class="line">            <span class="keyword">if</span>(deque.peekFirst() == nums[i - k])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="comment">//判断完左边界最大值的特殊情况后，我们只用考虑右边界与最大值的情况</span></span><br><span class="line">            <span class="comment">//然后更新对垒，形成从大到小排序</span></span><br><span class="line">            <span class="comment">//最后记录第二个滑动窗口的max</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/</a></p>
<p>构造一个正常的先进先出队列queue，然后再构造一个双端队列deque进行两头操作来维护最大值，和昨天题目一样，值在deque中从大到小排序。</p>
<p>queue就是正常入队出队，deque需要进行最大值维护。</p>
<p>queue入队时，若当前值&gt;deque末值，末值出队，将deque所有小于当前值的值都出队后，当前值入deque队尾。</p>
<p>queue出队时，若当前值=deque首位，首位也要出队，毕竟现在最大值已不存在queue中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列正常记录先进先出</span></span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line">    <span class="comment">//双端队列记录最大值的变化，队首即最大值</span></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty() ? -<span class="number">1</span> : deque.peekFirst();</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue.add(value);<span class="comment">//入队</span></span><br><span class="line">        <span class="comment">//更新最大值</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果正常队首是最大值，我们双端队列也要舍去该值</span></span><br><span class="line">        <span class="keyword">if</span>(queue.peek().equals(deque.peekFirst()))</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/</a></p>
<p>做这道题首先是理解题目意思，然后理解暴力破解思路，然后动态规划的做法就很好理解了。这道题就是逐渐加入骰子，然后求有n个骰子时其点数产生的范围是什么，然后求处这个范围里的值的分布概率，按序输出值的分布概率。下面贴一下K神题解的图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/12.png" alt="12.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] cur = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">6</span>];</span><br><span class="line">        <span class="comment">//初始化只有一个骰子的情况，即出现值为1~6，每个概率为1/6</span></span><br><span class="line">        Arrays.fill(cur,<span class="number">1.0</span>/<span class="number">6.0</span>);</span><br><span class="line">        <span class="comment">//从加入第二个骰子开始dp计算概率，直到第n个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//初始化现在新加入骰子后的值分布范围</span></span><br><span class="line">            <span class="comment">//从1~6开始，每次加入新骰子即最小值+1，最大值+6的范围</span></span><br><span class="line">            <span class="comment">//1~6，2~12，3~18，4~24，即6+5+5+···，综上得出5*i+1</span></span><br><span class="line">            <span class="keyword">double</span>[] temp = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span> * i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第一层记录n-1个骰子有多少个值，每一个值都要+1···+6来计算概率</span></span><br><span class="line">            <span class="comment">//概率依值递增，1+1，1+2，1+3···3+1···3+6···6+6</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur.length; j++)&#123; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">//每次出现重复值都会++，然后要/6.0计算当前分布的基数</span></span><br><span class="line">                    <span class="comment">//1/6，1/36，1/216就是基数，多个骰子肯定会有重复值，那么重复值概率也要++</span></span><br><span class="line">                    temp[j+k] += cur[j]/<span class="number">6.0</span>;<span class="comment">//cur[j] * (1.0/6.0)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新现在第n个骰子的值分布概率</span></span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</a></p>
<p>这道题可以想到很复杂，但解题关键就一句话，max-min&lt;5，满足这个判断的无重复序列即可组成顺子，不得不说K神这规律挺会找啊，我一开始还在纠结怎么判断顺子，然而K神直接从结果出发，很容易解决了问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//若当前牌是癞子，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//更新最大、小牌值</span></span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">            <span class="comment">//除癞子外，有重复牌的情况一定组成不了顺子</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(num)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//首次出现的牌，添加到set</span></span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能通过循环，说明5个数除癞子外无重复</span></span><br><span class="line">        <span class="comment">//也就是最大最小之间差4个以内的无重复序列是可以组成顺子的</span></span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="圆圈中最后剩下的数字（约瑟夫环）"><a href="#圆圈中最后剩下的数字（约瑟夫环）" class="headerlink" title="圆圈中最后剩下的数字（约瑟夫环）"></a>圆圈中最后剩下的数字（约瑟夫环）</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p>
<p>数学问题，这个解法只能说是看得懂讲不清楚的🤣，关键就是推导公式cur = (cur + m) % i，理解了这个题目就很容易了。注意我们解法就是倒推，这里贴一下K神的图，看图比较好理解。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/14.png" alt="14.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前剩下数字的索引位置</span></span><br><span class="line">        <span class="comment">//我们从只剩下一个数字的最终情况出发，来倒推该数字存在于原队列的位置</span></span><br><span class="line">        <span class="comment">//只剩一个数字的情况可以确定该数字的索引为0</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i即当前的数字总数，由于倒推从2开始一直到n，因为一开始给的是n个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//这一步是在还原上一层删除前，最后剩下数字在该队列的位置</span></span><br><span class="line">            <span class="comment">//cur + m是加每一层删除的个数，比如每次删第2个</span></span><br><span class="line">            <span class="comment">//01234、2340、402、24、2，我们通过加上m并取余获取索引变化前的位置</span></span><br><span class="line">            cur = (cur + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后直接返回cur，因为序列是从0开始，和索引从0开始一致</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/</a></p>
<p> 这道题自己想到了非暴力破解思路就试着写写看，没想到过了，然后再去学习一下K神的题解，没想到大佬的更简洁😂，动态规划的思想还需要锻炼。</p>
<p>其实我的思想和K神的差不多，时间、空间效率算下来也差不多，就是写的有点冗杂了。，可以稍稍精简一下。然后说一下题目思路，利润主要讲究低买高卖，我们维护最小值来记录最大利润即可。当前最小值一有更新就使用新的min，最后返回利润即可。</p>
<p>自己的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_key = <span class="number">0</span>, min_value = prices[<span class="number">0</span>], profit = <span class="number">0</span>, ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; prices.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min_key == prices.length-<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = min_key + <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i] &lt; min_value)&#123;</span><br><span class="line">                    min_key = i;</span><br><span class="line">                    min_value = prices[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    profit = prices[i] - min_value;</span><br><span class="line">                    ans = Math.max(ans,profit);</span><br><span class="line">                &#125;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>K神：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">            min = Math.min(min,price);</span><br><span class="line">            profit = Math.max(profit,price - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">https://leetcode-cn.com/problems/qiu-12n-lcof/</a></p>
<p>由于限制了运算符，我们使用&amp;&amp;逻辑运算符的短路特性，即A&amp;&amp;B，若A为falseB就不会判断了，所以我们通过一个布尔值来确实 n==1 时退出递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过布尔值辅助，判断递归的结束</span></span><br><span class="line">        <span class="keyword">boolean</span> x = n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>) &gt; <span class="number">1</span>;</span><br><span class="line">        sum += n;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</a></p>
<p>题目一上来就禁止了+-*/，我们很自然就想到要用位运算，但怎么用就不知道了，看了下K神的题解，解析的很详细。我们把加法过程分为不进位和进位两种情况。</p>
<ul>
<li>不进位：此时我们只需要通过<strong>异或</strong>运算计算01-&gt;1、00-&gt;0、11-&gt;0，11此时要进位，不能记为1，所以没有使用按位与，然后就算出了当前不用进位的和。</li>
<li>进位：通过按位与和移位运算，我们将同为1的位标记出来，并实现进位，也就是将其高的一位记为1，也就是左移1</li>
</ul>
<p>最后我们又将进位后的数与无进位和进行循环计算，直到没有进位，此时的无进位和就是两数的加法结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//a相当于无进位和，b相当于进位数，carry在汇编里代表进位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//没有进位时，直接算出和即可</span></span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//进位就是ab二进制有两位同为1就进位</span></span><br><span class="line">            <span class="comment">//同时左移一位，因为进位后肯定到高位了</span></span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//a与b计算不用进位的位数和，异或符合条件</span></span><br><span class="line">            <span class="comment">//因为 1 1 的情况，异或返回0</span></span><br><span class="line">            a ^= b;</span><br><span class="line">            <span class="comment">//b更新为进位数，然后再去和无进位和相加</span></span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后没有进位时返回的位数和就是答案</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//详细一点的写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>, sum = a ^ b;</span><br><span class="line">        <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            sum = a ^ b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/</a></p>
<p>看到题目我以为又是用位运算模拟，然后看了题解发现解法很巧妙，暴力解法肯定就是遍历数组a，然后b[i]等于这一排的数连乘，但不包括a[i]，使用暴力肯定是超时的。</p>
<p>我们可以拆分问题，通过i把数组分割成左右两部分，先遍历一次a数组，把左半部分对应每个b[i]进行连乘，然后在进行一次a数组遍历，从倒数第二个开始反向遍历，补上b[i]的右半部分，我们只需要两次拆分遍历便可完成连乘数组b的构建。可以看K神的分析图来理解。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/15.png" alt="15.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/16.png" alt="16.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算左半部分，i之前的数值连乘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            b[i] = b[i-<span class="number">1</span>] * a[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算右半部分，i之后的数值连乘并乘以左部分得到结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            temp *= a[i+<span class="number">1</span>];</span><br><span class="line">            b[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</a></p>
<p>这道题确实有思路，也写出来了90%，就在最后拉了跨，超过long的范围的值确实有点不会处理，但tm怎么会有”+-2”、”-5-“、”-13+5”这种测试用例的。。。。。这几个用例真nm绝了。</p>
<p>自己写的有缺陷版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) temp.append(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="number">48</span> &amp;&amp; c &lt;= <span class="number">57</span>) temp.append(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str = temp.toString();</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                ans = <span class="number">0</span> - ans;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            ans += (c-<span class="number">48</span>) * cur;</span><br><span class="line">            cur *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; <span class="number">0</span> &amp;&amp; ans &lt; Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; Integer.MAX_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>K神yyds，不多说啊，符号位和越界的处理都十分巧妙，五体投地了这下是。时间复杂度O(n)，因为使用了trim()去空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去空格，转换字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] c = str.trim().toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(c.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里判断越界的边界设置的很巧妙，并不是MAX，而是MAX/10</span></span><br><span class="line">        <span class="comment">// 我们判断时，只要非最终位越界，说明下一位肯定会越界</span></span><br><span class="line">        <span class="comment">// 这里/10，不用在最高位判断越界情况，因为越界就无法判断</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断标志位，这里就限制了标志位只在第一位生效</span></span><br><span class="line">        <span class="comment">// 后续出现的标志位就和其他字符一样没有用了</span></span><br><span class="line">        <span class="comment">// 这里i初始化1也很关键，若第一位是符号，则遍历从第2位开始</span></span><br><span class="line">        <span class="comment">// 而第1位不是符号的情况，遍历就从第1位开始</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span>) i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; c.length; j++)&#123;</span><br><span class="line">            <span class="comment">// 遍历到数字以外的字符，直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(c[j] &lt; <span class="string">&#x27;0&#x27;</span> || c[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 越界判断，这里是从左往右遍历，越界情况分两种</span></span><br><span class="line">            <span class="comment">// 判断时都是先判断越界再更新结果，走n前判断n-1值是否越界</span></span><br><span class="line">            <span class="comment">// 1、当前结果已越界，因为判定时一定不是最后一位</span></span><br><span class="line">            <span class="comment">//    所以接下来ans*10+x，最后一位肯定越界</span></span><br><span class="line">            <span class="comment">// 2、当前结果和界限相等，只有ans*10+x &lt;= max时不越界</span></span><br><span class="line">            <span class="comment">//    max个位是7，也就我们的是后一位数字是8、9时越界</span></span><br><span class="line">            <span class="keyword">if</span>(ans &gt; bndry || ans == bndry &amp;&amp; c[j] &gt; <span class="string">&#x27;7&#x27;</span>) <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            ans = ans * <span class="number">10</span> + (c[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> k神究极优化版本，没有使用trim()，将时间复杂度降到O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, sign = <span class="number">1</span>, length = str.length();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span>(++i == length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;-&#x27;</span> || str.charAt(i) == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(j) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(j) &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; str.charAt(j) &gt; <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            res = res * <span class="number">10</span> + (str.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-i-er-cha-sou-suo-shu-de-zui-jin-g-7/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-i-er-cha-sou-suo-shu-de-zui-jin-g-7/</a></p>
<p>自己的解法，我们充分应用二叉搜索树的特性，左小右大，若根结点刚好处于两结点中间，说明根结点就是最小公共结点，返回根结点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">int</span> min, max;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        min = Math.min(p.val, q.val);</span><br><span class="line">        max = Math.max(p.val, q.val);</span><br><span class="line">        MinCommonNode(root, min, max); </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 充分应用二叉搜索树的特性，左小右大，若根结点刚好处于两结点中间</span></span><br><span class="line">    <span class="comment">// 说明根结点就是最小公共结点，返回根结点即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MinCommonNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= min &amp;&amp; root.val &lt;= max )&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MinCommonNode(root.left, min, max);</span><br><span class="line">        MinCommonNode(root.right, min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>K神优化：我们直接判断两个结点是否同时大于/小于根结点，若大于/小于则遍历右子树/左子树，否则就说明根结点处于二者中间，此时直接返回根结点即可，这里相当于转了一个弯，只判断结点处于同一侧子树的情况，那么其他情况一定是结点在根结点两侧，直接返回根结点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val &gt; q.val) &#123; <span class="comment">// 保证 p.val &lt; q.val</span></span><br><span class="line">            TreeNode tmp = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; p.val) <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right; <span class="comment">// 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; q.val) <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left; <span class="comment">// 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p>题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p>
<ul>
<li>根结点的左右子树分别包含一个p、q结点，此时根结点就是位于正中间，即p、q最近公共祖先</li>
<li>如果p、q结点不是分布于根结点左右两侧，说明只分布于其中的一侧<ul>
<li>位于左子树，返回递归左子树的结果即最近公共祖先</li>
<li>位于右子树，返回递归右子树的结果即最近公共祖先</li>
<li>如果两侧都没有，说明p、q并不在当前根结点下，返回空</li>
</ul>
</li>
</ul>
<p>这道题其实就是递归思路的运用，题解没看懂只能说还没理解清楚递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当前结点就是p、q返回p、q</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//左右子树均不为空，说明p、q分别位于左右子树，此时根结点即为中心，也就是最小父节点</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//上面一个if未通过，说明p、q只存在于左子树 或 右子树</span></span><br><span class="line">        <span class="comment">//左子树不为空，说明p、q同时存在于左子树，返回左子树的结果</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//右子树不为空，说明p、q同时存在于右子树，返回右子树的结果</span></span><br><span class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="comment">//左右子树均不存在p、q结点，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>K神优化版本，转换了一点点思路就优化了代码，是真的强。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根结点为空返回空，其实就是返回其本身，可以和遍历到p、q返回根结点的情况合并</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//左子树为空，说明位于右子树</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="comment">//左子树不为空，右子树为空，结点位于左子树</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//左右子树均不为空，即根结点两侧分布包含一个结点，根结点位于中间即最小公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://aidianfirst.com">aidianfirst</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aidianfirst.com/2021/05/31/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/">http://aidianfirst.com/2021/05/31/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://aidianfirst.com" target="_blank">哀殿firstの空间</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/07/blog/blog%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7/" title="blog评论系统升级"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/miku4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">blog评论系统升级</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/31/%E5%90%8E%E7%AB%AF/MyBatis%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/" title="MyBatis简单学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/yuanchuang2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis简单学习</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/aidian.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">aidianfirst</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/29529786"><i></i><span>BiliBili空间</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/aidianfirst" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1262306856&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">数组中重复的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.</span> <span class="toc-text">二维数组中的查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">3.</span> <span class="toc-text">替换空格</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">从尾到头打印链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">重建二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">用两个栈实现队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8F%98%E7%A7%8D%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">青蛙跳台（斐波那契变种）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">9.</span> <span class="toc-text">旋转数组的最小数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">10.</span> <span class="toc-text">矩阵中的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">11.</span> <span class="toc-text">机器人的运动范围</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%88n-lt-58%EF%BC%8C%E4%B8%8D%E8%80%83%E8%99%91%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">剪绳子（n&lt;&#x3D;58，不考虑大数据）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%88%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%83%85%E5%86%B5%EF%BC%8C%E8%80%83%E8%99%91%E8%B6%8A%E7%95%8C%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">剪绳子（大数据情况，考虑越界）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">二进制中1的个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-number">15.</span> <span class="toc-text">数值的整数次方</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%EF%BC%88%E5%A4%A7%E6%95%B0%E6%83%85%E5%86%B5%E5%BE%97%E9%87%8D%E6%96%B0%E7%9C%8B%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">打印从1到最大的n位数（大数情况得重新看）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">删除链表的节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-%E9%9A%BE%EF%BC%81"><span class="toc-number">18.</span> <span class="toc-text">正则表达式匹配(难！)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BC%98%E5%8C%96%E4%BA%86%E4%B8%8D%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E4%BD%9C%E6%B3%95%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">表示数值的字符串（优化了不用状态机的作法）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E6%98%AF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D"><span class="toc-number">20.</span> <span class="toc-text">调整数组顺序是奇数位于偶数前</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">21.</span> <span class="toc-text">链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">22.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">23.</span> <span class="toc-text">合并两个排序的链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">24.</span> <span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">25.</span> <span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">26.</span> <span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">27.</span> <span class="toc-text">顺时针打印矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-number">28.</span> <span class="toc-text">包含min函数的栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-number">29.</span> <span class="toc-text">栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">30.</span> <span class="toc-text">从上到下打印二叉树（层序遍历）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-number">31.</span> <span class="toc-text">从上到下打印二叉树（二）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89"><span class="toc-number">32.</span> <span class="toc-text">从上到下打印二叉树（三）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">33.</span> <span class="toc-text">二叉搜索树的后续遍历序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">34.</span> <span class="toc-text">二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">35.</span> <span class="toc-text">复杂链表的复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">36.</span> <span class="toc-text">二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">37.</span> <span class="toc-text">序列化二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89"><span class="toc-number">38.</span> <span class="toc-text">字符串的排列（回溯法）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">39.</span> <span class="toc-text">数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">40.</span> <span class="toc-text">最小的k个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">41.</span> <span class="toc-text">数据流中的中位数（堆排序）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">42.</span> <span class="toc-text">连续子数组的最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">43.</span> <span class="toc-text">1~n整数中1出现的次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">44.</span> <span class="toc-text">数字序列中某一位的数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">45.</span> <span class="toc-text">把数组排成最小的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">46.</span> <span class="toc-text">把数字翻译成字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">47.</span> <span class="toc-text">礼物的最大价值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">48.</span> <span class="toc-text">最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%91%E6%95%B0"><span class="toc-number">49.</span> <span class="toc-text">丑数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">50.</span> <span class="toc-text">第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">51.</span> <span class="toc-text">数组中的逆序对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">52.</span> <span class="toc-text">两个链表的第一个公共节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97"><span class="toc-number">53.</span> <span class="toc-text">在排序数组中查找数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">54.</span> <span class="toc-text">0~n-1中缺失的数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9"><span class="toc-number">55.</span> <span class="toc-text">二叉搜索树的第k大结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">56.</span> <span class="toc-text">二叉树的深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">57.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-number">58.</span> <span class="toc-text">数组中数字出现的次数（一）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-number">59.</span> <span class="toc-text">数组中数字出现的次数（二）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">60.</span> <span class="toc-text">和为s的两个数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-number">61.</span> <span class="toc-text">和为s的连续正数序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="toc-number">62.</span> <span class="toc-text">翻转单词顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">63.</span> <span class="toc-text">左旋转字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">64.</span> <span class="toc-text">滑动窗口的最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">65.</span> <span class="toc-text">队列的最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="toc-number">66.</span> <span class="toc-text">n个骰子的点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-number">67.</span> <span class="toc-text">扑克牌中的顺子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%EF%BC%89"><span class="toc-number">68.</span> <span class="toc-text">圆圈中最后剩下的数字（约瑟夫环）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">69.</span> <span class="toc-text">股票的最大利润</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%821-2-%E2%80%A6-n"><span class="toc-number">70.</span> <span class="toc-text">求1+2+…+n</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-number">71.</span> <span class="toc-text">不用加减乘除做加法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-number">72.</span> <span class="toc-text">构建乘积数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="toc-number">73.</span> <span class="toc-text">把字符串转换成整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">74.</span> <span class="toc-text">二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">75.</span> <span class="toc-text">二叉树的最近公共祖先</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/08/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spring/" title="Spring"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2023/12/08/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spring/" title="Spring">Spring</a><time datetime="2023-12-08T09:33:35.781Z" title="发表于 2023-12-08 17:33:35">2023-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E6%95%A3%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9/" title="散装知识点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/miku4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="散装知识点"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E6%95%A3%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9/" title="散装知识点">散装知识点</a><time datetime="2023-07-30T11:20:17.737Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Controller%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%B5%85%E6%9E%90/" title="Controller接口调用链路浅析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Controller接口调用链路浅析"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Controller%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%B5%85%E6%9E%90/" title="Controller接口调用链路浅析">Controller接口调用链路浅析</a><time datetime="2023-07-30T11:20:17.736Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spel%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81/" title="Spel字段解析功能源码浅析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spel字段解析功能源码浅析"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/Spel%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81/" title="Spel字段解析功能源码浅析">Spel字段解析功能源码浅析</a><time datetime="2023-07-30T11:20:17.736Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/" title="并发编程实战阅读学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程实战阅读学习"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%B7%A5%E4%BD%9C%20&amp;%20%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/" title="并发编程实战阅读学习">并发编程实战阅读学习</a><time datetime="2023-07-30T11:20:17.736Z" title="发表于 2023-07-30 19:20:17">2023-07-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/aidianfirst/image/conan5.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By aidianfirst</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://aidianfirst-blog.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div class="aplayer no-destroy" data-id="2532053828" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted> </div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","hOffset":50,"vOffset":-50,"width":150,"height":350},"mobile":{"show":false},"log":false});</script></body></html>